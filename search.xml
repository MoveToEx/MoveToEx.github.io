<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>公告板</title>
      <link href="posts/Notice/"/>
      <url>posts/Notice/</url>
      
        <content type="html"><![CDATA[<p>这里是公告</p><p>[2020/11/15] 仙咕下凡<br>[2020/11/15] Valine 出了点问题，评论暂时关闭</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>C++的新特性</title>
      <link href="posts/0de8ddc338d164ca/"/>
      <url>posts/0de8ddc338d164ca/</url>
      
        <content type="html"><![CDATA[<p>对一些C++11/14/17/20的比较有意思的新特性的简要介绍</p><p>仅包含一小部分比较有意思的，其他特性还请移步C++Ref</p><a id="more"></a><h1 id="C-11"><a href="#C-11" class="headerlink" title="C++11"></a>C++11</h1><h2 id="占位符类型说明符"><a href="#占位符类型说明符" class="headerlink" title="占位符类型说明符"></a>占位符类型说明符</h2><p>指示编译器自动推导变量类型的类型说明符</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">auto a &#x3D; 2;  &#x2F;&#x2F; int</span><br><span class="line">auto arr &#x3D; &#123; 1, 2, 3 &#125;; &#x2F;&#x2F; int[]</span><br><span class="line">auto ch &#x3D; &#39;a&#39;; &#x2F;&#x2F; char</span><br><span class="line">auto it &#x3D; v.begin(); &#x2F;&#x2F; vector&lt;int&gt;::iterator</span><br></pre></td></tr></table></figure><p>自C++14起能够推导函数返回值类型</p><h2 id="默认-amp-弃用函数"><a href="#默认-amp-弃用函数" class="headerlink" title="默认 &amp; 弃用函数"></a>默认 &amp; 弃用函数</h2><p>用于构造函数<br><code>default</code>指示该构造函数为默认构造函数，意即该函数默认初始化所有成员<br>一般情况下，编译器会将所有没写构造函数的类型的构造函数指定为默认构造函数<br>使用<code>default</code>强制编译器为其生成默认构造函数<br>使用<code>default</code>的类的所有成员均应满足 <em>DefaultConstructible</em> ，即该成员能够不带参数初始化，下面就是一个反例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class T &#123;</span><br><span class="line">public:</span><br><span class="line">int x, y, z;</span><br><span class="line">&#x2F;&#x2F; T() &#x3D; default;</span><br><span class="line">T(int x, int y, int z) : x(x), y(y), z(z) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">class _T &#123;</span><br><span class="line">public:</span><br><span class="line">T t;</span><br><span class="line">_T() &#x3D; default;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">_T x;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">x.t.x &#x3D; 0;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>delete</code>指示该构造函数被弃用，若该构造函数重载被使用，则程序编译失败</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class T &#123;</span><br><span class="line">public:</span><br><span class="line">int x, y, z;</span><br><span class="line">T() &#x3D; default;</span><br><span class="line">T(int x, int y) &#x3D; delete;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">T a(1, 2); &#x2F;&#x2F; Error</span><br><span class="line">T x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="常量表达式"><a href="#常量表达式" class="headerlink" title="常量表达式"></a>常量表达式</h2><p>指示当前变量编译器在编译期间就应计算出值</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> MAXN = <span class="number">5e5</span> + <span class="number">5</span>;</span><br></pre></td></tr></table></figure><p>用在变量里和<code>const</code>差不多<br>用在函数返回值里能够指示编译器当前编译的函数的返回值要在编译时计算<br>使用<code>constexpr</code>做返回值的函数传入的参数也应为<code>constexpr</code></p><h2 id="列表初始化"><a href="#列表初始化" class="headerlink" title="列表初始化"></a>列表初始化</h2><p>能够以</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Type a &#x3D; &#123; 1, 2, 3 &#125;;</span><br><span class="line">Type x &#123; 1, 2, 3 &#125;;</span><br><span class="line">Type x(&#123; 1, 2, 3 &#125;);</span><br><span class="line">func(&#123; 1, 9, 2 &#125;);</span><br></pre></td></tr></table></figure><p>等类似形式调用函数<br><code>initializer_list&lt;Type&gt;</code>代表<code>Type</code>类型的列表<br><code>l.begin()</code>为指向第一个元素的迭代器<br><code>l.end()</code>为指向最后一个元素+1的迭代器<br><code>l.size()</code>为列表元素个数</p><button class="runcode-button" file="InitializerList.cpp"></button><h2 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h2><p>又称匿名函数，是一种无需定义函数名即可调用的函数</p><p>大多长这样：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[capture] (parameters) -&gt; <span class="keyword">mutable</span> return_type &#123; body &#125;</span><br></pre></td></tr></table></figure><ul><li>Capture: 用于捕获Lambda表达式外的变量，如下：<ul><li><code>[]</code>: 不指定任何变量，使用表达式外的变量将导致CE，但是不加<code>[]</code>也会CE</li><li><code>[x]</code>: <code>x</code>按值传递</li><li><code>[&amp;x]</code>: <code>x</code>按引用传递</li><li><code>[=]</code>: 任何<strong>被使用到</strong>的外部变量按值传递</li><li><code>[&amp;]</code>: 任何<strong>被使用到</strong>的外部变量按引用传递</li><li><code>[&amp;, x]</code>: <code>x</code>按值传递，其他用到的变量按引用传递，可以改变变量的个数，不可互换位置</li><li><code>[=, &amp;x]</code>: <code>x</code>按引用传递，其他按值传递，可以改变变量的个数，不可互换位置</li><li>特别的，类或结构体中的Lambda表达式需要显式捕捉<code>this</code>指针从而使用当前对象中的成员</li><li>函数可以访问的变量有：<ul><li>参数</li><li>函数内声明的变量</li><li>对象成员</li><li>全局变量</li><li>被捕获的变量</li></ul></li></ul></li><li>Parameters: 函数的参数，定义方法和C++中一般函数相同。注意，Lambda表达式与一般函数有下列不同：<ul><li>不能有缺省值 (如<code>int fun(int a = 10)</code>)</li><li>不能有可变参数 (如<code>int fun(int cnt, ...)</code>)</li><li>不能有无名参数 (如<code>int fun(int, int) {}</code>)</li></ul></li><li><code>mutable</code>: 如果出现<code>mutable</code>， 在Capture中指定<strong>按值传入的</strong>外部变量可以被更改，否则默认其为只读变量</li><li>Return_type: 函数的返回值类型。对于<code>void</code>函数，该项和前面的<code>-&gt;</code>可省略，但不可只出现一个</li><li>Body: 函数体</li></ul><button class="runcode-button" file="Lambda.cpp"></button><h2 id="空指针"><a href="#空指针" class="headerlink" title="空指针"></a>空指针</h2><p>和<code>NULL</code>差不多<br>那为啥要加一个这玩意呐<br>因为<code>NULL</code>是一个常量，一般被定义为<code>0</code><br>所以有的时候传入<code>NULL</code>作为参数的时候<br>会调用<code>long long</code>或者<code>int</code>的重载<br>所以C++11加入了<code>nullptr</code>代表空指针<br>这玩意应该不需要例子 当<code>NULL</code>用就可以</p><h2 id="形参包"><a href="#形参包" class="headerlink" title="形参包"></a>形参包</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">template &lt;class ... Args&gt;</span><br><span class="line">class T &#123;</span><br><span class="line">&#x2F;&#x2F; ...</span><br><span class="line">&#125;;</span><br><span class="line">T&lt;&gt; t;</span><br><span class="line">T&lt;int&gt; t2;</span><br><span class="line">T&lt;int, int, long, double&gt; t3;</span><br></pre></td></tr></table></figure><p>可变长度的<code>template</code>参数<br>也可用于定义函数等<br>函数的模板可以通过推导由编译器填入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">template &lt;class ... Args&gt;</span><br><span class="line">void f(Args...x) &#123;&#125;</span><br><span class="line"></span><br><span class="line">f();</span><br><span class="line">f(1);</span><br><span class="line">f(1, 2, 3.0, &quot;awsl&quot;);</span><br></pre></td></tr></table></figure><p>形参包可以展开</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">f(&amp;args...); &#x2F;&#x2F; &#x3D;&gt; f(&amp;arg1, &amp;arg2, ...);</span><br><span class="line">f(n, ++args...); &#x2F;&#x2F; &#x3D;&gt; f(n, ++arg1, ++arg2, ...);</span><br><span class="line">f(g(args...) + args...) &#x2F;&#x2F; &#x3D;&gt; f(g(arg1, arg2, ...) + arg1, g(arg1, arg2, ...) + arg2, ...);</span><br></pre></td></tr></table></figure><p>但是好像没啥用的样子<br>C++17加入表达式折叠</p><p>顺便，这玩意可以写快读</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Ty</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">read</span>(<span class="title">Ty</span> &amp;<span class="title">x</span>) &#123;</span></span><br><span class="line">x = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">char</span> ch = getchar();</span><br><span class="line"><span class="keyword">int</span> f = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) &#123;</span><br><span class="line"><span class="keyword">if</span> (ch == <span class="string">'-'</span>) f = -f;</span><br><span class="line">ch = getchar();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) &#123;</span><br><span class="line">x = x * <span class="number">10</span> + ch - <span class="string">'0'</span>;</span><br><span class="line">ch = getchar();</span><br><span class="line">&#125;</span><br><span class="line">x *= f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Ty</span>, <span class="title">class</span> ... <span class="title">Var</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">read</span>(<span class="title">Ty</span>&amp; <span class="title">x</span>, <span class="title">Var</span>&amp;... <span class="title">args</span>) &#123;</span></span><br><span class="line">read(x);</span><br><span class="line">read(args...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="属性说明符"><a href="#属性说明符" class="headerlink" title="属性说明符"></a>属性说明符</h2><p>比较奇怪的东西</p><blockquote><p>为类型、对象、代码等引入由实现定义的属性。</p></blockquote><p>几乎可以用于所有东西</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[[attr]]</span><br><span class="line">[[attr1, attr2(arg), ...]]</span><br><span class="line">[[namespace::attr1, ...]]</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[[noreturn]]</span><br><span class="line">void f() &#123;</span><br><span class="line">throw std::runtime_error(&quot;qwq&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以下是C++标准属性的一部分：</p><table><thead><tr><th style="text-align:center">属性</th><th style="text-align:center">含义</th><th style="text-align:center">C++版本</th></tr></thead><tbody><tr><td style="text-align:center"><code>[[noreturn]]</code></td><td style="text-align:center">函数不返回(抛出错误)</td><td style="text-align:center">11</td></tr><tr><td style="text-align:center"><code>[[deprecated]]</code>/<code>[[deprecated(&quot;reason&quot;)]]</code></td><td style="text-align:center">函数不推荐使用(由于 <em>reason</em>)，但允许使用</td><td style="text-align:center">14</td></tr><tr><td style="text-align:center"><code>[[nodiscard]]</code></td><td style="text-align:center">函数返回值不应被舍弃，否则输出警告</td><td style="text-align:center">17</td></tr><tr><td style="text-align:center"><code>[[maybe_unused]]</code></td><td style="text-align:center">函数的参数可能有未使用的参数，指示编译器不输出警告</td><td style="text-align:center">17</td></tr></tbody></table><p>其他C++标准属性请从页面底部跳转至C++Ref查看<br>编译器独有的属性请到编译器文档查看</p><h2 id="基于范围的for"><a href="#基于范围的for" class="headerlink" title="基于范围的for"></a>基于范围的for</h2><p>在范围上执行<code>for</code><br>值得注意的是，C++的<code>for (auto i : v)</code>不同于JS的<code>for (i in v)</code>，范围<code>for</code>的变量<code>i</code>不是键而是值<br>意即<code>v = { 3, 2, 1 }</code>时,<code>for (int i : v)</code>每轮<code>i</code>的值分别为<code>3, 2, 1</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;int&gt; v &#x3D; &#123; 1, 9, 2, 6, 0, 8, 1, 7 &#125;;</span><br><span class="line">for (int i : v) &#123;</span><br><span class="line">cout &lt;&lt; i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自C++17起，可以使用<code>auto [x, y]</code>的结构化绑定形式</p><button class="runcode-button" file="RangeBasedFor.cpp"></button><h1 id="C-14"><a href="#C-14" class="headerlink" title="C++14"></a>C++14</h1><p>C++14 没啥比较好玩的东西 少写点吧<br><del>毕竟 C++Ref 的 C++14 都没啥东西</del></p><h2 id="变量模板"><a href="#变量模板" class="headerlink" title="变量模板"></a>变量模板</h2><p>顾名思义，变量也有模板了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">template &lt;class T&gt;</span><br><span class="line">T x &#x3D; 114514;</span><br></pre></td></tr></table></figure><h2 id="文本运算符"><a href="#文本运算符" class="headerlink" title="文本运算符"></a>文本运算符</h2><p>就像复数的赋值一样</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">complex x &#x3D; 2i;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">TYPE operator &quot;&quot; CHAR (TYPE ARG) &#123;</span><br><span class="line">&#x2F;&#x2F; ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，参数的类型只能是<code>unsigned long long</code>或<code>char</code><br><code>char</code>除了<code>_</code>之外的单个字符会报警告<br>且这种函数不能作为成员函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int operator&quot;&quot; _ (char ch) &#123;</span><br><span class="line">return isdigit(ch) ? ch - &#39;0&#39; : (isupper(ch) ? ch - &#39;A&#39; + 10 : ch - &#39;a&#39; + 10);</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">cout &lt;&lt; &#39;f&#39;_ &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出<code>15</code></p><h1 id="C-17"><a href="#C-17" class="headerlink" title="C++17"></a>C++17</h1><h2 id="折叠表达式"><a href="#折叠表达式" class="headerlink" title="折叠表达式"></a>折叠表达式</h2><p>以如下方式展开形参包：</p><ol><li>一元右折叠<code>(E opt ...)</code> =&gt; <code>(E1 opt (E2 opt ... (En-1 opt En)))</code></li><li>一元左折叠<code>(... opt E)</code> =&gt; <code>(((E1 opt E2) opt ...) opt En)</code></li><li>二元右折叠<code>(E opt ... opt I)</code> =&gt; <code>(E1 opt (... opt (En-1 opt (En opt I))))</code></li><li>二元左折叠<code>(I opt ... opt E)</code> =&gt; <code>((((I opt E1) opt E2) opt ...) opt En)</code></li></ol><p>如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">template &lt;class...Ty&gt;</span><br><span class="line">bool all(Ty... args) &#123;</span><br><span class="line">return (... &amp;&amp; args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool b &#x3D; all(true, false, true, true); </span><br><span class="line">&#x2F;&#x2F; &#x3D;&gt; ((true &amp;&amp; false) &amp;&amp; true) &amp;&amp; true</span><br><span class="line">&#x2F;&#x2F; &#x3D; false</span><br></pre></td></tr></table></figure><p>一元折叠用于零长度的包展开时，仅允许以下运算符：</p><ol><li><code>&amp;&amp;</code>, 值为<code>true</code></li><li><code>||</code>, 值为<code>false</code></li><li><code>,</code>, 值为<code>void()</code></li></ol><h2 id="结构化绑定"><a href="#结构化绑定" class="headerlink" title="结构化绑定"></a>结构化绑定</h2><blockquote><p>绑定指定名称到初始化器的子对象或元素。<br>类似引用，结构化绑定是既存对象的别名。不同于引用的是，结构化绑定的类型不必为引用类型。</p></blockquote><p>大概这样用:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">auto &#x2F;* Ref Opt *&#x2F; [ &#x2F;* List *&#x2F; ] &#x3D; &#x2F;* Expression *&#x2F;;&#x2F;&#x2F; 1</span><br><span class="line">auto &#x2F;* Ref Opt *&#x2F; [ &#x2F;* List *&#x2F; ] &#123; &#x2F;* Expression *&#x2F; &#125;;&#x2F;&#x2F; 2</span><br><span class="line">auto &#x2F;* Ref Opt *&#x2F; [ &#x2F;* List *&#x2F; ] ( &#x2F;* Expression *&#x2F; );&#x2F;&#x2F; 3</span><br></pre></td></tr></table></figure><p>其中<code>List</code>为标识符列表，<code>Expression</code>为表达式</p><p>请注意<code>Expression</code>的顶层不应含有<code>,</code>(文法上为 <em>赋值表达式</em>)，且其类型为数组或非<code>union</code><br><code>Expression</code>不应含有<code>List</code>中的标识符</p><p>例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">int a[] &#x3D; &#123; 2, 3, 3 &#125;;</span><br><span class="line">auto [x, y, z] &#x3D; a;</span><br><span class="line">cout &lt;&lt; x &lt;&lt; y &lt;&lt; z &lt;&lt; endl;&#x2F;&#x2F; Output 233</span><br><span class="line">&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;</span><br><span class="line">tuple&lt;int, char, string&gt; tpl(2, &#39;3&#39;, &quot;3&quot;);</span><br><span class="line">auto [x, y, z] &#x3D; tpl;</span><br><span class="line">&#x2F;&#x2F; auto [x, y, z] &#x3D; make_tuple(2, &#39;3&#39;, &quot;3&quot;);</span><br><span class="line">cout &lt;&lt; x &lt;&lt; y &lt;&lt; z &lt;&lt; endl;&#x2F;&#x2F; Output 233</span><br><span class="line">&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;</span><br><span class="line">int a[] &#x3D; &#123; 1, 2, 3 &#125;;</span><br><span class="line">auto&amp; [x, y, z] &#x3D; a;</span><br><span class="line">x &#x3D; 2, y &#x3D; 3;</span><br><span class="line">cout &lt;&lt; a[0] &lt;&lt; a[1] &lt;&lt; a[2];&#x2F;&#x2F; Output 233</span><br><span class="line">&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;</span><br><span class="line">struct S &#123;</span><br><span class="line">int a, b, c;</span><br><span class="line">S() &#x3D; default;</span><br><span class="line">S(int a, int b, int c) : a(a), b(b), c(c) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">S f() &#123; return S(2, 3, 3); &#125;</span><br><span class="line">auto [x, y, z] &#x3D; f();</span><br><span class="line">cout &lt;&lt; x &lt;&lt; y &lt;&lt; z &lt;&lt; endl;&#x2F;&#x2F; Output 233</span><br></pre></td></tr></table></figure><h2 id="任意类型的单个值"><a href="#任意类型的单个值" class="headerlink" title="任意类型的单个值"></a>任意类型的单个值</h2><p>头文件<code>&lt;any&gt;</code></p><p>逐渐向JS靠拢？（雾</p><p>正如其名，<code>any</code>可以存储任何类型的值<br><code>any::type()</code>可以返回类型的<code>typeid</code><br><code>any::reset()</code>可以销毁所含值<br><code>any::swap()</code>可以交换两个<code>any</code><br><code>any_cast&lt;Type&gt;(Any)</code>可以访问<code>Any</code>所容纳的对象，若类型错误会抛出<code>std::bad_any_cast</code>异常</p><button class="runcode-button" file="Any.cpp"></button><h2 id="可选值"><a href="#可选值" class="headerlink" title="可选值"></a>可选值</h2><p>头文件<code>&lt;optional&gt;</code><br>顾名思义，可以存在也可以不存在的值</p><p>空<code>optional</code>一般为<code>nullopt</code><br><code>optional::value()</code>可获取<code>*this</code>中存储的值，若<code>*this</code>不含值则抛出<code>std::bad_optional_access</code><br><code>optional::has_value()</code>可检查<code>*this</code>中是否有值，有则返回<code>true</code>，否则返回<code>false</code><br><code>optional::value_or(val)</code>在<code>*this</code>含有值则返回其存储的值，否则返回<code>val</code><br>运算符重载：</p><ul><li><code>operator *</code>/<code>operator -&gt;</code> - 访问<code>*this</code>中存储的值，不检查是否含值，若不含值则返回默认构造的值</li><li><code>operator bool</code> - 和<code>has_value()</code>等价</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">optional&lt;int&gt; proc(int x) &#123;</span><br><span class="line">if (!x) &#123;</span><br><span class="line">return nullopt;</span><br><span class="line">&#125;</span><br><span class="line">return x &lt;&lt; 1;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;</span><br><span class="line">optional&lt;int&gt; ans &#x3D; f();</span><br><span class="line">if (ans) &#123;&#x2F;&#x2F; operator bool()</span><br><span class="line">&#x2F;&#x2F; if (ans.has_value()) &#123;</span><br><span class="line">&#x2F;&#x2F; ...</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">&#x2F;&#x2F; ...</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;</span><br><span class="line">optional&lt;int&gt; ans &#x3D; f();</span><br><span class="line">try &#123;</span><br><span class="line">cout &lt;&lt; f.value() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">catch (exception&amp; e) &#123;</span><br><span class="line">cout &lt;&lt; e.what() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="C-20"><a href="#C-20" class="headerlink" title="C++ 20"></a>C++ 20</h1><h2 id="格式化"><a href="#格式化" class="headerlink" title="格式化"></a>格式化</h2><p><code>sprintf</code>的安全替代品</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">string s &#x3D; format(&quot;&#123;&#125; &#123;&#125; &#123;&#125;&quot;, &quot;Hello&quot;, &quot;C++&quot;, 20); &#x2F;&#x2F; s &#x3D;&#x3D; &quot;Hello C++ 20&quot;</span><br></pre></td></tr></table></figure><p>若提供的参数少于字符串中的<code>{}</code>个数，行为未定义<br>提供的参数多于字符串中的<code>{}</code>个数没关系</p><h2 id="三路比较运算符"><a href="#三路比较运算符" class="headerlink" title="三路比较运算符"></a>三路比较运算符</h2><p>形式为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x &lt;&#x3D;&gt; y</span><br></pre></td></tr></table></figure><p>表达式返回一个值，使得</p><ul><li><code>x &lt; y</code>则<code>(x &lt;=&gt; y) &lt; 0</code></li><li><code>x &gt; y</code>则<code>(x &lt;=&gt; y) &gt; 0</code></li><li><code>x == y</code>则<code>(x &lt;=&gt; y) == 0</code></li></ul><h2 id="聚合初始化"><a href="#聚合初始化" class="headerlink" title="聚合初始化"></a>聚合初始化</h2><p>不好说，看示例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct S &#123;</span><br><span class="line">int x, y, z;</span><br><span class="line">&#125;;</span><br><span class="line">S a &#x3D; &#123; .x &#x3D; 1, .y &#x3D; 2 &#125;;</span><br><span class="line">&#x2F;&#x2F; S c &#x3D; &#123; .y &#x3D; 1, .x &#x3D; 2 &#125; &#x2F;&#x2F; Error</span><br></pre></td></tr></table></figure><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>MoveToEx被<code>concept</code>整懵了，所以先写点能够理解的吧</p><p>所谓概念，是一种辅助编译器以及开发者定位问题的东西</p><p>C++Ref 如此描述概念的优点：</p><blockquote><p>在编译时检测约束违规，在模板实例化过程的早期进行，这导致错误信息更易理解。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; l = &#123;<span class="number">3</span>,<span class="number">-1</span>,<span class="number">10</span>&#125;;</span><br><span class="line"><span class="built_in">std</span>::sort(l.begin(), l.end()); </span><br><span class="line"><span class="comment">//无概念的典型编译器诊断：</span></span><br><span class="line"><span class="comment">//  invalid operands to binary expression ('std::_List_iterator&lt;int&gt;' and</span></span><br><span class="line"><span class="comment">//  'std::_List_iterator&lt;int&gt;')</span></span><br><span class="line"><span class="comment">//                           std::__lg(__last - __first) * 2);</span></span><br><span class="line"><span class="comment">//                                     ~~~~~~ ^ ~~~~~~~</span></span><br><span class="line"><span class="comment">// …… 50 行输出……</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//有概念的典型编译器诊断：</span></span><br><span class="line"><span class="comment">//  error: cannot call std::sort with std::_List_iterator&lt;int&gt;</span></span><br><span class="line"><span class="comment">//  note:  concept RandomAccessIterator&lt;std::_List_iterator&lt;int&gt;&gt; was not satisfied</span></span><br></pre></td></tr></table></figure><p>咕咕咕~</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> 新特性 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> C++11 </tag>
            
            <tag> C++14 </tag>
            
            <tag> C++17 </tag>
            
            <tag> C++20 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MoveToEx的毒瘤码风</title>
      <link href="posts/901a09ed661aa5e7/"/>
      <url>posts/901a09ed661aa5e7/</url>
      
        <content type="html"><![CDATA[<p>我来氵博客了/cy</p><a id="more"></a><p>我的码风大致上和Visual Studio自动格式化的一个样（（（<br>大概是那段时间VS用多了<br>然后就习惯了</p><p>由于MoveToEx的码风很毒瘤，本篇比较长（<br>没有提及的东西大多都可以用提到的东西拼出来</p><h1 id="Basic"><a href="#Basic" class="headerlink" title="Basic"></a>Basic</h1><h2 id="空格-amp-换行"><a href="#空格-amp-换行" class="headerlink" title="空格 &amp; 换行"></a>空格 &amp; 换行</h2><p>4空格或1Tab缩进<br>能加空格的地方只要加上好看基本都会加<br>大括号不换行</p><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><h3 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h3><p>普通变量的声明没啥好说的<br>如果在一行声明单个指针变量，<code>*</code>靠近数据类型，否则<code>*</code>靠近变量名<br>使用<code>=</code>而不是构造函数进行变量初始化</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">1001</span>];</span><br><span class="line"><span class="built_in">string</span> s = <span class="string">"qwq"</span>;</span><br><span class="line"><span class="keyword">int</span>* p;</span><br><span class="line">Node* root = <span class="keyword">new</span> Node();</span><br><span class="line"><span class="keyword">int</span> *_a, *_b;</span><br></pre></td></tr></table></figure><h3 id="命名"><a href="#命名" class="headerlink" title="命名"></a>命名</h3><p>极简命名<br>能用三个字母以内的一般都会用<br>有多个相似含义变量时不会用<code>l</code>,<code>ll</code>,<code>L</code>,<code>LL</code>一类的变量名<br>（我喜欢在前边加下划线</p><p>对于图，常用的有：<br><code>n</code>, <code>m</code>, <code>e</code>(Edge), <code>ec</code>(Edge Count), <code>first</code>, <code>u</code>(from), <code>v</code>(to), <code>w</code>, <code>scc</code>(Strong Connected Component), <code>vis</code>(VISited), <code>dfn</code><br>对于树，常用的有：<br><code>n</code>, <code>fa</code>(FAther), <code>son</code>, <code>ls</code>(Left Son), <code>rs</code>(Right Son), <code>siz</code>(SIZe of subtree), <code>dep</code>(DEPth), <code>seg</code>(position in SEGment tree), <code>dfn</code>, <code>top</code><br>对于STL，常用的有：<br><code>q</code>(<code>queue</code>,<code>deque</code>,<code>priority_queue</code>), <code>pq</code>(<code>priority_queue</code>，当且仅当<code>q</code>被占用),<code>st</code>(<code>stack</code>), <code>s</code>(<code>string</code>), <code>it</code>(<code>iterator</code>)<br>其他常用的有：<br><code>p</code>(Pointer), <code>opt</code>(OPeraTion), <code>idx</code>(InDeX), <code>cnt</code>(CouNT), <code>tot</code>(TOTal), <code>ans</code>(ANSwer), <code>suc</code>(SUCcess), <code>pos</code>(POSition), <code>dx</code>(Delta X), <code>dy</code>(Delta Y), <code>mid</code>(MIDdle)</p><h3 id="运算"><a href="#运算" class="headerlink" title="运算"></a>运算</h3><p>运算数和运算符之间有空格<br>括号和里面的东西之间没有空格<br>整个括号和一个变量处理方法相同<br>需要显式转换的时候会用<code>type(val)</code>的构造函数形式<br>当然有的时候条件不允许就没办法了<br>（比如<code>#define int long long</code>然后<code>int(0)</code>就会CE</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = b;</span><br><span class="line">a = <span class="keyword">int</span>(p);</span><br><span class="line"><span class="keyword">int</span>* x = &amp;a;</span><br><span class="line"><span class="keyword">int</span> t = a + ((b + (c + d)) &lt;&lt; <span class="number">1</span> | <span class="number">1</span>);</span><br></pre></td></tr></table></figure><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>不加空格</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">101</span>];</span><br><span class="line">a[<span class="number">0</span>] = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><p>每个参数后的<code>,</code>与下一个参数之间有空格<br>适用于函数调用&amp;函数声明</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">"%c%c%c"</span>, <span class="string">'q'</span>, <span class="string">'w'</span>, <span class="string">'q'</span>);</span><br></pre></td></tr></table></figure><h3 id="函数体"><a href="#函数体" class="headerlink" title="函数体"></a>函数体</h3><p>函数体一律放在主函数之前<br>带有可变参数列表的在<code>...</code>前加空格</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">qwq</span><span class="params">(<span class="keyword">int</span> n, ...)</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><h3 id="调用"><a href="#调用" class="headerlink" title="调用"></a>调用</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure><h3 id="函数名"><a href="#函数名" class="headerlink" title="函数名"></a>函数名</h3><p>基本上也就那几个<br><code>check</code> 二分的checker或用于检查一个答案是否合法<br><code>calc</code>/<code>solve</code> 计算值<br><code>dfs</code>/<code>bfs</code> 搜索<br><code>init</code> 预处理<br><code>clear</code> 多测清空<br><code>find</code> 找符合条件的值<br>…</p><h2 id="条件判断"><a href="#条件判断" class="headerlink" title="条件判断"></a>条件判断</h2><h3 id="if-else"><a href="#if-else" class="headerlink" title="if-else"></a>if-else</h3><p><code>if</code>和<code>(</code>之间有空格<br><code>)</code>和<code>{</code>之间有空格<br><code>}</code>和<code>else</code>之间换行<br><code>else</code>和<code>{</code>之间有空格</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="comment">/* Condition */</span>) &#123;</span><br><span class="line"><span class="comment">// Code</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (<span class="comment">/* Condition */</span>) &#123;</span><br><span class="line"><span class="comment">// Code</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// Code</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="switch-case-default"><a href="#switch-case-default" class="headerlink" title="switch-case-default"></a>switch-case-default</h3><p><code>switch</code>和<code>(</code>之间有空格<br><code>)</code>和<code>{</code>之间有空格<br><code>case</code>和<code>default</code>标签缩进多1个Tab<br><code>:</code>和<code>{</code>之间有空格<br><code>case</code>和<code>default</code>中的代码缩进多1个Tab</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (<span class="comment">/* Variable */</span>) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="comment">/* Value */</span>: &#123;</span><br><span class="line"><span class="comment">// Code</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">default</span>: &#123;</span><br><span class="line"><span class="comment">// Code</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="三目"><a href="#三目" class="headerlink" title="三目"></a>三目</h3><p>空格能加就加<br>有的时候为了避免优先级问题会加一堆括号</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a &gt; b ? a : b;</span><br></pre></td></tr></table></figure><h2 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h2><h3 id="for"><a href="#for" class="headerlink" title="for"></a>for</h3><p><code>for</code>和<code>(</code>有空格<br>每个<code>;</code>和其后的东西有空格<br><code>)</code>和<code>{</code>有空格</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="comment">/* Expression */</span>; <span class="comment">/* Condition */</span>; <span class="comment">/* Expression */</span>) &#123;</span><br><span class="line"><span class="comment">// Code</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="while"><a href="#while" class="headerlink" title="while"></a>while</h3><p><code>while</code>和<code>(</code>有空格<br><code>)</code>和<code>{</code>有空格</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="comment">/* Condition */</span>) &#123;</span><br><span class="line"><span class="comment">// Code</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>特别地，当多组数据循环<code>t</code>次时：<br></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (t --&gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">// Code</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h3 id="do-while"><a href="#do-while" class="headerlink" title="do-while"></a>do-while</h3><p>不常用，忽略</p><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p>NULL</p><h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>一般会用<code>#define</code>而不是<code>const int</code>之类<br>常量名也就那几个<br><code>Ha</code> = 取模的数<br><code>MAXN</code>/<code>MAXM</code> = 数据上限</p><h3 id="常用"><a href="#常用" class="headerlink" title="常用"></a>常用</h3><p>一些奇奇怪怪的<code>define</code>出来的东西</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> for_each(it, a) for (auto it = a.begin(); it != a.end(); ++it)</span></span><br></pre></td></tr></table></figure><h1 id="Advanced"><a href="#Advanced" class="headerlink" title="Advanced"></a>Advanced</h1><h2 id="class"><a href="#class" class="headerlink" title="class"></a>class</h2><p><code>CLASS_NAME</code>和<code>{</code>之间有空格<br><code>public</code>,<code>private</code>/<code>protected</code>比<code>class</code>多一级缩进<br>成员和<code>public</code>/<code>private</code>/<code>protected</code>相同缩进<br>构造函数会尽量用<code>Class() = default</code>形式<br>如果<code>default</code>不能用会用<code>Class() : val1(0), val2(0) {}</code>的形式</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> /* <span class="title">Name</span> */ &#123;</span></span><br><span class="line"><span class="keyword">public</span>;</span><br><span class="line"><span class="comment">/* Name */</span>() = <span class="keyword">default</span>;</span><br><span class="line">~<span class="comment">/* Name */</span>() &#123;&#125;</span><br><span class="line"><span class="comment">/* Type */</span> <span class="comment">/* Member */</span>(<span class="comment">/* Args */</span>) &#123;</span><br><span class="line"><span class="comment">// Code</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="λ表达式"><a href="#λ表达式" class="headerlink" title="λ表达式"></a>λ表达式</h2><p><code>[]()</code>和<code>-&gt;</code>之间有空格<br><code>-&gt;</code>和返回值类型之间有空格<br>类型和函数体之间有空格</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> func = [](<span class="comment">/* Args */</span>) -&gt; <span class="comment">/* Type */</span> &#123; <span class="comment">/* Code */</span> &#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 灌水区 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 代码风格 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「题解」 SPOJ BALNUM</title>
      <link href="posts/aa64ca17909928ae/"/>
      <url>posts/aa64ca17909928ae/</url>
      
        <content type="html"><![CDATA[<p>数位+状压的毒瘤（恼<br><del>算法标签的暴力枚举是啥啊！</del></p><a id="more"></a><p><a href="https://www.luogu.com.cn/problem/SP10606" target="_blank" rel="noopener">Luogu - SP10606</a><br><a href="https://www.spoj.com/problems/BALNUM/" target="_blank" rel="noopener">SPOJ BALNUM</a></p><h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><p>给定$l,r$，问有多少$l,r$之间的数满足「偶数出现奇数次，奇数出现偶数次」</p><p>$1 \leq l,r \leq 10^{19}$</p><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>看题面和数据范围显然是数位DP</p><blockquote><p>数位DP<br>看到number我就知道了</p><p style="text-align:right">–Herself32</p></blockquote><p>orz herself32</p><p>至于状态……<br>$f[dep][c_0][c_1][c_2][c_3][c_4][c_5][c_6][c_7][c_8][c_9]$<br>长度为$dep$,若$c_i$的值为$2$表示$i$没有出现，否则为出现次数对2取模后的结果<br>这种东西硬写的话<code>dfs</code>的片段应该是非常壮观的<br>但是用<code>vector</code>的话会慢死<br>所以状压一下<br>由于$c_i$最大是2，所以为每个数分配2个位就够了<br>这样用的空间最大大概是$8 \times 20 \times (1 \operatorname{Lsh} 20) = 160 \times 2^{20} = 1.6e8 \text{Bytes} = 160 \text{MiB}$，能过<br>为了写起来方便，把0-9倒过来压，即$x \operatorname{Rsh} (2n) \operatorname{And} 3$(<code>(x &gt;&gt; (n &lt;&lt; 1)) &amp; 3</code>)表示$c_n$<br>然后就是数位DP老套路了<br>MoveToEx很菜，如果状压写的不好，在吊打他的时候请手下留情</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><div class="note warning">反作弊</div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> get(x, n) (((x) &gt;&gt; ((n) &lt;&lt; 1)) &amp; 3)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"></span><br><span class="line">ull f[<span class="number">21</span>][<span class="number">1</span> &lt;&lt; <span class="number">20</span>];</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">21</span>];</span><br><span class="line"><span class="keyword">int</span> t;</span><br><span class="line">ull l, r;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> n, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">x &amp;= (~(<span class="number">3</span> &lt;&lt; (n * <span class="number">2</span>)));</span><br><span class="line">x |= (v &lt;&lt; (n * <span class="number">2</span>));</span><br><span class="line"><span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ull <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> dep, <span class="keyword">int</span> x, <span class="keyword">int</span> zro, <span class="keyword">int</span> equ)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!dep) &#123;</span><br><span class="line">ull ans = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">9</span>; ++i, x &gt;&gt;= <span class="number">2</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (i &amp; <span class="number">1</span>) ans = ans &amp;&amp; ((x &amp; <span class="number">3</span>) ^ <span class="number">1</span>);</span><br><span class="line"><span class="keyword">else</span> ans = ans &amp;&amp; (x &amp; <span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!equ &amp;&amp; zro &amp;&amp; ~f[dep][x]) <span class="keyword">return</span> f[dep][x];</span><br><span class="line">ull ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> lim = equ ? a[dep] : <span class="number">9</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= lim; ++i) &#123;</span><br><span class="line"><span class="keyword">if</span> (!i) &#123;</span><br><span class="line">ans += dfs(dep - <span class="number">1</span>, change(x, <span class="number">0</span>, zro ? ((x &amp; <span class="number">3</span>) == <span class="number">2</span> ? <span class="number">1</span> : !(x &amp; <span class="number">3</span>)) : (x &amp; <span class="number">3</span>)), zro, equ &amp;&amp; i == lim);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">ans += dfs(dep - <span class="number">1</span>, change(x, i, get(x,i) == <span class="number">2</span> ? <span class="number">1</span> : !get(x,i)), <span class="number">1</span>, equ &amp;&amp; i == lim);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!equ) f[dep][x] = ans;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ull <span class="title">solve</span><span class="params">(ull x)</span> </span>&#123;</span><br><span class="line">a[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (x) &#123;</span><br><span class="line">a[++a[<span class="number">0</span>]] = x % <span class="number">10</span>;</span><br><span class="line">x /= <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dfs(a[<span class="number">0</span>], <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(f, <span class="number">0xff</span>, <span class="keyword">sizeof</span>(f));</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line"><span class="keyword">while</span> (t --&gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; l &gt;&gt; r;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; (solve(r) - solve(l - <span class="number">1</span>)) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题解 </tag>
            
            <tag> 数位DP </tag>
            
            <tag> 状压DP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>毒瘤二进制</title>
      <link href="posts/586658d6dc74ab44/"/>
      <url>posts/586658d6dc74ab44/</url>
      
        <content type="html"><![CDATA[<p><span style="font-size:48px">咕咕咕</span><br>咕了挺长时间了……甚至一度被PayPhone-X神仙怀疑换域名了……</p><p>那么今天就更一期<br>依旧是关于毒瘤</p><a id="more"></a><p>二进制的概念及转换等相信各位非常熟悉<br>在此不再涉及</p><p>本文主要涉及一些知道的人相对较少的东西</p><p>本文写的比较仓促<br>有的东西想加但是来不及加<br>但是再不更新恐怕就没时间更了<br>所以有些地方涉及的比较浅<br>敬请谅解</p><h1 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h1><h2 id="按位与-amp"><a href="#按位与-amp" class="headerlink" title="按位与 (&amp;)"></a>按位与 (&amp;)</h2><p>都为1时则为1，否则为0</p><p>即</p><p>$0\ \&amp;\ 0 = 0$<br>$0\ \&amp;\ 1 = 0$<br>$1\ \&amp;\ 0 = 0$<br>$1\ \&amp;\ 1 = 1$</p><h2 id="按位或"><a href="#按位或" class="headerlink" title="按位或 (|)"></a>按位或 (|)</h2><p>两个数有一个为1时即为1，否则为0</p><p>即</p><p>$0\ |\ 0 = 0$<br>$0\ |\ 1 = 1$<br>$1\ |\ 0 = 1$<br>$1\ |\ 1 = 1$</p><h2 id="按位取反"><a href="#按位取反" class="headerlink" title="按位取反 (~)"></a>按位取反 (~)</h2><p>对一个数的每一位取反</p><p>$\text{~}0=1$<br>$\text{~}1=0$</p><h2 id="异或"><a href="#异或" class="headerlink" title="异或 (^)"></a>异或 (^)</h2><p>两个数相同则为0，否则为1<br>又称不进位加法</p><p>即</p><p>$0 \text{^} 0 = 0$<br>$0 \text{^} 1 = 1$<br>$1 \text{^} 0 = 1$<br>$1 \text{^} 1 = 0$</p><h1 id="毒瘤"><a href="#毒瘤" class="headerlink" title="毒瘤"></a>毒瘤</h1><p><del>MoveToEx最爱的毒瘤时间</del></p><h2 id="位运算加法"><a href="#位运算加法" class="headerlink" title="位运算加法"></a>位运算加法</h2><p>既然异或被称为不进位加法<br>那么不进位加法处理一下进位不就是加法了吗</p><p>若$a$和$b$的二进制没有重合部分(不用处理进位，即<code>a &amp; b == 0</code>), 那么<code>a + b == a | b</code><br>否则，令<code>a = a ^ b</code>, <code>b = (a &amp; b) &lt;&lt; 1</code>，递归</p><p>手动模拟一遍，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">  0011 0011</span><br><span class="line">+ 0101 1101</span><br><span class="line">-------------</span><br><span class="line">&#x3D; 0110 1110</span><br><span class="line">+ 0010 0010</span><br><span class="line">-------------</span><br><span class="line">&#x3D; 0100 1100</span><br><span class="line">+ 0100 0100</span><br><span class="line">-------------</span><br><span class="line">&#x3D; 0000 1000</span><br><span class="line">+ 1000 1000</span><br><span class="line">-------------</span><br><span class="line">&#x3D; 0000 0000</span><br><span class="line">+ 1001 0000</span><br><span class="line">-------------</span><br><span class="line">&#x3D; 1001 0000</span><br></pre></td></tr></table></figure><p>不是我不想用MathJax啊 这玩意渲染出来不正常啊</p><p>以上方法对负数同样适用</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> (!(a &amp; b)) ? (a | b) : (vac(a ^ b, (a &amp; b) &lt;&lt; <span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="0-1-0-2"><a href="#0-1-0-2" class="headerlink" title="0.1 + 0.2"></a>0.1 + 0.2</h2><p>相信经常刷知乎的人一定刷到过这个东西</p><p>显然$0.1+0.2=0.3$<br>但是把这个放到C++里跑一遍</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; fixed &lt;&lt; setprecision(<span class="number">17</span>) &lt;&lt; (<span class="number">0.1</span> + <span class="number">0.2</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0.30000000000000004</span><br></pre></td></tr></table></figure><p>???</p><p>这种问题同样存在于其他语言中</p><p>C:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%.17f\n"</span>, <span class="number">0.1</span> + <span class="number">0.2</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0.30000000000000004</span><br></pre></td></tr></table></figure><p>Python3:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">.1</span>+<span class="number">.2</span></span><br><span class="line"><span class="number">0.30000000000000004</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>_</span><br></pre></td></tr></table></figure><p>NodeJS:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="number">0.1</span>+<span class="number">0.2</span></span><br><span class="line"><span class="number">0.30000000000000004</span></span><br><span class="line">&gt; <span class="number">0.1</span>+<span class="number">0.2</span> == <span class="number">0.3</span></span><br><span class="line"><span class="literal">false</span></span><br><span class="line">&gt; _</span><br></pre></td></tr></table></figure><p>ZSH:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> ~ &gt; <span class="built_in">echo</span> <span class="string">"<span class="variable">$((.1+.2)</span>)"</span></span><br><span class="line">0.30000000000000004</span><br></pre></td></tr></table></figure><p>人间迷惑行为大赏啊</p><p>这是为什么呢</p><p>因为 C++, Python, Javascript 等这些语言都使用 IEEE 二进制浮点数标准</p><p>因为这个博主懒，就拿单精度浮点数讲吧</p><h3 id="IEEE"><a href="#IEEE" class="headerlink" title="IEEE"></a>IEEE</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sign exponent           fraction</span><br><span class="line"> ↓  ┌───┴──┐  ┌───────────┴───────────┐</span><br><span class="line">[0][00000000][0000000 00000000 00000000]</span><br><span class="line"> ↑         ↑                          ↑</span><br><span class="line">e+f        f                          0</span><br></pre></td></tr></table></figure><p><del>MoveToEx擅长于把代码块玩出花</del></p><p>下方的数字代表该位为内存地址中从低位（最右）到高位（最左）是第几位</p><p>$e$为$\text{exponent}$的二进制位数<br>$f$为$\text{fraction}$的二进制位数</p><p>对于单精度浮点数，$e=8,f=23$<br>对于双精度浮点数，$e=11,f=52$</p><p>一个浮点数，其值可以表示如下：</p><p>$\text{Value}=\text{sign} \times \text{exponent} \times \text{fraction}$</p><p>$\text{sign}$: 符号位<br>$\text{exponent}$: 指数偏移值，又称阶码<br>$\text{fraction}$: 分数值，</p><h4 id="符号位"><a href="#符号位" class="headerlink" title="符号位"></a>符号位</h4><p>符号位即内存中最高位<br>$0$表示正，$\text{sign}=+1$<br>$1$表示负，$\text{sign}=-1$</p><h4 id="指数偏移值"><a href="#指数偏移值" class="headerlink" title="指数偏移值"></a>指数偏移值</h4><p>第2至9位(第二块)，指数偏移值<br>等于指数的实际值加上一个固定的值<br>这个值应当能够使其能够表示的最小的数表示为所有位全为$0$的数，能表示的最大的数表示为所有位全为$1$的数<br>IEEE 754 规定该值为$2^{e-1}-1$<br>对于单精度浮点数，该值为$2^7-1=127$</p><p>但是，对于单精度浮点数，这个数的实际取值范围是$[-126,127]$，$-127,128$被当作特殊值处理</p><p>如，若指数实际为$-7$，会被编码为$(-7)+127=120=01111000_2$<br>若某浮点数指数部分编码为$120$，那么其指数实际应为$120-127=-7$</p><p>若内存中的编码为$\text{exp}$， 那么<br>$\displaystyle \text{exponent}=2^{\text{exp}-(2^{e-1}-1)}$</p><h4 id="分数值"><a href="#分数值" class="headerlink" title="分数值"></a>分数值</h4><p>分数值比指数偏移值好理解的多</p><p>回想二进制整数，可以写成如下形式：<br>$10101=1\times2^4+1\times2^2+1\times2^0$</p><p>分数值和这个有些类似<br>只不过是把指数换成了负的<br>但是顺序换成了从右到左</p><p>$\displaystyle .11001=1\times {1 \over 2^1}+1\times {1 \over 2^2} + 1 \times {1 \over 2^5 }$</p><p><strong>但是</strong>，虽然$f=23$，但实际有效数位是$24$位<br>因为还有一位$1$是一定存在的<br>所以结果加上1</p><p>即</p><p>设按照上面的规则处理出来的数为 $\text{frac}$<br>那么<br>$\text{fraction}=1+\text{frac}$</p><h4 id="规约形式"><a href="#规约形式" class="headerlink" title="规约形式"></a>规约形式</h4><p>若一个浮点数的指数部分满足$0 \lt \text{exponent} \leq 2^e-2$，且这个浮点数的分数$\text{fraction}$部分最高有效位为1<br>那么这个浮点数称为规约形式的浮点数，规约意为可以用唯一确定的浮点形式表示一个值</p><p>例如，单精度规约形式浮点数该部分的值域为 $00000001_2$到$11111110_2$，分数部分值域为$000\dots000$(23 bit)到$111\dots111$</p><h4 id="非规约形式"><a href="#非规约形式" class="headerlink" title="非规约形式"></a>非规约形式</h4><p>如果一个浮点数指数部分编码为$0$，且分数部分非0，那么这个浮点数被称为非规约形式的浮点数，一般在某个数相当接近0时才会使用该种形式</p><p>IEEE 754标准规定：非规约形式的浮点数的指数偏移值比规约形式的浮点数的指数偏移值小1</p><h4 id="特殊值"><a href="#特殊值" class="headerlink" title="特殊值"></a>特殊值</h4><p>如果指数为$0$且小数部分为$0$，那么这个数为$\pm0$(具体取决于符号位)<br>如果指数为$2^e-1$且小数部分为$0$，那么这个数为$\pm \infty$(具体取决于符号位)<br>如果指数为$2^e-1$且小数部分非$0$，那么这个数为$\pm \text{NaN}$</p><h4 id="例"><a href="#例" class="headerlink" title="例"></a>例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sign exponent           fraction</span><br><span class="line"> ↓  ┌───┴──┐  ┌───────────┴───────────┐</span><br><span class="line">[0][01111100][0100000 00000000 00000000]</span><br><span class="line"> ↑         ↑                          ↑</span><br><span class="line">e+f        f                          0</span><br></pre></td></tr></table></figure><p>$\text{sign}=+1$<br>$\text{exponent}=124-127=-3$<br>$\displaystyle \text{fraction}=1+{1 \over 2^2}=1.25$<br>$\displaystyle \text{value} = (+1) \times 2^{-3} \times 1.25=0.15625$</p><h3 id="回到我们的问题"><a href="#回到我们的问题" class="headerlink" title="回到我们的问题"></a>回到我们的问题</h3><p>我们把$0.1$和$0.2$转成二进制发现这俩都是无限不循环小数，<br><code>double</code>并不能存<br>所以只能根据规则(舍入到最接近的值，一样接近则取其中的偶数(二进制中以0结尾的一个))找个近似值<br>然后就多出来那一个4</p><p>$0.1_{10}=0\ 01111111011\ 1001100110011001100110011001100110011001100110011010_2$</p><p>$0.2_{10}=0\ 01111111100\ 1001100110011001100110011001100110011001100110011010_2$</p><p>加起来就得到了$0.30000000000000004$</p><h2 id="0"><a href="#0" class="headerlink" title="-0"></a>-0</h2><p>像我们之前所说的，如果一个浮点数除符号位以外全是0，那么这个浮点数就是$-0$<br>所以，将一个全$0$的浮点数的最高位设为$1$，即可得到$-0$<br>在运算中，$-0=0$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> f = <span class="number">0</span>;</span><br><span class="line">*(<span class="keyword">long</span> <span class="keyword">long</span>*)&amp;f |= ((<span class="keyword">long</span> <span class="keyword">long</span>)<span class="number">1</span> &lt;&lt; <span class="number">63</span>);</span><br></pre></td></tr></table></figure><h2 id="NaN"><a href="#NaN" class="headerlink" title="NaN"></a>NaN</h2><p>Not a Number<br>玄学至极的东西</p><p>前面我们讲了，$\pm \text{NaN}$是一个满足以下条件的浮点数:</p><ul><li>指数部分为$2^e-1$</li><li>小数部分非$0$</li></ul><p>那么二进制下，这几个数都是<code>-NaN</code>:<br>$1\ 11111111111\ 0000000000000000000000000000000000000000000000000001$<br>$1\ 11111111111\ 0000000000000000000000000000000000000000000000000011$<br>$1\ 11111111111\ 0000000000000000000000000000000001111111110011111111$</p><h3 id="获取NaN"><a href="#获取NaN" class="headerlink" title="获取NaN"></a>获取NaN</h3><p>想要获取<code>NaN</code>，请使用指针或共用体(共同占用同一块内存的几个变量)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">getNaN</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">double</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> *p = (<span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span>*)&amp;ans;</span><br><span class="line">*p |= ((<span class="keyword">long</span> <span class="keyword">long</span>) <span class="number">0x7ff</span> &lt;&lt; <span class="number">52</span>);</span><br><span class="line">*p |= <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">getNaNWithUnion</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">union</span> &#123; <span class="keyword">double</span> f; <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> i; &#125; u;</span><br><span class="line">u.i |= ((<span class="keyword">long</span> <span class="keyword">long</span>) <span class="number">0x7ff</span> &lt;&lt; <span class="number">52</span>);</span><br><span class="line">u.i |= <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> u.f;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>欲获取<code>-NaN</code>，请使用<code>-getNaN()</code></p><h3 id="毒瘤性质"><a href="#毒瘤性质" class="headerlink" title="毒瘤性质"></a>毒瘤性质</h3><p>$\text{NaN} \not = \text{NaN}$<br>$-\text{NaN} \not = 0 - \text{NaN}$($-0$同样)<br>所有数字加上$\text{NaN}$都是$\text{NaN}$<br>但是不等于$\text{NaN}$</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[cling]$ getNaN() != getNaN()</span><br><span class="line">(bool) <span class="literal">true</span></span><br><span class="line">[cling]$ -getNaN()</span><br><span class="line">(double) -nan</span><br><span class="line">[cling]$ 0 - getNaN()</span><br><span class="line">(double) nan</span><br></pre></td></tr></table></figure><h2 id="∞"><a href="#∞" class="headerlink" title="∞"></a>∞</h2><p>和$\text{NaN}$类似</p><h3 id="获取∞"><a href="#获取∞" class="headerlink" title="获取∞"></a>获取∞</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">getInf</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">double</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> *p = (<span class="keyword">long</span> <span class="keyword">long</span>*)&amp;ans;</span><br><span class="line">*p |= ((<span class="keyword">long</span> <span class="keyword">long</span>) <span class="number">0x7ff</span> &lt;&lt; <span class="number">52</span>);</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>欲获取$-\infty$，请使用<code>-getInf()</code></p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://zh.wikipedia.org/wiki/IEEE_754" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/IEEE_754</a><br><a href="https://zh.wikipedia.org/wiki/%E5%96%AE%E7%B2%BE%E5%BA%A6%E6%B5%AE%E9%BB%9E%E6%95%B8" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/%E5%96%AE%E7%B2%BE%E5%BA%A6%E6%B5%AE%E9%BB%9E%E6%95%B8</a><br><a href="https://zh.wikipedia.org/wiki/%E7%A7%BB%E7%A0%81" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/%E7%A7%BB%E7%A0%81</a></p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CF784G 「BF Calculator」 题解</title>
      <link href="posts/29332c4b70e33d51/"/>
      <url>posts/29332c4b70e33d51/</url>
      
        <content type="html"><![CDATA[<p>MoveToEx蒟蒻也开始写题解了QAQ</p><a id="more"></a><p><a href="https://www.luogu.org/problemnew/show/CF784G" target="_blank" rel="noopener">Luogu - CF784G</a><br><a href="https://codeforces.com/contest/784/problem/G" target="_blank" rel="noopener">CodeForces - 784G</a></p><p>愚人节比赛G题</p><h1 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>Translated by <a href="https://www.luogu.org/space/show?uid=60864" target="_blank" rel="noopener">tiger2005@Luogu</a></p><p>在这个问题中，你要写一个可以生成Brainfuck语言的代码以算出数学表达式值的生成器。</p><p>给你一个算术表达式，其中包括数字0~255以及加减号，你需要生成一个可以算出并输出算术表达式结果的Brainfuck代码</p><p>我们将用一个绝对标准的Brainfuck编译器来判断你的Brainfuck代码的正误。</p><p>有30000个位置供你使用。</p><p>一个位置用无字符8比特的位置储存0~255的整数。</p><p>不支持输入（即不能出现’,’请求输入），在本题中也并不需要。</p><h2 id="输入输出"><a href="#输入输出" class="headerlink" title="输入输出"></a>输入输出</h2><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>输入仅有一行，包括一个算术表达式，内含2~10次运算对象，数字用 + 和/或 - 分离。每个运算对象将是一个在0和255间的整数。保证输出为0与225间的整数（在计算过程中可能会超出储存范围）。</p><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>输出一个Brainfuck程序，以计算表达式的值，这个表达式不得多过5000000个字符，在50000000次操作内就要结束。</p><h2 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h2><h3 id="Input-1"><a href="#Input-1" class="headerlink" title="Input #1"></a>Input #1</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2+3</span><br></pre></td></tr></table></figure><h3 id="Output-1"><a href="#Output-1" class="headerlink" title="Output #1"></a>Output #1</h3><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">++&gt;<span class="comment">;</span></span><br><span class="line"><span class="comment"></span>++<span class="literal">+</span>&gt;<span class="comment">;</span></span><br><span class="line"><span class="comment"></span>&lt;<span class="comment">;</span><span class="title">[</span>&lt;<span class="comment">;</span><span class="literal">+</span>&gt;<span class="comment">;</span><span class="literal">-</span><span class="title">]</span>&lt;<span class="comment">;</span></span><br><span class="line"><span class="comment"></span>++<span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="string">.</span></span><br></pre></td></tr></table></figure><p><del>MoveToEx: 哦豁NexT代码高亮竟然支持BF</del></p><h3 id="Input-2"><a href="#Input-2" class="headerlink" title="Input #2"></a>Input #2</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">9-7</span><br></pre></td></tr></table></figure><h3 id="Output-2"><a href="#Output-2" class="headerlink" title="Output #2"></a>Output #2</h3><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">++<span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span>&gt;<span class="comment">;</span></span><br><span class="line"><span class="comment"></span>++<span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span>&gt;<span class="comment">;</span></span><br><span class="line"><span class="comment"></span>&lt;<span class="comment">;</span><span class="title">[</span>&lt;<span class="comment">;</span><span class="literal">-</span>&gt;<span class="comment">;</span><span class="literal">-</span><span class="title">]</span>&lt;<span class="comment">;</span></span><br><span class="line"><span class="comment"></span>++<span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="string">.</span></span><br></pre></td></tr></table></figure><h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>BF可以在<a href="http://fatiherikli.github.io/brainfuck-visualizer" target="_blank" rel="noopener">BF Visualizer</a>运行。</p><p>CF使用一种SPJ的东西，把我们的程序放到BF编译器里运行一遍，在根据BF程序的输出判断评测结果。</p><p>其实如果要输出计算的结果的话<br>我们计算出来直接输出不就好了吗</p><p>拿Input1来说，显然，$2+3=5$，所以我们写一个只输出5的程序即可。</p><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">++<span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="string">.</span></span><br></pre></td></tr></table></figure><p>主要是这道题有几个坑…<br>BF只能输出字符，而这道题有的数据结果是大于9的<br>表达式会有多个运算对象，即使样例没有给出<br><strong>答案为0时手动转字符串的可能会卡掉</strong></p><p>关键是怎么计算<br>那些Python的做法就不说了吧<br>主要看C++</p><p>由于某些毒瘤的原因，我使用了C++11。</p><p>首先，把数字和运算符从字符串当中提取出来。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">extract</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; num, <span class="built_in">vector</span>&lt;function&lt;<span class="keyword">int</span>(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt; &gt;&amp; ope)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; str;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); ++i) &#123;      <span class="comment">// 提取字符串形式的数字</span></span><br><span class="line">        <span class="keyword">int</span> tmp = i;</span><br><span class="line">        <span class="keyword">while</span>(s[i] != <span class="string">'+'</span> &amp;&amp; s[i] != <span class="string">'-'</span>) &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (tmp != i) str.push_back(s.substr(tmp, i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); ++i) &#123;      <span class="comment">// 处理运算符</span></span><br><span class="line">        <span class="keyword">if</span> (s[i] == <span class="string">'+'</span>) &#123;</span><br><span class="line">            ope.push_back([](<span class="keyword">int</span> a, <span class="keyword">int</span> b) -&gt; <span class="keyword">int</span> &#123; <span class="keyword">return</span> a + b; &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">'-'</span>) &#123;</span><br><span class="line">            ope.push_back([](<span class="keyword">int</span> a, <span class="keyword">int</span> b) -&gt; <span class="keyword">int</span> &#123; <span class="keyword">return</span> a - b; &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;::iterator it = str.begin(); it != str.end(); ++it) &#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = <span class="number">0</span>;                    <span class="comment">// 转至整数</span></span><br><span class="line">        <span class="built_in">sscanf</span>(it-&gt;c_str(), <span class="string">"%d"</span>, &amp;tmp);</span><br><span class="line">        num.push_back(tmp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，把结果计算出来。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">calc</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; num;</span><br><span class="line">    <span class="built_in">vector</span>&lt;function&lt;<span class="keyword">int</span>(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt; &gt; ope;</span><br><span class="line">    extract(s, num, ope);</span><br><span class="line">    ans = num[<span class="number">0</span>];</span><br><span class="line">    num.erase(num.begin());</span><br><span class="line">    <span class="keyword">while</span>(!num.empty()) &#123;</span><br><span class="line">        ans = ope[<span class="number">0</span>](ans, num[<span class="number">0</span>]);</span><br><span class="line">        ope.erase(ope.begin());</span><br><span class="line">        num.erase(num.begin());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，输出。<br>请注意，BF的输出不是输出数字而是以字符形式输出，所以我们需要对结果进行一些处理。<br>把答案转成字符串，输出即可。<br>格式大概是对于结果的每位数$a_i$，输出$a_i+48$个<code>+</code>和<code>.&gt;</code>即可。<br>当然如果有人想尝试一些骚操作的话我也不反对，毕竟CF那边用的是SPJ。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">string</span> s;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;   <span class="comment">// 被卡警告</span></span><br><span class="line">        s = <span class="string">"0"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(n) &#123;</span><br><span class="line">        s += (n % <span class="number">10</span> + <span class="string">'0'</span>);</span><br><span class="line">        n /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    reverse(s.begin(), s.end());</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; s[i]; ++j) &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">'+'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">".&gt;"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>[完]</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p>请勿抄袭<br>抄的话会有惊喜</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">extract</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; num, <span class="built_in">vector</span>&lt;function&lt;<span class="keyword">int</span>(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt; &gt;&amp; ope)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; str;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = i;</span><br><span class="line">        <span class="keyword">while</span>(s[i] != <span class="string">'+'</span> &amp;&amp; s[i] != <span class="string">'-'</span>) &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (tmp != i) str.push_back(s.substr(tmp, i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i] == <span class="string">'+'</span>) &#123;</span><br><span class="line">            ope.push_back([](<span class="keyword">int</span> a, <span class="keyword">int</span> b) -&gt; <span class="keyword">int</span> &#123; <span class="keyword">return</span> a + b; &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">'-'</span>) &#123;</span><br><span class="line">            ope.push_back([](<span class="keyword">int</span> a, <span class="keyword">int</span> b) -&gt; <span class="keyword">int</span> &#123; <span class="keyword">return</span> a - b; &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;::iterator it = str.begin(); it != str.end(); ++it) &#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">sscanf</span>(it-&gt;c_str(), <span class="string">"%d"</span>, &amp;tmp);</span><br><span class="line">        num.push_back(tmp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">calc</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; num;</span><br><span class="line">    <span class="built_in">vector</span>&lt;function&lt;<span class="keyword">int</span>(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt; &gt; ope;</span><br><span class="line">    extract(s, num, ope);</span><br><span class="line">    ans = num[<span class="number">0</span>];</span><br><span class="line">    num.erase(num.begin());</span><br><span class="line">    <span class="keyword">while</span>(!num.empty()) &#123;</span><br><span class="line">        ans = ope[<span class="number">0</span>](ans, num[<span class="number">0</span>]);</span><br><span class="line">        ope.erase(ope.begin());</span><br><span class="line">        num.erase(num.begin());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">string</span> s;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">        s = <span class="string">"0"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(n) &#123;</span><br><span class="line">        s += (n % <span class="number">10</span> + <span class="string">'0'</span>);</span><br><span class="line">        n /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    reverse(s.begin(), s.end());</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; s[i]; ++j) &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">'+'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">".&gt;"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">string</span> s;</span><br><span class="line">    output(calc(s));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
          <category> CodeForces </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题解 </tag>
            
            <tag> 暴力 </tag>
            
            <tag> 模拟 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「长期更新」 如何优雅地机惨别人 for Win</title>
      <link href="posts/b871c09cf73bca69/"/>
      <url>posts/b871c09cf73bca69/</url>
      
        <content type="html"><![CDATA[<p>当你身边的人出去时没有锁电脑……</p><a id="more"></a><p>[2019/08/03] Upd: 做了一些补充，顺便加上liuzhe被机惨的几次（大雾<br>[2019/08/13] Upd: 增加关于PE头的内容，并将本文列为LTS。<br>[2020/04/24] Upd: 增加关于BIOS的内容</p><div class="note warning">声明：本页所有操作引发的后果(包括但不限于被核平、自己被机惨、电脑硬件损坏等)，与本人无关。</div><br>本页所有方法均在Windows平台上测试通过 <del>（在平时的机惨中</del><br><br># 「毒瘤I级」<br><br>## 关机<br><br>当他在写一些毒瘤的东西但是<strong>没有保存</strong>的话，这个方法会很有用。<br><br><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shutdown -f -p</span><br></pre></td></tr></table></figure><br><br>随手<kbd>Ctrl</kbd>+<kbd>S</kbd>以预防。<br><br>顺便说一下这个对VSC及Notepad++之类的没用<br><br>## 杀explorer<br><br>终止资源管理器，配合<kbd><i class="fa fa-windows"></i></kbd>+<kbd>D</kbd>使用更佳。<br><br><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">taskkill</span> /im explorer.exe /f</span><br></pre></td></tr></table></figure><br><br>可通过<kbd><i class="fa fa-windows"></i></kbd>+<kbd>R</kbd> <code>explorer.exe</code>解决。<br><br>## 账号<br><br>最常见的机惨手段<br>不说了吧<br><br>用他的账号比如洛咕或者QQ啥的做一些奇奇怪怪的事情……比如<code>I AK IOI</code>啥的<br><br>一般 <del>经常机惨别人或经常被机惨</del> 的OIer都会对此种机惨方式有所防范。<br><br>&gt; 我最强了<br>&gt;<br>&gt;<p style="text-align:right">–被机惨的Herself32</p><br><br>&gt; 我tql<br>&gt;<br>&gt;<p style="text-align:right">–被机惨的Payphone-X</p><br><br>&gt; wtxdy<br>&gt;<br>&gt;<p style="text-align:right">–被机惨的MoveToEx菜鸡</p><br><br>&gt; iakioi<br>&gt; I AK IOI!<br>&gt; IAKIOI<br>&gt; wtxdy<br>&gt;<br>&gt;<p style="text-align:right">–被机惨的liuhe</p><br><br>&gt; I AK IOI!<br>&gt;<br>&gt;<p style="text-align:right">–被机惨的机房某同学</p><br><br><br>各位离开电脑的时候一定要锁电脑（<br>一般一个OIer发送<code>wtxdy</code>或<code>I AK IOI</code>所用时间不超过5s<br><br>没啥好办法预防<br>注意锁电脑和账户<br><br># 「毒瘤II级」<br><br>## 魔改编译器<br><br>### Dev-C++<br><br>点开 工具-&gt;编译选项 ，勾选”在编译时加入以下命令”，然后……<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--help</span><br></pre></td></tr></table></figure><br><br>如果你比较毒瘤……<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-Dmain&#x3D;mian</span><br><span class="line">-Dwmain&#x3D;wmian</span><br><span class="line">-DWinMain&#x3D;WinMian</span><br><span class="line">-DwWinMain&#x3D;wWinMian</span><br><span class="line">-DONLINE_JUDGE</span><br></pre></td></tr></table></figure><br><br>比较不容易被发现<br>但会暴露在下方输出框的编译命令里<br><br>### VSCode<br><br>各扩展提供的编译方式不同，请自行更改，在此以AIO Compiler 2.0.0为例<br><br>文件:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%USERPROFILE%\\.vscode\\extensions\\aztechcorps.aio-compiler-2.0.0\\extension.js</span><br></pre></td></tr></table></figure><br><br>第 24~28 行:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"compile"</span>: &#123;</span><br><span class="line">    <span class="string">"c"</span>: <span class="string">`gcc -o .output<span class="subst">$&#123;pathDelimiter&#125;</span>main -lm `</span>,</span><br><span class="line">    <span class="string">"cpp"</span>: <span class="string">`g++ -o .output<span class="subst">$&#123;pathDelimiter&#125;</span>main `</span>,</span><br><span class="line">    <span class="string">"java"</span>: <span class="string">"javac -d \".output\" "</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><br><br>可能稍有不同<br>这是编译的命令<br>自己魔改吧<br><br>VS的话就算了<br>MSBuild不是一般OIer会改的<br>我更不会（<br><br>## 魔改头文件<br><br>按住Ctrl，点击他包括的最后一个头文件，在末尾加入本站<a href="/duliu/Programs/JC-Header.html">毒瘤/机惨标头</a>中的代码。<br>对于万能头(<code>&lt;bits/stdc++.h&gt;</code>)尤其好用<br><br>对VS和VSC及<strong>比较现代</strong>的编辑器不适用，因为这些编辑器都能够分析代码并给出提示<br>只要把光标放在宏的位置……<br><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(<span class="string">"MoveToEx is juruo!"</span>);</span><br><span class="line">              ┌────────────────────────┐</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; le│ <span class="meta">#<span class="meta-keyword">define</span> strlen(x) -1   │</span></span><br><span class="line">              ├────────────────────────┤</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; │ Expands to:            │</span><br><span class="line">&#125;             │ <span class="number">-1</span>                     │</span><br><span class="line">              └────────────────────────┘</span><br></pre></td></tr></table></figure><br><br><br>可通过换用VSC或VS解决（大雾<br><br>## 魔改其他文件<br><br>曾经Handwer太阳被机惨的时候用户密码被删了，博客也被改了<br><br>&gt; 折腾了一个中午才恢复过来<br>&gt;<br>&gt;<p style="text-align:right">–HandwerSTD</p><br><br>或者把他桌面的快捷方式改一下<br>改成指向<code>shutdown -p -f</code>，把图标改到原来的图标<br><br>但是不保证没人会像我一样毒瘤<br>我的桌面图标基本上是拿来看的<br>一般用Wox+开始+任务栏<br>（Wox大法好啊<br><br>同样，记得锁电脑<br><br># 「毒瘤III级」<br><br><div class="note warning">以下内容被WL带师认为是迫害，请自行把握尺度，避免被核平</div><p>如果关系没有好到一定程度的话<strong>请勿尝试</strong></p><h2 id="修改BIOS"><a href="#修改BIOS" class="headerlink" title="修改BIOS"></a>修改BIOS</h2><p>首先关机<br>如果没法关的话长按电源键</p><p>然后开机进入BIOS<br>如果不知道是哪个键的话就用手指在<kbd>F1</kbd>-<kbd>F12</kbd>滚几遍就好了<br>有的电脑可能需要按住<kbd>Fn</kbd></p><p>然后就作吧<br>BIOS可以禁用无线网络<br>可以设定硬盘密码<br>啥的</p><h2 id="魔改EXE"><a href="#魔改EXE" class="headerlink" title="魔改EXE"></a>魔改EXE</h2><p>emmmmmmm</p><p>Windows启动程序时，会从程序中读取一份关于程序从外部引入的标识符(可以是函数及变量名等)的列表(称为<code>PE头</code>)，按照这个列表加载DLL。由于EXE中保存的列表一般不变，这种方式也被称为静态加载</p><p>PE头保存在EXE文件中</p><p>有一种程序，能够读取程序的PE头，并有能力重建和编辑PE头</p><p>只要预先准备好对应的DLL，就能让程序从停止运行到关机再到砍<code>Program Files</code>……</p><p>改哪个程序不需要我说了吧 Dev 颓废工具啥的<br>当然如果被修改的程序要求管理员权限就更有意思了（（（</p><p>编辑PE头推荐<code>LordPE</code>。<br>编译DLL文件推荐<code>Visual Studio</code>系列。<br>(记得Dev好像能编译DLL来的)</p><p>相对隐秘，不易发现<br>但是相对麻烦的多，要求机惨者了解Windows相关技术<br>而且重装被修改的软件即可修复（</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Shlobj.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LIBAPI __declspec(dllexport)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> &#123;</span><br><span class="line">    <span class="function">LIBAPI <span class="keyword">void</span> <span class="title">crash</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> *p = &amp;a;</span><br><span class="line">        p += <span class="number">2333</span>;</span><br><span class="line">        (*p)++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">LIBAPI <span class="keyword">void</span> <span class="title">memory_limit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>) <span class="keyword">new</span> <span class="keyword">int</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">LIBAPI <span class="keyword">void</span> <span class="title">time_limit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">LIBAPI <span class="keyword">void</span> <span class="title">kill_explorer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">            system(<span class="string">"taskkill /im explorer.exe /f"</span>);</span><br><span class="line">            Sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">LIBAPI <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        system(<span class="string">"shutdown -p"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">LIBAPI <span class="keyword">void</span> <span class="title">delete_program_files</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!IsUserAnAdmin()) &#123;</span><br><span class="line">            crash();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        system(<span class="string">"del /q \"C:\\Program Files\""</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="魔改注册表"><a href="#魔改注册表" class="headerlink" title="魔改注册表"></a>魔改注册表</h2><p>注册表是个好东西<br>不仅键值目录复杂的让人头疼<br>键值的意义也难以弄清<br>所以注册表可以拿来机惨用，不仅难以确定问题所在，还难以恢复</p><p>比如<br>Windows注册表有一个位置<br>它的值列出了一些DLL文件<br><code>User32.dll</code>会在每一个加载<code>User32.dll</code>的程序运行时加载这些DLL文件并调用<code>DllMain</code>，<code>fdwReason</code>传入<code>DLL_PROCESS_ATTACH</code><br>(该特性在最新版本的Windows不确定是否被保留，Win7实测可行)<br>然后……</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL WINAPI <span class="title">DllMain</span><span class="params">(HINSTANCE hInstDll, DWORD fdwReason, PVOID fImpLoad)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span>(fdwReason) &#123;</span><br><span class="line">        <span class="keyword">case</span> DLL_PROCESS_ATTACH: &#123;</span><br><span class="line">            MessageBox(<span class="literal">NULL</span>, TEXT(<span class="string">"This program ran into an error."</span>), TEXT(<span class="string">"Error"</span>), MB_ICONERROR);</span><br><span class="line">            ExitProcess(<span class="number">0</span>);     <span class="comment">// 退出进程</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">default</span>: &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>嚄嚄嚄嚄</p><p>这个位置：<br><code>HKEY_LOCAL_MACHINE\Software\Microsoft\Windows NT\CurrentVersion\Windows</code></p><p>[2019/08/03] Upd: 当时手残，<code>HKEY</code>打成<code>HEKY</code>，已修复</p><p>这个位置下的<code>LoadAppInit_DLLs</code>键的值为<code>1</code>的时候，<code>AppInit_DLLs</code>才会生效。<br>这个位置下的<code>AppInit_DLLs</code>键的值指定一个或一组DLL的文件名，用<code>&#39; &#39;</code>或<code>&#39;,&#39;</code>分隔。</p><p>在VM试了一遍，确实能用，不过需要编译时指定运行方的Windows平台，否则会提示找不到<code>vcruntime140.dll</code>啥的……<br>然后就是<code>control</code>，<code>cmd</code>，甚至<code>taskkill</code>一类的东西开启的时候都会加载那个链接库<br>啊当然也包括你自己写的</p><p>倒也有解决方法<br>就是在U盘或者什么地方保存一份注册表的备份，并经常更新（</p><p>[2019/08/03] Upd: 请注意：</p><blockquote><p>This feature may not be available in future versions of the Windows operating system.<br>(该特性在未来的Windows系统版本中可能不可用(指<code>AppInit_DLLs</code>))</p><p style="text-align:right">–<a href="https://support.microsoft.com/en-us/help/197571/working-with-the-appinit-dlls-registry-value" target="_blank" rel="noopener">Microsoft</a></p></blockquote><h2 id="格式化"><a href="#格式化" class="headerlink" title="格式化"></a>格式化</h2><p>emmmmmmm<br>如果不想被核平解决掉的话请不要尝试</p><p>请在具有管理员权限的Powershell窗口中运行</p><figure class="highlight ps"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">format D: /u /s</span><br><span class="line">format E: /u /s</span><br><span class="line">format F: /u /s</span><br></pre></td></tr></table></figure><p>能通过恢复工具找回不少<br>但是如果他毒瘤的要死帮你用弄个37次随机覆写啥的……<br>弄死他</p><h2 id="删除分区"><a href="#删除分区" class="headerlink" title="删除分区"></a>删除分区</h2><p>emmmmmmm*2</p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">diskpart</span><br><span class="line">list disk</span><br><span class="line">select disk <span class="number">0</span></span><br><span class="line">list partition</span><br></pre></td></tr></table></figure><p>然后随机挑选一个幸运分区进行delete。</p><p>基本无解</p><p>[2019/08/01] Upd<br>有解<br>可以用DiskGenius恢复绝大部分<br>但是文件路径不保证全部正确</p><p>别问我为啥知道（QAQ</p><h2 id="删除引导"><a href="#删除引导" class="headerlink" title="删除引导"></a>删除引导</h2><p>不说了<br>不会的就算了<br>别去祸害社会<br>至于那些会的我劝你善良</p><p>可通过重装系统解决</p>]]></content>
      
      
      <categories>
          
          <category> 灌水区 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 极致毒瘤 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「长期更新」 安利</title>
      <link href="posts/c6fa5907e5d1119c/"/>
      <url>posts/c6fa5907e5d1119c/</url>
      
        <content type="html"><![CDATA[<p>闲着没事安利一发自己用的顺手的东西</p><a id="more"></a><style>.list-item{display:inline-block;width:233px}.list-item>a{cursor:default;width:100%}.card{text-align:center;overflow:hidden;border-radius:4px;height:74px;width:223px;transition:all .3s}.card:hover{box-shadow:3px 3px 3px rgba(0,0,0,.3);background-color:#ddd;transition:all .3s}.title{height:20px;margin:0;margin-top:14px}.descr{text-align:center;font-size:10px;color:#222}.angle{color:#fff;transition:all .3s}.card:hover>.titles>.title>.angle{color:#00f;transition:all .3s}</style><p>[2020/4/9] Upd: 换个布局，原来的又难看又繁琐<br>然后成功给我写炸了 /kk</p><h1 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h1><div class="_container" data="Windows"><ul class="list"></ul></div><p>PanDownload 的事相信大家都知道，就不废话了<br>感谢作者让我们白嫖了某度网盘这么长时间</p><h1 id="Android"><a href="#Android" class="headerlink" title="Android"></a>Android</h1><div class="note warning">请从 Google Play 获取</div><div class="_container" data="Android"><ul class="list"></ul></div><h1 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h1><div class="_container" data="Font"><ul class="list"></ul></div><script>var v={Windows:[{link:"https://www.bandisoft.com/bandizip/",name:"Bandizip",descr:"压缩工具"},{link:"http://www.ccleaner.com/ccleaner",name:"CCleaner",descr:"清理垃圾"},{link:"https://cmder.net/",name:"Cmder",descr:"命令行工具"},{link:"https://github.com/0xd4d/dnSpy/releases",name:"dnSpy",descr:".NET & C# 反编译"},{link:"https://macpaw.com/encrypto",name:"Encrypto",descr:"文件加密"},{link:"https://www.voidtools.com/",name:"Everything",descr:"文件搜索"},{link:"https://www.geogebra.org/",name:"Geogebra",descr:"数学绘图"},{link:"https://www.pandownload.com",name:'<i class="fa fa-info-circle"></i>PanDownload',descr:"百度网盘下载工具"},{link:"https://potplayer.daum.net/",name:"PotPlayer",descr:"视频播放"},{link:"https://github.com/microsoft/PowerToys",name:"Power Toys",descr:"一些有用的小工具"},{link:"https://docs.microsoft.com/en-us/sysinternals/downloads/process-explorer",name:"Process Explorer",descr:"进程管理"},{link:"https://www.qbittorrent.org/",name:"qBitTorrent",descr:"torrent下载"},{link:"https://www.sandboxie.com/",name:"Sandboxie",descr:"沙盒环境"},{link:"https://www.screentogif.com/",name:"Screen to GIF",descr:"动图录制"},{link:"https://www.snipaste.com/",name:"Snipaste",descr:"屏幕截图"},{link:"http://www.uderzo.it/main_products/space_sniffer/download.html",name:"Space Sniffer",descr:"空间占用可视化"},{link:"https://typora.io/",name:"Typora",descr:"M↓编辑器"},{link:"https://www.veracrypt.fr/en/Home.html",name:"VeraCrypt",descr:"驱动器加密"},{link:"https://code.visualstudio.com/",name:"Visual Studio Code",descr:"代码编辑器"},{link:"https://github.com/Microsoft/Terminal",name:"Windows Terminal",descr:"终端工具"},{link:"http://www.wox.one/",name:"Wox",descr:"快速启动工具"}],Android:[{link:"https://play.google.com/store/apps/details?id=ru.iiec.cxxdroid&hl=en_US",name:"CxxDroid",descr:"C++编辑 & 编译"},{link:"https://play.google.com/store/apps/details?id=com.fastaccess.github",name:"FastHub",descr:"Github第三方客户端"},{link:"https://play.google.com/store/apps/details?id=com.termux",name:"Termux",descr:"终端模拟器"}],Font:[{link:"https://github.com/adobe-fonts/source-code-pro",name:'<span style="font-family: SourceCodePro">Source Code Pro</span>',descr:"Adobe出品，为代码而生"},{link:"https://github.com/tonsky/FiraCode",name:'<span style="font-family: FiraCode">Fira Code</span>',descr:'<span style="font-family: FiraCode">支持连字，代码专用>=_<= </span>'}]},ctnr=document.querySelector("._container");for(var i in v)for(var item in ctnr=document.querySelector(`._container[data=${i}]`),v[i])ctnr.innerHTML+=`\n        <li class="list-item">\n            <a href="${v[i][item].link}" target="_blank">\n                <div class="card">\n                    <div class="titles">\n                        <p class="title"><i class="fa fa-angle-right angle"></i> ${v[i][item].name}</p>\n                        <p class="descr">${v[i][item].descr}</p>\n                    </div>\n                </div>\n            </a>\n        </li>`</script>]]></content>
      
      
      <categories>
          
          <category> 灌水区 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> N/A </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Lambda表达式</title>
      <link href="posts/79e68f4965059f8c/"/>
      <url>posts/79e68f4965059f8c/</url>
      
        <content type="html"><![CDATA[<p>和JS有点像<br>不过多了个作用域的限制<br><a id="more"></a></p><h1 id="Lambda简介"><a href="#Lambda简介" class="headerlink" title="Lambda简介"></a>Lambda简介</h1><p>（Lambda表达式被Wiki重定向至匿名函数）</p><blockquote><p>在计算机编程中，匿名函数（英语：anonymous function）是指一类无需定义标识符（函数名）的函数或子程序，普遍存在于多种编程语言中。<br>1958年LISP首先采用匿名函数，自此之后，越来越多编程语言陆续采用，主流的编程语言如PHP和C++也在不久前采用。</p><p style="text-align:right">–<a href="https://zh.wikipedia.org/wiki/%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0" target="_blank" rel="noopener">匿名函数-维基百科</a></p></blockquote><p>Lambda表达式就是这种东西:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> f = [](<span class="keyword">int</span> a) -&gt; <span class="keyword">int</span> &#123;</span><br><span class="line"><span class="keyword">return</span> a * a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>emmmmmm<br>看起来很像JS啊</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> f = <span class="function">(<span class="params">a</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">return</span> a * a;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>但是为啥他们都要用箭头啊</p><p>话说最近C++添加的和别的语言相似的东西越来越多了，比如<code>std::for_each</code>啥的</p><p>CR对这个的介绍是这样的：</p><blockquote><p>构造闭包：能够捕获作用域中变量的无名函数对象。</p><p style="text-align:right">–<a href="https://zh.cppreference.com/w/cpp/language/lambda" target="_blank" rel="noopener">cppreference.com</a></p></blockquote><p>emmmm</p><p>不知道怎么描述的更加通俗易懂……</p><h1 id="基本形式"><a href="#基本形式" class="headerlink" title="基本形式"></a>基本形式</h1><p>lambda函数大多是这样的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[capture] (parameters) -&gt; <span class="keyword">mutable</span> return_type &#123; body &#125;</span><br></pre></td></tr></table></figure><ul><li>Capture: 用于捕获Lambda表达式外的变量，如下：<ul><li><code>[]</code>: 不指定任何变量，使用表达式外的变量将导致CE，但是不加<code>[]</code>也会CE。</li><li><code>[x]</code>: <code>x</code>按值传递。</li><li><code>[&amp;x]</code>: <code>x</code>按引用传递。</li><li><code>[=]</code>: 任何<strong>被使用到</strong>的外部变量按值传递。</li><li><code>[&amp;]</code>: 任何<strong>被使用到</strong>的外部变量按引用传递。</li><li><code>[&amp;, x]</code>: <code>x</code>按值传递，其他用到的变量按引用传递，可以改变变量的个数，不可互换位置。</li><li><code>[=, &amp;x]</code>: <code>x</code>按引用传递，其他按值传递，可以改变变量的个数，不可互换位置。</li><li>特别的，类或结构体中的Lambda表达式需要显式捕捉<code>this</code>指针从而使用当前对象中的成员。</li><li>函数可以访问的变量有：<ul><li>参数</li><li>函数内声明的变量</li><li>对象成员</li><li>全局变量</li><li>被捕获的变量</li></ul></li></ul></li><li>Parameters: 函数的参数，定义方法和C++中一般函数相同。注意，Lambda表达式与一般函数有下列不同：<ul><li>不能有缺省值 (如<code>int fun(int a = 10)</code>)</li><li>不能有可变参数 (如<code>int fun(int cnt, ...)</code>)</li><li>不能有无名参数 (如<code>int fun(int, int) {}</code>)</li></ul></li><li><code>mutable</code>: 如果出现<code>mutable</code>， 在Capture中指定<strong>按值传入的</strong>外部变量可以被更改，否则默认其为只读变量。</li><li>Return_type: 函数的返回值类型。对于<code>void</code>函数，该项和前面的<code>-&gt;</code>可省略，但不可只出现一个。</li><li>Body: 函数体。</li></ul><p>Lambda表达式需要用<code>std::function&lt;&gt;</code>(定义于<code>&lt;functional&gt;</code>)或<code>auto</code>类型的变量存储，<code>function</code>的模板中填入形如<code>int(int,int)</code>的函数类型和参数。如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::function&lt;<span class="keyword">int</span>(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt; add = [](<span class="keyword">int</span> a, <span class="keyword">int</span> b) -&gt; <span class="keyword">int</span> &#123; <span class="keyword">return</span> a + b; &#125;;</span><br><span class="line"><span class="keyword">auto</span> sub = [](<span class="keyword">int</span> a, <span class="keyword">int</span> b) -&gt; <span class="keyword">int</span> &#123; <span class="keyword">return</span> a - b; &#125;</span><br></pre></td></tr></table></figure><h1 id="调用"><a href="#调用" class="headerlink" title="调用"></a>调用</h1><p>以<code>变量名(参数列表)</code>形式调用即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">auto</span> println = [](<span class="keyword">int</span> i) &#123; <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>; &#125;;</span><br><span class="line">println(<span class="number">1</span>);</span><br><span class="line">println(<span class="number">2</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><h2 id="P1001-A-B"><a href="#P1001-A-B" class="headerlink" title="P1001 A + B"></a>P1001 A + B</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> a, b;</span><br><span class="line">function&lt;<span class="keyword">int</span>(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt; add = [](<span class="keyword">int</span> a, <span class="keyword">int</span> b) -&gt; <span class="keyword">int</span> &#123; <span class="keyword">return</span> a + b; &#125;;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; add(a, b) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, a[<span class="number">1001</span>];</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">    sort(a, a + n, [](<span class="keyword">int</span> a, <span class="keyword">int</span> b) -&gt; <span class="keyword">bool</span> &#123; <span class="keyword">return</span> a &lt; b; &#125;);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) <span class="built_in">cout</span> &lt;&lt; a[i];</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    sort(a, a + n, [](<span class="keyword">int</span> a, <span class="keyword">int</span> b) -&gt; <span class="keyword">bool</span> &#123; <span class="keyword">return</span> a &gt; b; &#125;);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) <span class="built_in">cout</span> &lt;&lt; a[i];</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> C++11 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 新语法&amp;新特性 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Trie</title>
      <link href="posts/ee5ec8ffcb4b8966/"/>
      <url>posts/ee5ec8ffcb4b8966/</url>
      
        <content type="html"><![CDATA[<p><del>最近码风越来越毒瘤了</del></p><p>Trie，又称字典树、前缀树，是一种用于存储字符串的数据结构。<br><del>这种东西在一个我之前用过的OJ上是入门级别的</del><br><del>可怕</del></p><a id="more"></a><p>在洛咕跳题玩的时候跳到了<a href="https://www.luogu.org/problemnew/show/P2580" target="_blank" rel="noopener">P2580</a>，众所周知，这是一个map水题，但是题目的标签既然有<code>Trie</code>……<br>那我们就用Trie做就是了……</p><p><del>毕竟是全谷Trie最水的题了</del></p><h1 id="什么是Trie"><a href="#什么是Trie" class="headerlink" title="什么是Trie"></a>什么是Trie</h1><p>Trie,其作者Edward Fredkin将其读作/ˈtriː/(“tree”)，但是，更多的人比较倾向于使用/ˈtraɪ/(“try”)。</p><p>Trie，是一种树形结构，有插入和查找两种操作，以字符串为键，鬼畜的一批，因为这种树的键不会保存在节点中，而是由节点在树中的位置决定，Trie树的任意节点的子节点都有相同前缀。</p><p>大概长这样：</p><p><img src="/post_images/Trie.png" alt="Trie"></p><p>（在这里，节点所显示的字符串为方便理解所加，并不实际储存在节点中）</p><h1 id="Trie的基本思路"><a href="#Trie的基本思路" class="headerlink" title="Trie的基本思路"></a>Trie的基本思路</h1><h2 id="根节点"><a href="#根节点" class="headerlink" title="根节点"></a>根节点</h2><p>作为一棵树，需要一个根节点，而Trie的根节点不存储任何东西，所以可以直接用一个数字或者指针，如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">char</span> Start, <span class="keyword">size_t</span> MaxSize&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Trie</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 1:</span></span><br><span class="line">Node* head;</span><br><span class="line"><span class="comment">// 2:</span></span><br><span class="line"><span class="keyword">int</span> head = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至于这里的<code>Start</code>和<code>MaxSize</code>……<br>Trie树中的每个节点的子节点数目如果弄成<code>MAX_CHAR</code>是很致命的，会有一大堆空间（如果使用指针，还有时间）浪费，所以只能设置一个起始点，一个最大大小，这样找子节点时用<code>s[i] - Start</code>就可以了。</p><h2 id="节点"><a href="#节点" class="headerlink" title="节点"></a>节点</h2><p>Trie树的节点不需要储存字符，只需要储存当前节点的子节点，因为Trie树中键不需要被显式保存。<br>所以它的节点大概长这样：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">Node* child[...];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>当然，有很多时候我们需要自行魔改，这只是个基本的节点。<br>至于为啥用指针写……<br>Trie这种空间换时间的东西占空间太大，在我的WSL上节点数组开到1e6就……炸了<br>我也不知道是不是WSL的问题<br></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">movetoex@MoveToEx-PC:~$ sed -n <span class="string">'10,14p'</span> Trie_Array.cpp</span><br><span class="line">  typedef struct tagNode &#123;</span><br><span class="line">      bool IsStr;</span><br><span class="line">      int child[27];</span><br><span class="line">    &#125; Node;</span><br><span class="line">  Node nodes[100001];</span><br><span class="line">movetoex@MoveToEx-PC:~$ ./Array</span><br><span class="line">段错误 (核心已转储)</span><br></pre></td></tr></table></figure><p></p><p>然后开到1e5，弄1k个字符串，每个30字符的数据测的时候……</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">movetoex@MoveToEx-PC:~$ ./Array &lt; ./Input</span><br><span class="line">段错误 (核心已转储)</span><br></pre></td></tr></table></figure><p>卒<br>再来看指针……</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">movetoex@MoveToEx-PC:~$ ./Ptr &lt; ./Input</span><br><span class="line">1</span><br></pre></td></tr></table></figure><p>所以我选择动态内存……</p><p>（但是在洛咕上面数组和指针都能用，我也不知道是什么鬼畜操作）</p><p>或者，加一个判断当前节点是否为完整字符串的布尔变量：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line"><span class="keyword">bool</span> bIsStr;</span><br><span class="line">Node* child[...];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2><p>循环$|s|$次，每次查找当前节点的第$s_i$个子节点，如果为<code>0</code>或<code>NULL</code>，插入新节点，否则使当前节点指针指向子节点（至于数组怎么说……自行理解吧）</p><p>时间复杂度大概$\mathcal O(|s|)$</p><p>直接上代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(<span class="keyword">char</span>* szString, <span class="keyword">size_t</span> iLen)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> tmp = <span class="number">0</span>;</span><br><span class="line">Trie::Node *p = <span class="keyword">this</span>-&gt;head;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; iLen; ++i) &#123;</span><br><span class="line">tmp = szString[i] - Start;</span><br><span class="line"><span class="keyword">if</span> (p-&gt;child[tmp] == <span class="literal">NULL</span>) &#123;</span><br><span class="line">p-&gt;child[tmp] = <span class="keyword">this</span>-&gt;_alloc();</span><br><span class="line">&#125;</span><br><span class="line">p = p-&gt;child[tmp];</span><br><span class="line">&#125;</span><br><span class="line">p-&gt;IsStr = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><p>循环$|s|$次，每次查找当前节点的第$s_i$个子节点，如果为<code>0</code>或<code>NULL</code>返回<code>false</code>，否则使当前节点指针指向子节点。最后，返回当前节点是否为一个完整字符串。</p><p>时间复杂度大概$\mathcal O(|s|)$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Trie::Find</span><span class="params">(<span class="keyword">char</span>* szString, <span class="keyword">size_t</span> iLen)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> tmp = <span class="number">0</span>;</span><br><span class="line">Node* p = <span class="keyword">this</span>-&gt;head;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; iLen; ++i) &#123;</span><br><span class="line">tmp = szString[i] - Start;</span><br><span class="line"><span class="keyword">if</span> (p-&gt;child[tmp] == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">p = p-&gt;child[tmp];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> p-&gt;IsStr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Trie代码"><a href="#Trie代码" class="headerlink" title="Trie代码"></a>Trie代码</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">char</span> Start, <span class="keyword">size_t</span> MaxSize&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Trie</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tagNode</span> &#123;</span></span><br><span class="line"><span class="keyword">bool</span> IsStr;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tagNode</span> *<span class="title">child</span>[<span class="title">MaxSize</span> + 1];</span></span><br><span class="line">&#125; Node;</span><br><span class="line">Node* head;</span><br><span class="line"><span class="keyword">inline</span> Trie::Node* _alloc() &#123;</span><br><span class="line">Trie::Node* p = <span class="keyword">new</span> Trie::Node;</span><br><span class="line"><span class="built_in">memset</span>(p, <span class="number">0</span>, <span class="keyword">sizeof</span>(Trie::Node));</span><br><span class="line"><span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> _free(Trie::Node** p) &#123;</span><br><span class="line"><span class="keyword">if</span> (*p) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= MaxSize; ++i) &#123;</span><br><span class="line"><span class="keyword">if</span> ((*p)-&gt;child[i]) &#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;_free(&amp;(*p)-&gt;child[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">delete</span> *p;</span><br><span class="line">*p = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Trie() &#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;head = <span class="keyword">this</span>-&gt;_alloc();</span><br><span class="line">&#125;</span><br><span class="line">~Trie() &#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;_free(&amp;<span class="keyword">this</span>-&gt;head);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* szString, <span class="keyword">size_t</span> iLen)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> tmp = <span class="number">0</span>;</span><br><span class="line">Trie::Node *p = <span class="keyword">this</span>-&gt;head;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; iLen; ++i) &#123;</span><br><span class="line">tmp = szString[i] - Start;</span><br><span class="line"><span class="keyword">if</span> (p-&gt;child[tmp] == <span class="literal">NULL</span>) &#123;</span><br><span class="line">p-&gt;child[tmp] = <span class="keyword">this</span>-&gt;_alloc();</span><br><span class="line">p-&gt;child[tmp]-&gt;c = szString[i];</span><br><span class="line">&#125;</span><br><span class="line">p = p-&gt;child[tmp];</span><br><span class="line">&#125;</span><br><span class="line">p-&gt;IsStr = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Find</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* szString, <span class="keyword">size_t</span> iLen)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> tmp = <span class="number">0</span>;</span><br><span class="line">Node* p = <span class="keyword">this</span>-&gt;head;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; iLen; ++i) &#123;</span><br><span class="line">tmp = szString[i] - Start;</span><br><span class="line"><span class="keyword">if</span> (p-&gt;child[tmp] == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">p = p-&gt;child[tmp];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> p-&gt;IsStr;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
          <category> 数据结构 </category>
          
          <category> Trie </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OI </tag>
            
            <tag> Trie </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>那些毒瘤的排序算法</title>
      <link href="posts/933ca3151e976795/"/>
      <url>posts/933ca3151e976795/</url>
      
        <content type="html"><![CDATA[<p>排序的实现方式不少，很多，非常多……</p><a id="more"></a><p>本文部分算法参考维基。</p><p>[2019/03/10] Upd: 逛维基的时候发现一堆毒瘤排序，更新<br>[2019/03/26] Upd: 逛知乎发现竟然还有更沙雕的算法，更新<br>[2019/06/22] Upd: extmool设计了一个沙雕的算法，更新</p><h1 id="正常点的"><a href="#正常点的" class="headerlink" title="正常点的"></a>正常点的</h1><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><h3 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h3><p>懒得说了……</p><p>时间复杂度$\mathcal O(n)$ ~ $\mathcal O(n^2)$<br>平均时间复杂度$\mathcal O(n^2)$<br>空间复杂度$\mathcal O(1)$</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &lt;algorithm&gt; - swap</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BubbleSort</span><span class="params">(<span class="keyword">int</span>* pnArr, <span class="keyword">int</span> nLength)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nLength; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; nLength - i; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (pnArr[j] &gt; pnArr[j + <span class="number">1</span>])</span><br><span class="line"><span class="built_in">std</span>::swap(pnArr[j], pnArr[j + <span class="number">1</span>]);</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><h3 id="基本思想-1"><a href="#基本思想-1" class="headerlink" title="基本思想"></a>基本思想</h3><p>给定长度$n$的数组$a$，循环$n-1$次，每次找出一个数并在其后面找出一个最小的数，交换。</p><p>时间复杂度$\mathcal O(n^2)$<br>空间复杂度$\mathcal O(1)$</p><h3 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &lt;algorithm&gt; - swap()</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SelectionSort</span><span class="params">(<span class="keyword">int</span>* pnArr, <span class="keyword">int</span> nLength)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> nMin = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nLength - <span class="number">1</span>; i++) &#123;</span><br><span class="line">nMin = i;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; nLength; j++) &#123;</span><br><span class="line"><span class="keyword">if</span>(pnArr[nMin] &gt; pnArr[j]) &#123;</span><br><span class="line">nMin=j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(nMin != i) &#123;</span><br><span class="line"><span class="built_in">std</span>::swap(pnArr[nMin], pnArr[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><h3 id="基本思想-2"><a href="#基本思想-2" class="headerlink" title="基本思想"></a>基本思想</h3><blockquote><p>快速排序使用分治法（Divide and conquer）策略来把一个序列（list）分为两个子序列（sub-lists）。<br>步骤为：</p><ul><li>从数列中挑出一个元素，称为“基准”（pivot），</li><li>重新排序数列，所有比基准值小的元素摆放在基准前面，所有比基准值大的元素摆在基准后面（相同的数可以到任何一边）。在这个分割结束之后，该基准就处于数列的中间位置。这个称为 <strong>分割（partition）</strong> 操作。</li><li>递归地（recursively）把小于基准值元素的子数列和大于基准值元素的子数列排序。</li></ul><p>递归到最底部时，数列的大小是零或一，也就是已经排序好了。这个算法一定会结束，因为在每次的迭代（iteration）中，它至少会把一个元素摆到它最后的位置去。</p><p style="text-align:right">–<a href="https://zh.wikipedia.org/wiki/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F" target="_blank" rel="noopener">Wikipedia</a></p></blockquote><p>时间复杂度$\mathcal O(n \log_2 n)$ ~ $\mathcal O(n^2)$<br>空间复杂度$\mathcal O(\log n)$ ~ $\mathcal O(n)$</p><h3 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &lt;algorithm&gt; - swap()</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QuickSort</span><span class="params">(<span class="keyword">int</span>* pnArr, <span class="keyword">int</span> nLeft,<span class="keyword">int</span> nRight)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> i = nLeft, j = nRight;</span><br><span class="line"><span class="keyword">int</span> k = pnArr[nLeft];</span><br><span class="line"><span class="keyword">if</span>(i &gt;= j)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line"><span class="keyword">while</span>((i &lt; j) &amp;&amp; pnArr[j] &gt;= k)</span><br><span class="line">j--;</span><br><span class="line"><span class="built_in">std</span>::swap(pnArr[i], pnArr[j]);</span><br><span class="line"><span class="keyword">while</span>((i &lt; j) &amp;&amp; (pnArr[i] &lt; k))</span><br><span class="line">i++;</span><br><span class="line"><span class="built_in">std</span>::swap(pnArr[i], pnArr[j]);</span><br><span class="line">&#125;</span><br><span class="line">QuickSort(pnArr, nLeft, i - <span class="number">1</span>);</span><br><span class="line">QuickSort(pnArr, i + <span class="number">1</span>, nRight);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h2><h3 id="基本思想-3"><a href="#基本思想-3" class="headerlink" title="基本思想"></a>基本思想</h3><p>对于每个数组元素$a_i$，使$tmp_{a_i}$++，按照$tmp$数组输出即可。<br>时间复杂度$\mathcal O(n)$<br>空间复杂度$\mathcal O(n + m)$<br>$m$为桶的数量。</p><h3 id="实现-3"><a href="#实现-3" class="headerlink" title="实现"></a>实现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_BUCKET 100000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// &lt;algorithm&gt; - swap()</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BucketSort</span><span class="params">(<span class="keyword">int</span>* pnArr, <span class="keyword">int</span> nLength)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> *pnBucket = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">int</span> iMax = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// Protection</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nLength; i++) &#123;</span><br><span class="line"><span class="keyword">if</span>(pnArr[i] &gt; MAX_BUCKET || pnArr[i] &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">pnBucket = <span class="keyword">new</span> <span class="keyword">int</span>[MAX_BUCKET + <span class="number">1</span>];</span><br><span class="line"><span class="built_in">memset</span>(pnBucket, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">int</span>) * (MAX_BUCKET + <span class="number">1</span>));</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nLength; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (iMax &lt; pnArr[i]) &#123;</span><br><span class="line">iMax = pnArr[i];</span><br><span class="line">&#125;</span><br><span class="line">pnBucket[pnArr[i]]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= iMax; i++) &#123;</span><br><span class="line"><span class="keyword">while</span>(pnBucket[i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">pnBucket[i]--;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">delete</span> pnBucket;</span><br><span class="line">pnBucket = <span class="literal">NULL</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>emmmm这个实现增加了很多避免RE的保护措施……<br>但是由于某种神奇的原因并没有用……起码在我的电脑上是这样的……</p><h1 id="毒瘤I级"><a href="#毒瘤I级" class="headerlink" title="毒瘤I级"></a>毒瘤I级</h1><h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><h3 id="基本思想-4"><a href="#基本思想-4" class="headerlink" title="基本思想"></a>基本思想</h3><blockquote><p>原始的算法实现在最坏的情况下需要进行$\mathcal O(n^2)$的比较和交换。V. Pratt的书[1]对算法进行了少量修改，可以使得性能提升至$\mathcal O(n \log_2 n)$。这比最好的比较算法的$\mathcal O(n \log n)$要差一些。<br>希尔排序通过将比较的全部元素分为几个区域来提升插入排序的性能。这样可以让一个元素可以一次性地朝最终位置前进一大步。然后算法再取越来越小的步长进行排序，算法的最后一步就是普通的插入排序，但是到了这步，需排序的数据几乎是已排好的了（此时插入排序较快）。<br>假设有一个很小的数据在一个已按升序排好序的数组的末端。如果用复杂度为O(n2)的排序（冒泡排序或插入排序），可能会进行n次的比较和交换才能将该数据移至正确位置。而希尔排序会用较大的步长移动数据，所以小数据只需进行少数比较和交换即可到正确位置。<br>一个更好理解的希尔排序实现：将数组列在一个表中并对列排序（用插入排序）。重复这过程，不过每次用更长的列来进行。最后整个表就只有一列了。将数组转换至表是为了更好地理解这算法，算法本身仅仅对原数组进行排序（通过增加索引的步长，例如是用<code>i += step_size</code>而不是<code>i++</code>）。</p><p style="text-align:right">–<a href="https://zh.wikipedia.org/wiki/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F" target="_blank" rel="noopener">Wikipedia</a></p></blockquote><p>这是啥!!!<br>时间复杂度$\mathcal O(n^{1.3})$ ~ $\mathcal O(n^2)$<br>平均时间复杂度$\mathcal O(n \log_2 n)$<br>空间复杂度$\mathcal O(1)$</p><h3 id="实现-4"><a href="#实现-4" class="headerlink" title="实现"></a>实现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &lt;algorithm&gt; - swap()</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShellSort</span><span class="params">(<span class="keyword">int</span>* pnArr, <span class="keyword">int</span> nLength)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> div = nLength / <span class="number">2</span>; div &gt;= <span class="number">1</span>; div = div / <span class="number">2</span>) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; div; ++i) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt; nLength - div; j += div) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k = j; k &lt; nLength; k += div) &#123;</span><br><span class="line"><span class="keyword">if</span>(pnArr[j] &gt; pnArr[k]) &#123;</span><br><span class="line">      <span class="built_in">std</span>::swap(pnArr[j], pnArr[k]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><h3 id="基本思想-5"><a href="#基本思想-5" class="headerlink" title="基本思想"></a>基本思想</h3><p>将数组塞到堆里，让堆进行排序。</p><p>时间复杂度$\mathcal O(n \log_2 n)$<br>空间复杂度$\mathcal O(2n)$</p><h3 id="实现-5"><a href="#实现-5" class="headerlink" title="实现"></a>实现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &lt;algorithm&gt; - swap()</span></span><br><span class="line"><span class="comment">// &lt;cstring&gt;/&lt;memory.h&gt; - memset()</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">size_t</span> MaxSize&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Heap</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  T pHeap[MaxSize];</span><br><span class="line">  <span class="keyword">int</span> nSize;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Heap()&#123;</span><br><span class="line"><span class="built_in">memset</span>(<span class="keyword">this</span>-&gt;pHeap, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">this</span>-&gt;pHeap));</span><br><span class="line"><span class="keyword">this</span>-&gt;nSize = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">~Heap()&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Push</span><span class="params">(T x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;pHeap[++<span class="keyword">this</span>-&gt;nSize] = x;</span><br><span class="line"><span class="keyword">int</span> i = <span class="keyword">this</span>-&gt;nSize, j = i &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">this</span>-&gt;pHeap[j] &gt; <span class="keyword">this</span>-&gt;pHeap[i] &amp;&amp; i) &#123;</span><br><span class="line"><span class="built_in">std</span>::swap(<span class="keyword">this</span>-&gt;pHeap[i], <span class="keyword">this</span>-&gt;pHeap[j]);</span><br><span class="line">i = j, j = i &gt;&gt; <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;pHeap[<span class="number">1</span>] = <span class="keyword">this</span>-&gt;pHeap[<span class="keyword">this</span>-&gt;nSize--];</span><br><span class="line"><span class="keyword">int</span> n = <span class="number">1</span>, nL = <span class="number">2</span>, nR = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">while</span> ((<span class="keyword">this</span>-&gt;pHeap[n] &gt; <span class="keyword">this</span>-&gt;pHeap[nL] || <span class="keyword">this</span>-&gt;pHeap[n] &gt; <span class="keyword">this</span>-&gt;pHeap[nR]) &amp;&amp; nL &lt;= <span class="keyword">this</span>-&gt;nSize) &#123;</span><br><span class="line"><span class="keyword">int</span> tmp = ((<span class="keyword">this</span>-&gt;pHeap[nL] &gt; <span class="keyword">this</span>-&gt;pHeap[nR]) ? nR : nL);</span><br><span class="line"><span class="built_in">std</span>::swap(<span class="keyword">this</span>-&gt;pHeap[tmp], <span class="keyword">this</span>-&gt;pHeap[n]);</span><br><span class="line">n = tmp, nL = n &lt;&lt; <span class="number">1</span>, nR = nL + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">T <span class="title">Top</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>-&gt;pHeap[<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> !<span class="keyword">this</span>-&gt;nSize;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="毒瘤II级"><a href="#毒瘤II级" class="headerlink" title="毒瘤II级"></a>毒瘤II级</h1><h2 id="猴子排序"><a href="#猴子排序" class="headerlink" title="猴子排序"></a>猴子排序</h2><h3 id="基本思想-6"><a href="#基本思想-6" class="headerlink" title="基本思想"></a>基本思想</h3><p>检查数组是否有序，如果是，结束。如果不是，随机打乱，再检查一遍。</p><p>时间复杂度:<br>运气好 + 数据良心，$\mathcal O(n)$<br>运气不好 + 数据毒瘤，$\mathcal O( \infty)$<br>平均时间复杂度$\mathcal O(n \times n!)$<br>空间复杂度$\mathcal O(1)$</p><p>那些编译不了的换C++11</p><h3 id="实现-6"><a href="#实现-6" class="headerlink" title="实现"></a>实现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &lt;algorithm&gt; - is_sorted() &amp; random_shuffle()</span></span><br><span class="line"><span class="comment">// &lt;ctime&gt; - time()</span></span><br><span class="line"><span class="comment">// &lt;cstdlib&gt; - srand()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Note: is_sorted() is not supported before C++11.</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BogoSort</span><span class="params">(<span class="keyword">int</span>* pnArr, <span class="keyword">int</span> nLength)</span> </span>&#123;</span><br><span class="line">srand((<span class="keyword">unsigned</span>)time(<span class="literal">NULL</span>));</span><br><span class="line"><span class="keyword">while</span>(!is_sorted(pnArr, pnArr + nLength)) &#123;</span><br><span class="line">random_shuffle(pnArr, pnArr + nLength);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="臭皮匠排序"><a href="#臭皮匠排序" class="headerlink" title="臭皮匠排序"></a>臭皮匠排序</h2><p>妈耶这个沙雕的名字……</p><blockquote><p>该算法得名于三个臭皮匠，每个臭皮匠都打其他两个</p><p style="text-align:right">–<a href="https://zh.wikipedia.org/wiki/%E8%87%AD%E7%9A%AE%E5%8C%A0%E6%8E%92%E5%BA%8F" target="_blank" rel="noopener">Wikipedia</a></p></blockquote><h3 id="基本思想-7"><a href="#基本思想-7" class="headerlink" title="基本思想"></a>基本思想</h3><blockquote><p>如果最后一个值小于第一个值，则交换这两个数<br>如果当前集合元素数量大于等于3：</p><ul><li>使用臭皮匠排序前2/3的元素</li><li>使用臭皮匠排序后2/3的元素</li><li>再次使用臭皮匠排序前2/3的元素</li></ul><p style="text-align:right">–<a href="https://zh.wikipedia.org/wiki/%E8%87%AD%E7%9A%AE%E5%8C%A0%E6%8E%92%E5%BA%8F" target="_blank" rel="noopener">Wikipedia</a></p></blockquote><p>时间复杂度$\mathcal O(n^{\log(3) \over \log(1.5)})$ ~ $\mathcal O(n^{2.7})$<br>空间复杂度$\mathcal O(1)$</p><h3 id="实现-7"><a href="#实现-7" class="headerlink" title="实现"></a>实现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">StoogeSort</span><span class="params">(<span class="keyword">int</span>* pnArr, <span class="keyword">int</span> iL, <span class="keyword">int</span> iR)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (pnArr[iR] &lt; pnArr[iL]) &#123;</span><br><span class="line"><span class="built_in">std</span>::swap(pnArr[iL], pnArr[iR]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (iR - iL + <span class="number">1</span> &gt;= <span class="number">3</span>) &#123;</span><br><span class="line"><span class="keyword">int</span> t = (iR - iL + <span class="number">1</span>) / <span class="number">3</span>;</span><br><span class="line">StoogeSort(pnArr, iL, iR - t);</span><br><span class="line">StoogeSort(pnArr, iL + t, iR);</span><br><span class="line">StoogeSort(pnArr, iL, iR - t);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="鸡尾酒排序"><a href="#鸡尾酒排序" class="headerlink" title="鸡尾酒排序"></a>鸡尾酒排序</h2><h3 id="基本思想-8"><a href="#基本思想-8" class="headerlink" title="基本思想"></a>基本思想</h3><blockquote><p>鸡尾酒排序等于是冒泡排序的轻微变形。不同的地方在于从低到高然后从高到低，而冒泡排序则仅从低到高去比较序列里的每个元素。他可以得到比冒泡排序稍微好一点的性能，原因是冒泡排序只从一个方向进行比对（由低到高），每次循环只移动一个项目。</p><p style="text-align:right">–<a href="https://zh.wikipedia.org/wiki/%E9%B8%A1%E5%B0%BE%E9%85%92%E6%8E%92%E5%BA%8F" target="_blank" rel="noopener">Wikipedia</a></p></blockquote><h3 id="实现-8"><a href="#实现-8" class="headerlink" title="实现"></a>实现</h3><p>代码魔改于<a href="https://zh.wikipedia.org/wiki/%E9%B8%A1%E5%B0%BE%E9%85%92%E6%8E%92%E5%BA%8F" target="_blank" rel="noopener">Wikipedia-鸡尾酒排序</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CocktailSort</span><span class="params">(<span class="keyword">int</span>* pnArr, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> j, left = <span class="number">0</span>, right = len - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line"><span class="keyword">for</span> (j = left; j &lt; right; j++)</span><br><span class="line"><span class="keyword">if</span> (pnArr[j] &gt; pnArr[j + <span class="number">1</span>])</span><br><span class="line">swap(pnArr[j], pnArr[j + <span class="number">1</span>]);</span><br><span class="line">right--;</span><br><span class="line"><span class="keyword">for</span> (j = right; j &gt; left; j--)</span><br><span class="line"><span class="keyword">if</span> (pnArr[j - <span class="number">1</span>] &gt; pnArr[j])</span><br><span class="line">swap(pnArr[j - <span class="number">1</span>], pnArr[j]);</span><br><span class="line">left++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="毒瘤III级"><a href="#毒瘤III级" class="headerlink" title="毒瘤III级"></a>毒瘤III级</h1><div class="note danger">前方高能！</div><h2 id="睡眠排序"><a href="#睡眠排序" class="headerlink" title="睡眠排序"></a>睡眠排序</h2><h3 id="基本思想-9"><a href="#基本思想-9" class="headerlink" title="基本思想"></a>基本思想</h3><p>给定长度$n$的数组$a$，创建$n$个线程，分别睡眠$a_i ms$，被唤醒时将$a_i$输出即可，主线程等待各线程结束。<br>为了让结果精准，创建线程时即挂起，统一恢复。</p><p>从知乎上看到的……而且这个算法在知乎上广为流传……</p><p>毒瘤啊！！！</p><p>很明显，不允许存在负数。<br>很明显，数据越大，排序越精准。<br>在无法接收线程返回值时，只能输出有序数列，不能对数组排序。</p><p>时间复杂度未知<br>空间复杂度未知</p><p>在增量较小时输出可能出现错序，如:</p><p>Input<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">10</span><br><span class="line">3 2 6 5 1 4 7 8 9 10</span><br></pre></td></tr></table></figure><p></p><p>Output<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 2 3 4 5 6 7 8 9 10</span><br></pre></td></tr></table></figure><p></p><p>可能的输出：<br>#1<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 2 3 4 5 6 7 89  10</span><br></pre></td></tr></table></figure><br>#2<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2 1 3 4 5 6 7 8 9 10</span><br></pre></td></tr></table></figure><p></p><h3 id="实现-9"><a href="#实现-9" class="headerlink" title="实现"></a>实现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &lt;Windows.h&gt; - Sleep() &amp; *Thread() &amp; WaitForMultipleObjects() &amp; CloseHandle()</span></span><br><span class="line"><span class="comment">// &lt;cstdio&gt; - putchar()</span></span><br><span class="line"><span class="function">DWORD CALLBACK <span class="title">SleepThread</span><span class="params">(LPVOID pvParam)</span> </span>&#123;</span><br><span class="line">Sleep((DWORD)pvParam);</span><br><span class="line">FastIO::Put((<span class="keyword">int</span>)pvParam);<span class="comment">// Or use cout or printf</span></span><br><span class="line"><span class="built_in">putchar</span>(<span class="string">' '</span>);</span><br><span class="line"><span class="keyword">return</span> (DWORD)pvParam;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SleepSort</span><span class="params">(<span class="keyword">int</span>* pnArr, <span class="keyword">int</span> nLength)</span> </span>&#123;</span><br><span class="line">DWORD dwThreadId[<span class="number">1001</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">HANDLE hThread[<span class="number">1001</span>] = &#123; <span class="literal">NULL</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nLength; i++) <span class="keyword">if</span> (pnArr[i] &lt; <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nLength; i++) <span class="comment">// Create suspended thread</span></span><br><span class="line">hThread[i] = CreateThread(<span class="literal">NULL</span>, <span class="number">0</span>, SleepThread, (LPVOID)pnArr[i],</span><br><span class="line">CREATE_SUSPENDED, &amp;dwThreadId[i]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nLength; i++) <span class="comment">// Resume suspended thread</span></span><br><span class="line">ResumeThread(hThread[i]);</span><br><span class="line"></span><br><span class="line">WaitForMultipleObjects(nLength, hThread, TRUE, INFINITE);</span><br><span class="line"><span class="comment">// Wait for thread to quit</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nLength; i++) &#123;</span><br><span class="line">CloseHandle(hThread[i]);</span><br><span class="line">hThread[i] = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="太阳能比特翻转排序"><a href="#太阳能比特翻转排序" class="headerlink" title="太阳能比特翻转排序"></a>太阳能比特翻转排序</h2><h3 id="基本思想-10"><a href="#基本思想-10" class="headerlink" title="基本思想"></a>基本思想</h3><p><del>HandwerSTD</del>太阳发出的$\alpha$粒子偶尔能够反转内存中的比特位……</p><ol><li>检查数组是否有序，如果是，退出。</li><li>等10秒并祈祷<del>HandwerSTD</del>太阳发出的辐射能使某一比特翻转，而且使得数组排好序，goto 1。</li></ol><p>时间复杂度接近$\mathcal O(\infty)$<br>空间复杂度$\mathcal O(1)$</p><p>终于找到比猴排还慢的排序了（雾</p><p>同样，<code>is_sorted</code>需要C++11。</p><p><del>靠近HandwerSTD以取得更加效果</del></p><h3 id="实现-10"><a href="#实现-10" class="headerlink" title="实现"></a>实现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &lt;algorithm&gt; - is_sorted()</span></span><br><span class="line"><span class="comment">// &lt;Windows.h&gt; - Sleep()</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SunSort</span><span class="params">(<span class="keyword">int</span>* pnArr, <span class="keyword">int</span> iLength)</span> </span>&#123;</span><br><span class="line"><span class="keyword">while</span>(!is_sorted(pnArr, pnArr + iLength))</span><br><span class="line">Sleep(<span class="number">10000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="extmool排序"><a href="#extmool排序" class="headerlink" title="extmool排序"></a>extmool排序</h2><h3 id="基本思想-11"><a href="#基本思想-11" class="headerlink" title="基本思想"></a>基本思想</h3><p>给定数组$a_i$，每次找出最大值，将其余的砍掉，最大值加入队列，将砍掉的继续上述操作，如此递归，直到$a.\text{size()} = 1$。</p><h3 id="实现-11"><a href="#实现-11" class="headerlink" title="实现"></a>实现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &lt;vector&gt; - vector&lt;&gt;</span></span><br><span class="line"><span class="comment">// &lt;queue&gt; - queue&lt;&gt;</span></span><br><span class="line"><span class="comment">// &lt;algorithm&gt; - max_element()</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">extmoolSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v, <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt;&amp; q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (v.size() == <span class="number">1</span>) &#123;</span><br><span class="line">        q.push(v[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator maxe = max_element(v.begin(), v.end());</span><br><span class="line">    q.push(*maxe);</span><br><span class="line">    v.erase(maxe);</span><br><span class="line">    extmoolSort(v, q);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="沙雕排序"><a href="#沙雕排序" class="headerlink" title="沙雕排序"></a>沙雕排序</h1><p>以下算法从网络中采集</p><p>无法用代码实现</p><p>简直沙雕的一批</p><h2 id="指鹿为马排序"><a href="#指鹿为马排序" class="headerlink" title="指鹿为马排序"></a>指鹿为马排序</h2><h3 id="基本思想-12"><a href="#基本思想-12" class="headerlink" title="基本思想"></a>基本思想</h3><p>聚集一帮人，向他们展示待排序数组，询问他们是否为排序好的，弄死其中认为没有排序好的，重复几次，直到所有人都认为是排序好的。</p><p>（PS：使用本算法所产生的后果，本人概不负责）</p><h2 id="互联网排序"><a href="#互联网排序" class="headerlink" title="互联网排序"></a>互联网排序</h2><h3 id="实现-12"><a href="#实现-12" class="headerlink" title="实现"></a>实现</h3><p>类似于冒泡，但每一次都依赖于互联网，如”1和2哪个大?”</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 极致毒瘤 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>va_list的使用</title>
      <link href="posts/4793824e43f0d087/"/>
      <url>posts/4793824e43f0d087/</url>
      
        <content type="html"><![CDATA[<p><code>va_list</code>用于接收函数的可变参数，<code>printf</code>之类的用于输入输出的函数经常使用可变参数列表。如<code>printf</code>的定义：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">_Check_return_opt_ </span><br><span class="line"><span class="function">_CRT_STDIO_INLINE <span class="keyword">int</span> __CRTDECL <span class="title">printf</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">_In_z_ _Printf_format_string_ <span class="keyword">char</span> <span class="keyword">const</span>* <span class="keyword">const</span> _Format,</span></span></span><br><span class="line"><span class="function"><span class="params">...)</span></span>;</span><br></pre></td></tr></table></figure><p>简化：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __cdecl <span class="title">printf</span><span class="params">(<span class="keyword">char</span> <span class="keyword">const</span>* _Format, ...)</span></span>;</span><br></pre></td></tr></table></figure><a id="more"></a><h1 id="va-list是什么"><a href="#va-list是什么" class="headerlink" title="va_list是什么"></a>va_list是什么</h1><p><code>va_list</code>是位于<code>&lt;stdarg.h&gt;</code>(<code>&lt;cstdarg&gt;</code> for C++)中的一个类型，通常情况下，它被定义为<code>char*</code>。如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span>* va_list;</span><br></pre></td></tr></table></figure><p>它可以指向一个地址，通过指针运算得到下一个参数的地址，然后将类型强制转换为参数的类型。</p><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p>首先，获取第一个可变参数的地址：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">va_list args;</span><br><span class="line">va_start(args,<span class="comment">/*可变参数前的最后一个参数*/</span>);</span><br></pre></td></tr></table></figure><p>然后，使用如下方式获取每一个参数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Type&gt; tmp = va_arg(args, &lt;Type&gt;);</span><br></pre></td></tr></table></figure><p>使用完后，使用下列代码将va_list置零：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">va_end(args);</span><br></pre></td></tr></table></figure><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdarg&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Sum</span><span class="params">(<span class="keyword">int</span> iCount, ...)</span> </span>&#123;</span><br><span class="line">va_list args;</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">va_start(args, iCount);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; iCount; i++) &#123;</span><br><span class="line">ans += va_arg(args, <span class="keyword">int</span>);</span><br><span class="line">&#125;</span><br><span class="line">va_end(args);</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="built_in">cout</span> &lt;&lt; Sum(<span class="number">10</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>在使用<code>va_list</code>的时候，一定要指定一个参数或者通过某些特殊途径获取可变参数的个数，像<code>printf</code>系列函数可以通过统计字符串中<code>&#39;%&#39;</code>的个数及后面的字符获取参数的个数及类型。否则程序就不知道应该获取多少个可变参数，RE当然也不是什么稀奇的事。</p><h1 id="将字符串中格式符替换为参数"><a href="#将字符串中格式符替换为参数" class="headerlink" title="将字符串中格式符替换为参数"></a>将字符串中格式符替换为参数</h1><p>实际上如果像<code>sprintf</code>那样只是将可变参数替换到带<code>%d</code>等格式符的字符串中，我们可以使用专用于将<code>va_list</code>中的可变参数列表替换到字符串中的函数。一般使用<code>_vstprintf(_s)</code>。<br><code>*_s</code>函数是安全字符串函数，可以避免因为某种特殊原因而导致内存泄露，比如在<code>strcpy</code>的<code>_Desc</code>(用于接收)内存空间不足以容纳<code>_Src</code>(源字符串)时。<br>如果用的好，我们甚至可以手写<code>printf</code>函数神马的……</p><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>MSDN:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">vsprintf</span><span class="params">(  </span></span></span><br><span class="line"><span class="function"><span class="params">   <span class="keyword">char</span> *buffer,  </span></span></span><br><span class="line"><span class="function"><span class="params">   <span class="keyword">const</span> <span class="keyword">char</span> *format,  </span></span></span><br><span class="line"><span class="function"><span class="params">   va_list argptr   </span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">vswprintf</span><span class="params">(  </span></span></span><br><span class="line"><span class="function"><span class="params">   <span class="keyword">wchar_t</span> *buffer,  </span></span></span><br><span class="line"><span class="function"><span class="params">   <span class="keyword">size_t</span> count,  </span></span></span><br><span class="line"><span class="function"><span class="params">   <span class="keyword">const</span> <span class="keyword">wchar_t</span> *format,  </span></span></span><br><span class="line"><span class="function"><span class="params">   va_list argptr   </span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">size_t</span> size&gt;  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">vsprintf_s</span><span class="params">(  </span></span></span><br><span class="line"><span class="function"><span class="params">   <span class="keyword">char</span> (&amp;buffer)[size],  </span></span></span><br><span class="line"><span class="function"><span class="params">   <span class="keyword">const</span> <span class="keyword">char</span> *format,  </span></span></span><br><span class="line"><span class="function"><span class="params">   va_list argptr   </span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">size_t</span> size&gt;  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">vswprintf_s</span><span class="params">(  </span></span></span><br><span class="line"><span class="function"><span class="params">   <span class="keyword">wchar_t</span> (&amp;buffer)[size],  </span></span></span><br><span class="line"><span class="function"><span class="params">   <span class="keyword">const</span> <span class="keyword">wchar_t</span> *format,  </span></span></span><br><span class="line"><span class="function"><span class="params">   va_list argptr   </span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure><p>注：在Unicode下<code>_vstprintf(_s)</code>为<code>vswprintf(_s)</code>，ANSI下<code>vsprintf(_s)</code>。<br><code>vs(w)printf(_s)</code>的<code>template</code>可以由编译器自动填充，无需特别指定。</p><p>Visual Studio 2017 - correct_wstdio.h:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">_Success_(<span class="keyword">return</span> &gt;= <span class="number">0</span>)</span><br><span class="line"><span class="function">_CRT_STDIO_INLINE <span class="keyword">int</span> __CRTDECL <span class="title">vswprintf_s</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">_Out_writes_(_BufferCount) _Always_(_Post_z_)<span class="keyword">wchar_t</span>*       <span class="keyword">const</span> _Buffer,</span></span></span><br><span class="line"><span class="function"><span class="params">_In_<span class="keyword">size_t</span>         <span class="keyword">const</span> _BufferCount,</span></span></span><br><span class="line"><span class="function"><span class="params">_In_z_ _Printf_format_string_<span class="keyword">wchar_t</span> <span class="keyword">const</span>* <span class="keyword">const</span> _Format,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                va_list              _ArgList</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C++"</span> _SWPRINTFS_DEPRECATED _CRT_INSECURE_DEPRECATE(vswprintf_s)</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> __CRTDECL <span class="title">vswprintf</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    _Pre_notnull_ _Post_z_<span class="keyword">wchar_t</span>*       <span class="keyword">const</span> _Buffer,</span></span></span><br><span class="line"><span class="function"><span class="params">    _In_z_ _Printf_format_string_<span class="keyword">wchar_t</span> <span class="keyword">const</span>* <span class="keyword">const</span> _Format,</span></span></span><br><span class="line"><span class="function"><span class="params">                                va_list              _ArgList</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br><span class="line">_Success_(<span class="keyword">return</span> &gt;= <span class="number">0</span>)</span><br><span class="line">_Check_return_opt_</span><br><span class="line"><span class="function">_CRT_STDIO_INLINE <span class="keyword">int</span> __CRTDECL <span class="title">vsprintf_s</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    _Out_writes_(_BufferCount) _Always_(_Post_z_)<span class="keyword">char</span>*       <span class="keyword">const</span> _Buffer,</span></span></span><br><span class="line"><span class="function"><span class="params">    _In_<span class="keyword">size_t</span>      <span class="keyword">const</span> _BufferCount,</span></span></span><br><span class="line"><span class="function"><span class="params">    _In_z_ _Printf_format_string_<span class="keyword">char</span> <span class="keyword">const</span>* <span class="keyword">const</span> _Format,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                va_list           _ArgList</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br><span class="line">_Success_(<span class="keyword">return</span> &gt;= <span class="number">0</span>)</span><br><span class="line">_Check_return_opt_ _CRT_INSECURE_DEPRECATE(vsprintf_s)</span><br><span class="line"><span class="function">_CRT_STDIO_INLINE <span class="keyword">int</span> __CRTDECL <span class="title">vsprintf</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    _Pre_notnull_ _Always_(_Post_z_)<span class="keyword">char</span>*       <span class="keyword">const</span> _Buffer,</span></span></span><br><span class="line"><span class="function"><span class="params">    _In_z_ _Printf_format_string_<span class="keyword">char</span> <span class="keyword">const</span>* <span class="keyword">const</span> _Format,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    va_list           _ArgList</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure><p>毒瘤依旧。<br>不过好像不是很全，这些东西好像有重载的来的……</p><h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><h3 id="out-buffer-or-Buffer"><a href="#out-buffer-or-Buffer" class="headerlink" title="[out]buffer or _Buffer"></a>[out]buffer <em>or</em> _Buffer</h3><p>指定用于接收的内存空间。</p><h3 id="in-count-or-BufferCount"><a href="#in-count-or-BufferCount" class="headerlink" title="[in]count or _BufferCount"></a>[in]count <em>or</em> _BufferCount</h3><p>指定<code>buffer</code> <em>or</em> <code>_Buffer</code>的最大写入大小，一般设为<code>_countof(buffer)</code>。</p><h3 id="in-format-or-Format"><a href="#in-format-or-Format" class="headerlink" title="[in]format or _Format"></a>[in]format <em>or</em> _Format</h3><p>含<code>%d</code>等标志的格式字符串。</p><h3 id="argptr-or-ArgList"><a href="#argptr-or-ArgList" class="headerlink" title="argptr or _ArgList"></a>argptr <em>or</em> _ArgList</h3><p>指定可变参数列表。</p><p>通常情况下，先声明一个<code>char</code>(<em>or</em> <code>wchar_t</code>)的数组，然后将这个数组、指定个数的数字、格式字符串以及<code>va_list</code>一起传入函数。</p><h2 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MessageBoxArgW</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    _In_opt_ HWND hWnd,</span></span></span><br><span class="line"><span class="function"><span class="params">    _In_ LPWSTR lpText,</span></span></span><br><span class="line"><span class="function"><span class="params">    _In_ LPWSTR lpCaption,</span></span></span><br><span class="line"><span class="function"><span class="params">    _In_ UINT uType,</span></span></span><br><span class="line"><span class="function"><span class="params">    ...</span></span></span><br><span class="line"><span class="function"><span class="params">)</span> </span>&#123;</span><br><span class="line">    va_list args;</span><br><span class="line">    va_start(args, uType);</span><br><span class="line">    <span class="keyword">int</span> iReturn = <span class="number">0</span>;</span><br><span class="line">    vswprintf(lpText, lpText, args);</span><br><span class="line">    iReturn = MessageBoxW(hWnd, lpText, lpCaption, uType);</span><br><span class="line">    va_end(args);</span><br><span class="line">    <span class="keyword">return</span> iReturn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在Windows编写多线程程序</title>
      <link href="posts/ca98c17def689642/"/>
      <url>posts/ca98c17def689642/</url>
      
        <content type="html"><![CDATA[<p>多线程，可以大幅度提高程序运行效率。</p><a id="more"></a><h1 id="何为线程"><a href="#何为线程" class="headerlink" title="何为线程"></a>何为线程</h1><p>线程，就是可以和你的程序同时运行的东西。Windows是一个抢占式操作系统，CPU会将CPU时间按照优先级依次分配给各个线程。</p><h1 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h1><p>创建线程一般使用<code>CreateThread</code>函数。</p><p>不过MS技术人员更加推荐<code>_beginthreadex()</code>，感兴趣的可以自己去翻官方文档。</p><h2 id="CreateThread"><a href="#CreateThread" class="headerlink" title="CreateThread"></a>CreateThread</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>MSDN:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HANDLE <span class="title">CreateThread</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  LPSECURITY_ATTRIBUTES   lpThreadAttributes,</span></span></span><br><span class="line"><span class="function"><span class="params">  SIZE_T                  dwStackSize,</span></span></span><br><span class="line"><span class="function"><span class="params">  LPTHREAD_START_ROUTINE  lpStartAddress,</span></span></span><br><span class="line"><span class="function"><span class="params">  __drv_aliasesMem LPVOID lpParameter,</span></span></span><br><span class="line"><span class="function"><span class="params">  DWORD                   dwCreationFlags,</span></span></span><br><span class="line"><span class="function"><span class="params">  LPDWORD                 lpThreadId</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure><p>Visual Studio 2017 - <i class="fa fa-file-code-o"></i> processthreadapi.h:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">WINBASEAPI _Ret_maybenull_ HANDLE WINAPI <span class="title">CreateThread</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    _In_opt_ LPSECURITY_ATTRIBUTES lpThreadAttributes,</span></span></span><br><span class="line"><span class="function"><span class="params">    _In_ SIZE_T dwStackSize,</span></span></span><br><span class="line"><span class="function"><span class="params">    _In_ LPTHREAD_START_ROUTINE lpStartAddress,</span></span></span><br><span class="line"><span class="function"><span class="params">    _In_opt_ __drv_aliasesMem LPVOID lpParameter,</span></span></span><br><span class="line"><span class="function"><span class="params">    _In_ DWORD dwCreationFlags,</span></span></span><br><span class="line"><span class="function"><span class="params">    _Out_opt_ LPDWORD lpThreadId</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure><p>毒瘤依旧</p><h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><h4 id="in-opt-lpThreadAttributes"><a href="#in-opt-lpThreadAttributes" class="headerlink" title="[in,opt]lpThreadAttributes"></a>[in,opt]lpThreadAttributes</h4><p>指向一个指示线程的安全描述符的指针，通常设为<code>NULL</code>以指示使用默认属性。</p><h4 id="in-dwStackSize"><a href="#in-dwStackSize" class="headerlink" title="[in]dwStackSize"></a>[in]dwStackSize</h4><p>一个指示线程的栈大小的双字，通常设为0以指示使用与主函数相同的栈大小。</p><h4 id="in-lpStartAddress"><a href="#in-lpStartAddress" class="headerlink" title="[in]lpStartAddress"></a>[in]lpStartAddress</h4><p>函数指针，指向线程运行的函数，通常像下面一样定义：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">DWORD CALLBACK <span class="title">ThreadFunc</span><span class="params">(LPVOID pvParam)</span> </span>&#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="in-opt-lpParameter"><a href="#in-opt-lpParameter" class="headerlink" title="[in,opt]lpParameter"></a>[in,opt]lpParameter</h4><p>传给线程函数的参数。</p><h4 id="in-dwCreationFlags"><a href="#in-dwCreationFlags" class="headerlink" title="[in]dwCreationFlags"></a>[in]dwCreationFlags</h4><p>常用值如下表：</p><table><thead><tr><th>值</th><th>含义</th></tr></thead><tbody><tr><td>0</td><td>线程创建后立即运行</td></tr><tr><td>CREATE_SUSPENDED</td><td>创建后挂起</td></tr></tbody></table><p>挂起的线程可用<code>ResumeThread</code>恢复。</p><h4 id="out-opt-lpThreadId"><a href="#out-opt-lpThreadId" class="headerlink" title="[out,opt]lpThreadId"></a>[out,opt]lpThreadId</h4><p>指向一个用于存放线程ID的双字，如果为<code>NULL</code>，则不为线程指定ID。</p><h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3><p>如果线程成功创建，返回线程的句柄。否则，返回<code>NULL</code>。</p><h1 id="让线程与主函数同步"><a href="#让线程与主函数同步" class="headerlink" title="让线程与主函数同步"></a>让线程与主函数同步</h1><p>在一些地方，线程需要和主程序的一些变量等东西同步，这种情况，一般会使用全局变量。如指示程序结束的变量：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BOOL g_bClosed = FALSE;</span><br></pre></td></tr></table></figure><p>线程函数：<br></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">DWORD CALLBACK <span class="title">ThreadFunc</span><span class="params">(LPVOID pvParam)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(!g_bClosed) &#123;</span><br><span class="line">    <span class="comment">// ... </span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h1 id="退出线程"><a href="#退出线程" class="headerlink" title="退出线程"></a>退出线程</h1><p>退出线程一般有4种方式：</p><ul><li>线程函数返回(最常用 最安全)</li><li>线程调用<code>ExitThread</code>进行“自杀”</li><li>其他线程调用<code>TerminateThread</code>强制终止当前线程</li><li>创建线程的进程退出</li></ul><h2 id="线程函数返回"><a href="#线程函数返回" class="headerlink" title="线程函数返回"></a>线程函数返回</h2><p>让线程执行的函数返回是最安全、最常用的方式。<br>当我们认为线程的任务完成了以后，就需要让线程执行的函数返回一个值，这个值通常为0。<br>让线程的函数返回可以让Windows正确的清理我们的线程运行使用的内存空间。</p><h2 id="ExitThread"><a href="#ExitThread" class="headerlink" title="ExitThread"></a>ExitThread</h2><p><code>ExitThread</code>是一个用于退出线程的函数。</p><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><p>MSDN:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">DECLSPEC_NORETURN VOID <span class="title">ExitThread</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  DWORD dwExitCode</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure><p>Visual Studio 2017 - processthreadapi.h:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">WINBASEAPI DECLSPEC_NORETURN VOID WINAPI <span class="title">ExitThread</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    _In_ DWORD dwExitCode</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="参数-1"><a href="#参数-1" class="headerlink" title="参数"></a>参数</h3><h4 id="in-dwExitCode"><a href="#in-dwExitCode" class="headerlink" title="[in]dwExitCode"></a>[in]dwExitCode</h4><p>线程的返回值，可用<code>GetExitCodeThread</code>获取。</p><h2 id="TerminateThread"><a href="#TerminateThread" class="headerlink" title="TerminateThread"></a>TerminateThread</h2><p><code>TerminateThread</code>是一个用于杀死其他进程的函数，MS官方极力反对这种方式。<code>TerminateThread</code>不会销毁线程占用的内存空间，因为其他线程可能还在使用这一段内存空间，如果Windows销毁的话……</p><p><img src="/images/RE.png" alt=""></p><p>在此不对<code>TerminateThread</code>做介绍。<s>省的读者拿去祸害人。</s></p><h1 id="关闭线程句柄"><a href="#关闭线程句柄" class="headerlink" title="关闭线程句柄"></a>关闭线程句柄</h1><p>线程运行完毕后，我们还需要将线程的句柄“归还”给Windows。否则就会有一大堆句柄占用空间却什么都不做。<br>关闭句柄使用<code>CloseHandle</code>函数。<br>要注意，关闭句柄并不代表线程停止运行，所以即使调用<code>CloseHandle</code>而不让线程退出，线程会一直运行下去。</p><h2 id="CloseHandle"><a href="#CloseHandle" class="headerlink" title="CloseHandle"></a>CloseHandle</h2><h3 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h3><p>MSDN:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL WINAPI <span class="title">CloseHandle</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_ HANDLE hObject</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure><p>Visual Studio 2017 - handleapi.h:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">WINBASEAPI BOOL WINAPI <span class="title">CloseHandle</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    _In_ _Post_ptr_invalid_ HANDLE hObject</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="参数-2"><a href="#参数-2" class="headerlink" title="参数"></a>参数</h3><h4 id="in-hObject"><a href="#in-hObject" class="headerlink" title="[in]hObject"></a>[in]hObject</h4><p>指示要关闭的句柄。<br><code>hObject</code>可以是任何允许被关闭的句柄，如文件、线程等。</p>]]></content>
      
      
      <categories>
          
          <category> Windows </category>
          
          <category> 线程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Windows </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>处理键盘</title>
      <link href="posts/731288ea57414571/"/>
      <url>posts/731288ea57414571/</url>
      
        <content type="html"><![CDATA[<p>键盘，是一个很重要的工具，负责用户输入。在CUI中，键盘处理从来就不是我们要操心的事，但是，我们现在是GUI。<br><a id="more"></a><br>处理键盘，主要有以下几种方法：</p><ul><li><code>WM_KEYDOWN</code>消息</li><li><code>WM_CHAR</code>消息</li><li><code>GetAsyncKeyState</code>函数</li></ul><h1 id="WM-KEYDOWN"><a href="#WM-KEYDOWN" class="headerlink" title="WM_KEYDOWN"></a>WM_KEYDOWN</h1><p>明显，这是一个Windows消息，会在键盘上的某个键被按下时发送。<br>但是如果真的用了这个消息，在按住时程序会很卡。</p><h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><p>这个称之为参数合适不合适……</p><h3 id="wParam"><a href="#wParam" class="headerlink" title="wParam"></a>wParam</h3><p>按键的虚拟键码，参见<a href="/9ea7215d45f55ac9/">虚拟按键编码</a></p><h3 id="lParam"><a href="#lParam" class="headerlink" title="lParam"></a>lParam</h3><p><code>lParam</code>的不同的二进制位代表不同的含义。见下表：</p><table><thead><tr><th>位</th><th>含义</th></tr></thead><tbody><tr><td>0-15</td><td>用户按住键而自动重复击键的次数</td></tr><tr><td>16-23</td><td>按键扫描码，由键盘生产厂家决定</td></tr><tr><td>24</td><td>指示是否为扩展按键(我也不知道什么意思)</td></tr><tr><td>25-28</td><td>保留</td></tr><tr><td>29</td><td>MSDN说是”The context code”，对于<code>WM_KEYDOWN</code>总是0</td></tr><tr><td>30</td><td>如果消息发送的时候按键是按下的为0，否则为1</td></tr><tr><td>31</td><td>MSDN说是”The transition code”，对于<code>WM_KEYDOWN</code>总是0</td></tr></tbody></table><h1 id="WM-CHAR"><a href="#WM-CHAR" class="headerlink" title="WM_CHAR"></a>WM_CHAR</h1><p>同样，一个Windows消息。</p><h2 id="参数-1"><a href="#参数-1" class="headerlink" title="参数"></a>参数</h2><h3 id="wParam-1"><a href="#wParam-1" class="headerlink" title="wParam"></a>wParam</h3><p>按键的字符编码，可直接使用<code>L&#39;字符&#39;</code>的形式，记住，<code>WM_CHAR</code>的<code>wParam</code>一直使用UTF-16！</p><h3 id="lParam-1"><a href="#lParam-1" class="headerlink" title="lParam"></a>lParam</h3><p>同样是一堆以二进制位表示的东西，如下：</p><table><thead><tr><th>位</th><th>含义</th></tr></thead><tbody><tr><td>0-15</td><td>用户按住键而自动重复击键的次数</td></tr><tr><td>16-23</td><td>按键扫描码，由键盘生产厂家决定</td></tr><tr><td>24</td><td>指示是否为扩展按键(我也不知道什么意思)</td></tr><tr><td>25-28</td><td>保留</td></tr><tr><td>29</td><td>指示Alt是否按下</td></tr><tr><td>30</td><td>如果消息发送的时候按键是按下的为0，否则为1</td></tr><tr><td>31</td><td>指示当前按键是否正在释放</td></tr></tbody></table><h1 id="GetAsyncKeyState"><a href="#GetAsyncKeyState" class="headerlink" title="GetAsyncKeyState"></a>GetAsyncKeyState</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>MSDN:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">SHORT <span class="title">GetAsyncKeyState</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">int</span> vKey</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure><p>Visual Studio 2017 - WinUser.h:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">WINUSERAPI SHORT WINAPI <span class="title">GetAsyncKeyState</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    _In_ <span class="keyword">int</span> vKey</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="参数-2"><a href="#参数-2" class="headerlink" title="参数"></a>参数</h2><h3 id="in-vKey"><a href="#in-vKey" class="headerlink" title="[in]vKey"></a>[in]vKey</h3><p>指定要测试的键的虚拟键码。<br>值得一提的是，<code>GetAsyncKeyState</code>对单个键起作用，所以可以同时检测多个按键。</p><h2 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h2><p>返回一堆除了最高位都无卵用的东西。而且其他的位还不一定是0。为了排除这些干扰，我们可以定义一个宏：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KEYDOWN(vk_code) ((GetAsyncKeyState(vk_code) &amp; 0x8000) ? 1 : 0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KEYUP(vk_code)((GetAsyncKeyState(vk_code) &amp; 0x8000) ? 0 : 1)</span></span><br></pre></td></tr></table></figure><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p>使用键盘的地方很多，在此以按Esc键时退出为例。</p><h2 id="GetMessage消息循环"><a href="#GetMessage消息循环" class="headerlink" title="GetMessage消息循环"></a>GetMessage消息循环</h2><p>在<code>WndProc</code>的<code>switch</code>语句中加入：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> WM_KEYDOWN:&#123;</span><br><span class="line"><span class="keyword">if</span>(wParam == VK_ESCAPE) &#123;</span><br><span class="line">SendMessage(hWnd,WM_DESTROY,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="PeekMessage消息循环"><a href="#PeekMessage消息循环" class="headerlink" title="PeekMessage消息循环"></a>PeekMessage消息循环</h2><p>在消息循环的<code>if</code>后加入：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(KEYDOWN(VK_ESCAPE))&#123;</span><br><span class="line">SendMessage(hWnd,WM_DESTROY,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h1><p><a href="https://docs.microsoft.com/en-us/windows/desktop/api/winuser/nf-winuser-getasynckeystate" target="_blank" rel="noopener">GetAsyncKeyState</a><br><a href="https://docs.microsoft.com/en-us/windows/desktop/inputdev/wm-keydown" target="_blank" rel="noopener">WM_KEYDOWN</a><br><a href="https://docs.microsoft.com/en-us/windows/desktop/inputdev/wm-char" target="_blank" rel="noopener">WM_CHAR</a></p>]]></content>
      
      
      <categories>
          
          <category> Windows </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Windows </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
