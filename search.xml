<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>公告板</title>
    <url>/posts/Notice/</url>
    <content><![CDATA[<p>这里是公告  </p>
<p>[2020/11/15] 仙咕下凡<br>[2020/11/15] Valine 出了点问题，评论暂时关闭</p>
]]></content>
  </entry>
  <entry>
    <title>C++的新特性</title>
    <url>/posts/0de8ddc338d164ca/</url>
    <content><![CDATA[<p>一些C++11/14/17/20的比较好玩的新特性</p>
<p>仅包含一小部分比较有意思的，其他特性还请移步C++Ref</p>
<p>[2020/11/6] 仙咕下凡.jpg</p>
<a id="more"></a>
<h1 id="C-11"><a href="#C-11" class="headerlink" title="C++11"></a>C++11</h1><h2 id="占位符类型说明符"><a href="#占位符类型说明符" class="headerlink" title="占位符类型说明符"></a>占位符类型说明符</h2><p>指示编译器自动推导变量类型的类型说明符</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">auto a &#x3D; 2;  &#x2F;&#x2F; int</span><br><span class="line">auto arr &#x3D; &#123; 1, 2, 3 &#125;; &#x2F;&#x2F; int[]</span><br><span class="line">auto ch &#x3D; &#39;a&#39;; &#x2F;&#x2F; char</span><br><span class="line">auto it &#x3D; v.begin(); &#x2F;&#x2F; vector&lt;int&gt;::iterator</span><br></pre></td></tr></table></figure>
<p>自C++14起能够推导函数返回值类型</p>
<h2 id="默认-amp-弃用函数"><a href="#默认-amp-弃用函数" class="headerlink" title="默认 &amp; 弃用函数"></a>默认 &amp; 弃用函数</h2><p>用于构造函数<br><code>default</code>指示该构造函数为默认构造函数，意即该函数默认初始化所有成员<br>一般情况下，编译器会将所有没写构造函数的类型的构造函数指定为默认构造函数<br>使用<code>default</code>强制编译器为其生成默认构造函数<br>使用<code>default</code>的类的所有成员均应满足 <em>DefaultConstructible</em> ，即该成员能够不带参数初始化，下面就是一个反例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class T &#123;</span><br><span class="line">	public:</span><br><span class="line">	int x, y, z;</span><br><span class="line">	&#x2F;&#x2F; T() &#x3D; default;</span><br><span class="line">	&#x2F;&#x2F; Uncomment ↑ to pass the compilation.</span><br><span class="line">	T(int x, int y, int z) : x(x), y(y), z(z) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">class _T &#123;</span><br><span class="line">	public:</span><br><span class="line">	T t;</span><br><span class="line">	_T() &#x3D; default;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">_T x;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">	x.t.x &#x3D; 0;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>delete</code>指示该构造函数被弃用，若该构造函数重载被使用，则程序编译失败</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class T &#123;</span><br><span class="line">	public:</span><br><span class="line">	int x, y, z;</span><br><span class="line">	T() &#x3D; default;</span><br><span class="line">	T(int x, int y) &#x3D; delete;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">	T a(1, 2); &#x2F;&#x2F; Error</span><br><span class="line">	T x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="右值引用"><a href="#右值引用" class="headerlink" title="右值引用"></a>右值引用</h2><p>一种延长生存期的方法</p>
<h2 id="列表初始化"><a href="#列表初始化" class="headerlink" title="列表初始化"></a>列表初始化</h2><p>能够以</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Type a &#x3D; &#123; 1, 2, 3 &#125;;</span><br><span class="line">Type x &#123; 1, 2, 3 &#125;;</span><br><span class="line">Type x(&#123; 1, 2, 3 &#125;);</span><br><span class="line">func(&#123; 1, 9, 2 &#125;);</span><br></pre></td></tr></table></figure>
<p>等类似形式调用函数<br><code>initializer_list&lt;Type&gt;</code>代表<code>Type</code>类型的列表<br><code>l.begin()</code>为指向第一个元素的迭代器<br><code>l.end()</code>为指向最后一个元素+1的迭代器<br><code>l.size()</code>为列表元素个数</p>
<button class="runcode-button" file="InitializerList.cpp"></button>

<h2 id="Lambmda表达式"><a href="#Lambmda表达式" class="headerlink" title="Lambmda表达式"></a>Lambmda表达式</h2><p>参见以往文章</p>
<h2 id="空指针"><a href="#空指针" class="headerlink" title="空指针"></a>空指针</h2><p>和<code>NULL</code>差不多<br>那为啥要加一个这玩意呐<br>因为<code>NULL</code>是一个常量，一般被定义为<code>0</code><br>所以有的时候传入<code>NULL</code>作为参数的时候<br>会调用<code>long long</code>或者<code>int</code>的重载<br>所以C++11加入了<code>nullptr</code>代表空指针<br>这玩意应该不需要例子 当<code>NULL</code>用就可以</p>
<h2 id="形参包"><a href="#形参包" class="headerlink" title="形参包"></a>形参包</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">template &lt;class ... Args&gt;</span><br><span class="line">class T &#123;</span><br><span class="line">	&#x2F;&#x2F; ...</span><br><span class="line">&#125;;</span><br><span class="line">T&lt;&gt; t;</span><br><span class="line">T&lt;int&gt; t2;</span><br><span class="line">T&lt;int, int, long, double&gt; t3;</span><br></pre></td></tr></table></figure>
<p>可变长度的<code>template</code>参数<br>也可用于定义函数等<br>函数的模板可以通过推导由编译器填入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">template &lt;class ... Args&gt;</span><br><span class="line">void f(Args...x) &#123;&#125;</span><br><span class="line"></span><br><span class="line">f();</span><br><span class="line">f(1);</span><br><span class="line">f(1, 2, 3.0, &quot;awsl&quot;);</span><br></pre></td></tr></table></figure>
<p>形参包可以展开</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">f(&amp;args...); &#x2F;&#x2F; &#x3D;&gt; f(&amp;arg1, &amp;arg2, ...);</span><br><span class="line">f(n, ++args...); &#x2F;&#x2F; &#x3D;&gt; f(n, ++arg1, ++arg2, ...);</span><br><span class="line">f(g(args...) + args...) &#x2F;&#x2F; &#x3D;&gt; f(g(arg1, arg2, ...) + arg1, g(arg1, arg2, ...) + arg2, ...);</span><br></pre></td></tr></table></figure>
<p>但是好像没啥用的样子<br>C++17加入表达式折叠</p>
<p>顺便，这玩意可以写快读</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Ty</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">read</span>(<span class="title">Ty</span> &amp;<span class="title">x</span>) &#123;</span></span><br><span class="line">	x = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">char</span> ch = getchar();</span><br><span class="line">	<span class="keyword">int</span> f = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) &#123;</span><br><span class="line">		<span class="keyword">if</span> (ch == <span class="string">'-'</span>) f = -f;</span><br><span class="line">		ch = getchar();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) &#123;</span><br><span class="line">		x = x * <span class="number">10</span> + ch - <span class="string">'0'</span>;</span><br><span class="line">		ch = getchar();</span><br><span class="line">	&#125;</span><br><span class="line">	x *= f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Ty</span>, <span class="title">class</span> ... <span class="title">Var</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">read</span>(<span class="title">Ty</span>&amp; <span class="title">x</span>, <span class="title">Var</span>&amp;... <span class="title">args</span>) &#123;</span></span><br><span class="line">	read(x);</span><br><span class="line">	read(args...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="属性说明符"><a href="#属性说明符" class="headerlink" title="属性说明符"></a>属性说明符</h2><p>比较奇怪的东西</p>
<blockquote>
<p>为类型、对象、代码等引入由实现定义的属性。</p>
</blockquote>
<p>几乎可以用于所有东西</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[[attr]]</span><br><span class="line">[[attr1, attr2(arg), ...]]</span><br><span class="line">[[namespace::attr1, ...]]</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[[noreturn]]</span><br><span class="line">void f() &#123;</span><br><span class="line">	throw std::runtime_error(&quot;qwq&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以下是C++标准属性的一部分：</p>
<table>
<thead>
<tr>
<th style="text-align:center">属性</th>
<th style="text-align:center">含义</th>
<th style="text-align:center">C++版本</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>[[noreturn]]</code></td>
<td style="text-align:center">函数不返回(抛出错误)</td>
<td style="text-align:center">11</td>
</tr>
<tr>
<td style="text-align:center"><code>[[deprecated]]</code>/<code>[[deprecated(&quot;reason&quot;)]]</code></td>
<td style="text-align:center">函数不推荐使用(由于 <em>reason</em>)，但允许使用</td>
<td style="text-align:center">14</td>
</tr>
<tr>
<td style="text-align:center"><code>[[nodiscard]]</code></td>
<td style="text-align:center">函数返回值不应被舍弃，否则输出警告</td>
<td style="text-align:center">17</td>
</tr>
<tr>
<td style="text-align:center"><code>[[maybe_unused]]</code></td>
<td style="text-align:center">函数的参数可能有未使用的参数，指示编译器不输出警告</td>
<td style="text-align:center">17</td>
</tr>
</tbody>
</table>
<p>其他C++标准属性请从页面底部跳转至C++Ref查看<br>编译器独有的属性请到编译器文档查看</p>
<h2 id="基于范围的for"><a href="#基于范围的for" class="headerlink" title="基于范围的for"></a>基于范围的for</h2><p>在范围上执行<code>for</code><br>值得注意的是，C++的<code>for (auto i : v)</code>不同于JS的<code>for (i in v)</code>，范围<code>for</code>的变量<code>i</code>不是键而是值<br>意即<code>v = { 3, 2, 1 }</code>时,<code>for (int i : v)</code>每轮<code>i</code>的值分别为<code>3, 2, 1</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vector&lt;int&gt; v &#x3D; &#123; 1, 9, 2, 6, 0, 8, 1, 7 &#125;;</span><br><span class="line">for (int i : v) &#123;</span><br><span class="line">	cout &lt;&lt; i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>自C++17起，可以使用<code>auto [x, y]</code>的结构化绑定形式，如:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">map&lt;string, int&gt; m;</span><br><span class="line">m[&quot;qwq&quot;] &#x3D; 1;</span><br><span class="line">m[&quot;qaq&quot;] &#x3D; 2;</span><br><span class="line">for (auto [key, val] : m) &#123;</span><br><span class="line">	cout &lt;&lt; key &lt;&lt; &#39;&#x3D;&#39; &lt;&lt; val &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Output:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">qaq&#x3D;2</span><br><span class="line">qwq&#x3D;1</span><br></pre></td></tr></table></figure>
<h1 id="C-14"><a href="#C-14" class="headerlink" title="C++14"></a>C++14</h1><p>C++14 没啥比较好玩的东西 少写点吧<br><del>毕竟 C++Ref 的 C++14 都没啥东西</del></p>
<h2 id="变量模板"><a href="#变量模板" class="headerlink" title="变量模板"></a>变量模板</h2><p>顾名思义，变量也有模板了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">template &lt;class T&gt;</span><br><span class="line">T x &#x3D; 114514;</span><br></pre></td></tr></table></figure>
<h2 id="文本运算符"><a href="#文本运算符" class="headerlink" title="文本运算符"></a>文本运算符</h2><p>就像复数的赋值一样</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">complex x &#x3D; 2i;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">TYPE operator &quot;&quot; CHAR (TYPE ARG) &#123;</span><br><span class="line">	&#x2F;&#x2F; ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意，参数的类型只能是<code>unsigned long long</code>或<code>char</code><br><code>char</code>除了<code>_</code>之外的单个字符会报警告<br>且这种函数不能作为成员函数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int operator&quot;&quot; _ (char ch) &#123;</span><br><span class="line">	return isdigit(ch) ? ch - &#39;0&#39; : (isupper(ch) ? ch - &#39;A&#39; + 10 : ch - &#39;a&#39; + 10);</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">	cout &lt;&lt; &#39;f&#39;_ &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出<code>15</code></p>
<h1 id="C-17"><a href="#C-17" class="headerlink" title="C++17"></a>C++17</h1><h2 id="折叠表达式"><a href="#折叠表达式" class="headerlink" title="折叠表达式"></a>折叠表达式</h2><p>以如下方式展开形参包：</p>
<ol>
<li>一元右折叠<code>(E opt ...)</code> =&gt; <code>(E1 opt (E2 opt ... (En-1 opt En)))</code></li>
<li>一元左折叠<code>(... opt E)</code> =&gt; <code>(((E1 opt E2) opt ...) opt En)</code></li>
<li>二元右折叠<code>(E opt ... opt I)</code> =&gt; <code>(E1 opt (... opt (En-1 opt (En opt I))))</code></li>
<li>二元左折叠<code>(I opt ... opt E)</code> =&gt; <code>((((I opt E1) opt E2) opt ...) opt En)</code></li>
</ol>
<p>如:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">template &lt;class...Ty&gt;</span><br><span class="line">bool all(Ty... args) &#123;</span><br><span class="line">	return (... &amp;&amp; args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool b &#x3D; all(true, false, true, true); </span><br><span class="line">&#x2F;&#x2F; &#x3D;&gt; ((true &amp;&amp; false) &amp;&amp; true) &amp;&amp; true</span><br><span class="line">&#x2F;&#x2F; &#x3D; false</span><br></pre></td></tr></table></figure>
<p>一元折叠用于零长度的包展开时，仅允许以下运算符：</p>
<ol>
<li><code>&amp;&amp;</code>, 值为<code>true</code></li>
<li><code>||</code>, 值为<code>false</code></li>
<li><code>,</code>, 值为<code>void()</code></li>
</ol>
<h2 id="结构化绑定"><a href="#结构化绑定" class="headerlink" title="结构化绑定"></a>结构化绑定</h2><blockquote>
<p>绑定指定名称到初始化器的子对象或元素。<br>类似引用，结构化绑定是既存对象的别名。不同于引用的是，结构化绑定的类型不必为引用类型。</p>
</blockquote>
<p>大概这样用:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">auto &#x2F;* Ref Opt *&#x2F; [ &#x2F;* List *&#x2F; ] &#x3D; &#x2F;* Expression *&#x2F;;	&#x2F;&#x2F; 1</span><br><span class="line">auto &#x2F;* Ref Opt *&#x2F; [ &#x2F;* List *&#x2F; ] &#123; &#x2F;* Expression *&#x2F; &#125;;	&#x2F;&#x2F; 2</span><br><span class="line">auto &#x2F;* Ref Opt *&#x2F; [ &#x2F;* List *&#x2F; ] ( &#x2F;* Expression *&#x2F; );	&#x2F;&#x2F; 3</span><br></pre></td></tr></table></figure>
<p>其中<code>List</code>为标识符列表，<code>Expression</code>为表达式</p>
<p>请注意<code>Expression</code>的顶层不应含有<code>,</code>(文法上为 <em>赋值表达式</em>)，且其类型为数组或非<code>union</code><br><code>Expression</code>不应含有<code>List</code>中的标识符</p>
<p>例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int a[] &#x3D; &#123; 2, 3, 3 &#125;;</span><br><span class="line">auto [x, y, z] &#x3D; a;</span><br><span class="line">cout &lt;&lt; x &lt;&lt; y &lt;&lt; z &lt;&lt; endl;	&#x2F;&#x2F; Output 233</span><br><span class="line">&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;</span><br><span class="line">tuple&lt;int, char, string&gt; tpl(2, &#39;3&#39;, &quot;3&quot;);</span><br><span class="line">auto [x, y, z] &#x3D; tpl;</span><br><span class="line">&#x2F;&#x2F; auto [x, y, z] &#x3D; make_tuple(2, &#39;3&#39;, &quot;3&quot;);</span><br><span class="line">cout &lt;&lt; x &lt;&lt; y &lt;&lt; z &lt;&lt; endl;	&#x2F;&#x2F; Output 233</span><br><span class="line">&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;</span><br><span class="line">int a[] &#x3D; &#123; 1, 2, 3 &#125;;</span><br><span class="line">auto&amp; [x, y, z] &#x3D; a;</span><br><span class="line">x &#x3D; 2, y &#x3D; 3;</span><br><span class="line">cout &lt;&lt; a[0] &lt;&lt; a[1] &lt;&lt; a[2];	&#x2F;&#x2F; Output 233</span><br><span class="line">&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;</span><br><span class="line">struct S &#123;</span><br><span class="line">	int a, b, c;</span><br><span class="line">	S() &#x3D; default;</span><br><span class="line">	S(int a, int b, int c) : a(a), b(b), c(c) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">S f() &#123; return S(2, 3, 3); &#125;</span><br><span class="line">auto [x, y, z] &#x3D; f();</span><br><span class="line">cout &lt;&lt; x &lt;&lt; y &lt;&lt; z &lt;&lt; endl;	&#x2F;&#x2F; Output 233</span><br></pre></td></tr></table></figure>
<h2 id="任意类型的单个值"><a href="#任意类型的单个值" class="headerlink" title="任意类型的单个值"></a>任意类型的单个值</h2><p>头文件<code>&lt;any&gt;</code><br><strong>不包含于<code>&lt;bits/stdc++.h&gt;</code></strong></p>
<p>逐渐向JS靠拢？（雾</p>
<p>正如其名，<code>any</code>可以存储任何类型的值<br><code>any::type()</code>可以返回类型的<code>typeid</code><br><code>any::reset()</code>可以销毁所含值<br><code>any::swap()</code>可以交换两个<code>any</code><br><code>any_cast&lt;Type&gt;(Any)</code>可以访问<code>Any</code>所容纳的对象，若类型错误会抛出<code>std::bad_any_cast</code>异常</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;bits&#x2F;stdc++.h&gt;</span><br><span class="line">#include &lt;any&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">any a;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">	a &#x3D; &quot;awsl&quot;;</span><br><span class="line">	a &#x3D; []()&#123;&#125;;</span><br><span class="line">	a &#x3D; main;</span><br><span class="line">	a &#x3D; 1;</span><br><span class="line">	cout &lt;&lt; any_cast&lt;int&gt;(a) &lt;&lt; endl;</span><br><span class="line">	try &#123;</span><br><span class="line">		any_cast&lt;char&gt;(a);</span><br><span class="line">	&#125;</span><br><span class="line">	catch (exception&amp; e) &#123;</span><br><span class="line">		cout &lt;&lt; e.what() &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="可选"><a href="#可选" class="headerlink" title="可选"></a>可选</h2><p>头文件<code>&lt;optional&gt;</code><br>顾名思义，可以存在也可以不存在的值</p>
<p>空<code>optional</code>一般为<code>nullopt</code><br><code>optional::value()</code>可获取<code>*this</code>中存储的值，若<code>*this</code>不含值则抛出<code>std::bad_optional_access</code><br><code>optional::has_value()</code>可检查<code>*this</code>中是否有值，有则返回<code>true</code>，否则返回<code>false</code><br><code>optional::value_or(val)</code>在<code>*this</code>含有值则返回其存储的值，否则返回<code>val</code><br>运算符重载：</p>
<ul>
<li><code>operator *</code>/<code>operator -&gt;</code> - 访问<code>*this</code>中存储的值，不检查是否含值，若不含值则返回默认构造的值</li>
<li><code>operator bool</code> - 和<code>has_value()</code>等价</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">optional&lt;int&gt; proc(int x) &#123;</span><br><span class="line">	if (!x) &#123;</span><br><span class="line">		return nullopt;</span><br><span class="line">	&#125;</span><br><span class="line">	return x &lt;&lt; 1;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;</span><br><span class="line">optional&lt;int&gt; ans &#x3D; f();</span><br><span class="line">if (ans) &#123;		&#x2F;&#x2F; operator bool()</span><br><span class="line">&#x2F;&#x2F; if (ans.has_value()) &#123;</span><br><span class="line">	&#x2F;&#x2F; ...</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">	&#x2F;&#x2F; ...</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;</span><br><span class="line">optional&lt;int&gt; ans &#x3D; f();</span><br><span class="line">try &#123;</span><br><span class="line">	cout &lt;&lt; f.value() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">catch (exception&amp; e) &#123;</span><br><span class="line">	cout &lt;&lt; e.what() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="C-20"><a href="#C-20" class="headerlink" title="C++ 20"></a>C++ 20</h1><h2 id="格式化"><a href="#格式化" class="headerlink" title="格式化"></a>格式化</h2><p><code>sprintf</code>的安全替代品</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">string s &#x3D; format(&quot;&#123;&#125; &#123;&#125; &#123;&#125;&quot;, &quot;Hello&quot;, &quot;C++&quot;, 20); &#x2F;&#x2F; s &#x3D;&#x3D; &quot;Hello C++ 20&quot;</span><br></pre></td></tr></table></figure>
<p>若提供的参数少于字符串中的<code>{}</code>个数，行为未定义<br>提供的参数多于字符串中的<code>{}</code>个数没关系</p>
<h2 id="三路比较运算符"><a href="#三路比较运算符" class="headerlink" title="三路比较运算符"></a>三路比较运算符</h2><p>形式为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">x &lt;&#x3D;&gt; y</span><br></pre></td></tr></table></figure>
<p>表达式返回一个值，使得</p>
<ul>
<li><code>x &lt; y</code>则<code>(x &lt;=&gt; y) &lt; 0</code></li>
<li><code>x &gt; y</code>则<code>(x &lt;=&gt; y) &gt; 0</code></li>
<li><code>x == y</code>则<code>(x &lt;=&gt; y) == 0</code></li>
</ul>
<h2 id="聚合初始化"><a href="#聚合初始化" class="headerlink" title="聚合初始化"></a>聚合初始化</h2><p>不好说，看示例</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct S &#123;</span><br><span class="line">	int x, y, z;</span><br><span class="line">&#125;;</span><br><span class="line">S a &#x3D; &#123; .x &#x3D; 1, .y &#x3D; 2 &#125;;</span><br><span class="line">&#x2F;&#x2F; S c &#x3D; &#123; .y &#x3D; 1, .x &#x3D; 2 &#125; &#x2F;&#x2F; Error</span><br></pre></td></tr></table></figure>
<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>MoveToEx被<code>concept</code>整懵了，所以先写点能够理解的吧</p>
<p>所谓概念，是一种辅助编译器以及开发者定位问题的东西</p>
<p>C++Ref 如此描述概念的优点：</p>
<blockquote>
<p>在编译时检测约束违规，在模板实例化过程的早期进行，这导致错误信息更易理解。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; l = &#123;<span class="number">3</span>,<span class="number">-1</span>,<span class="number">10</span>&#125;;</span><br><span class="line"><span class="built_in">std</span>::sort(l.begin(), l.end()); </span><br><span class="line"><span class="comment">//无概念的典型编译器诊断：</span></span><br><span class="line"><span class="comment">//  invalid operands to binary expression ('std::_List_iterator&lt;int&gt;' and</span></span><br><span class="line"><span class="comment">//  'std::_List_iterator&lt;int&gt;')</span></span><br><span class="line"><span class="comment">//                           std::__lg(__last - __first) * 2);</span></span><br><span class="line"><span class="comment">//                                     ~~~~~~ ^ ~~~~~~~</span></span><br><span class="line"><span class="comment">// …… 50 行输出……</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//有概念的典型编译器诊断：</span></span><br><span class="line"><span class="comment">//  error: cannot call std::sort with std::_List_iterator&lt;int&gt;</span></span><br><span class="line"><span class="comment">//  note:  concept RandomAccessIterator&lt;std::_List_iterator&lt;int&gt;&gt; was not satisfied</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C++</category>
        <category>新特性</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>C++11</tag>
        <tag>C++14</tag>
        <tag>C++17</tag>
        <tag>C++20</tag>
      </tags>
  </entry>
  <entry>
    <title>MoveToEx的毒瘤码风</title>
    <url>/posts/901a09ed661aa5e7/</url>
    <content><![CDATA[<p>我来氵博客了/cy  </p>
<a id="more"></a>
<p>我的码风大致上和Visual Studio自动格式化的一个样（（（<br>大概是那段时间VS用多了<br>然后就习惯了  </p>
<p>由于MoveToEx的码风很毒瘤，本篇比较长（<br>没有提及的东西大多都可以用提到的东西拼出来  </p>
<h1 id="Basic"><a href="#Basic" class="headerlink" title="Basic"></a>Basic</h1><h2 id="空格-amp-换行"><a href="#空格-amp-换行" class="headerlink" title="空格 &amp; 换行"></a>空格 &amp; 换行</h2><p>4空格或1Tab缩进<br>能加空格的地方只要加上好看基本都会加<br>大括号不换行  </p>
<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><h3 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h3><p>普通变量的声明没啥好说的<br>如果在一行声明单个指针变量，<code>*</code>靠近数据类型，否则<code>*</code>靠近变量名<br>使用<code>=</code>而不是构造函数进行变量初始化  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">1001</span>];</span><br><span class="line"><span class="built_in">string</span> s = <span class="string">"qwq"</span>;</span><br><span class="line"><span class="keyword">int</span>* p;</span><br><span class="line">Node* root = <span class="keyword">new</span> Node();</span><br><span class="line"><span class="keyword">int</span> *_a, *_b;</span><br></pre></td></tr></table></figure>
<h3 id="命名"><a href="#命名" class="headerlink" title="命名"></a>命名</h3><p>极简命名<br>能用三个字母以内的一般都会用<br>有多个相似含义变量时不会用<code>l</code>,<code>ll</code>,<code>L</code>,<code>LL</code>一类的变量名<br>（我喜欢在前边加下划线  </p>
<p>对于图，常用的有：<br><code>n</code>, <code>m</code>, <code>e</code>(Edge), <code>ec</code>(Edge Count), <code>first</code>, <code>u</code>(from), <code>v</code>(to), <code>w</code>, <code>scc</code>(Strong Connected Component), <code>vis</code>(VISited), <code>dfn</code><br>对于树，常用的有：<br><code>n</code>, <code>fa</code>(FAther), <code>son</code>, <code>ls</code>(Left Son), <code>rs</code>(Right Son), <code>siz</code>(SIZe of subtree), <code>dep</code>(DEPth), <code>seg</code>(position in SEGment tree), <code>dfn</code>, <code>top</code><br>对于STL，常用的有：<br><code>q</code>(<code>queue</code>,<code>deque</code>,<code>priority_queue</code>), <code>pq</code>(<code>priority_queue</code>，当且仅当<code>q</code>被占用),<code>st</code>(<code>stack</code>), <code>s</code>(<code>string</code>), <code>it</code>(<code>iterator</code>)<br>其他常用的有：<br><code>p</code>(Pointer), <code>opt</code>(OPeraTion), <code>idx</code>(InDeX), <code>cnt</code>(CouNT), <code>tot</code>(TOTal), <code>ans</code>(ANSwer), <code>suc</code>(SUCcess), <code>pos</code>(POSition), <code>dx</code>(Delta X), <code>dy</code>(Delta Y), <code>mid</code>(MIDdle)  </p>
<h3 id="运算"><a href="#运算" class="headerlink" title="运算"></a>运算</h3><p>运算数和运算符之间有空格<br>括号和里面的东西之间没有空格<br>整个括号和一个变量处理方法相同<br>需要显式转换的时候会用<code>type(val)</code>的构造函数形式<br>当然有的时候条件不允许就没办法了<br>（比如<code>#define int long long</code>然后<code>int(0)</code>就会CE  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">a = b;</span><br><span class="line">a = <span class="keyword">int</span>(p);</span><br><span class="line"><span class="keyword">int</span>* x = &amp;a;</span><br><span class="line"><span class="keyword">int</span> t = a + ((b + (c + d)) &lt;&lt; <span class="number">1</span> | <span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>不加空格</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">101</span>];</span><br><span class="line">a[<span class="number">0</span>] = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><p>每个参数后的<code>,</code>与下一个参数之间有空格<br>适用于函数调用&amp;函数声明  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">"%c%c%c"</span>, <span class="string">'q'</span>, <span class="string">'w'</span>, <span class="string">'q'</span>);</span><br></pre></td></tr></table></figure>
<h3 id="函数体"><a href="#函数体" class="headerlink" title="函数体"></a>函数体</h3><p>函数体一律放在主函数之前<br>带有可变参数列表的在<code>...</code>前加空格  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">qwq</span><span class="params">(<span class="keyword">int</span> n, ...)</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="调用"><a href="#调用" class="headerlink" title="调用"></a>调用</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">func(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure>
<h3 id="函数名"><a href="#函数名" class="headerlink" title="函数名"></a>函数名</h3><p>基本上也就那几个<br><code>check</code> 二分的checker或用于检查一个答案是否合法<br><code>calc</code>/<code>solve</code> 计算值<br><code>dfs</code>/<code>bfs</code> 搜索<br><code>init</code> 预处理<br><code>clear</code> 多测清空<br><code>find</code> 找符合条件的值<br>…</p>
<h2 id="条件判断"><a href="#条件判断" class="headerlink" title="条件判断"></a>条件判断</h2><h3 id="if-else"><a href="#if-else" class="headerlink" title="if-else"></a>if-else</h3><p><code>if</code>和<code>(</code>之间有空格<br><code>)</code>和<code>{</code>之间有空格<br><code>}</code>和<code>else</code>之间换行<br><code>else</code>和<code>{</code>之间有空格  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="comment">/* Condition */</span>) &#123;</span><br><span class="line">	<span class="comment">// Code</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (<span class="comment">/* Condition */</span>) &#123;</span><br><span class="line">	<span class="comment">// Code</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">	<span class="comment">// Code</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="switch-case-default"><a href="#switch-case-default" class="headerlink" title="switch-case-default"></a>switch-case-default</h3><p><code>switch</code>和<code>(</code>之间有空格<br><code>)</code>和<code>{</code>之间有空格<br><code>case</code>和<code>default</code>标签缩进多1个Tab<br><code>:</code>和<code>{</code>之间有空格<br><code>case</code>和<code>default</code>中的代码缩进多1个Tab  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> (<span class="comment">/* Variable */</span>) &#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="comment">/* Value */</span>: &#123;</span><br><span class="line">		<span class="comment">// Code</span></span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">default</span>: &#123;</span><br><span class="line">		<span class="comment">// Code</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="三目"><a href="#三目" class="headerlink" title="三目"></a>三目</h3><p>空格能加就加<br>有的时候为了避免优先级问题会加一堆括号  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">a &gt; b ? a : b;</span><br></pre></td></tr></table></figure>
<h2 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h2><h3 id="for"><a href="#for" class="headerlink" title="for"></a>for</h3><p><code>for</code>和<code>(</code>有空格<br>每个<code>;</code>和其后的东西有空格<br><code>)</code>和<code>{</code>有空格</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="comment">/* Expression */</span>; <span class="comment">/* Condition */</span>; <span class="comment">/* Expression */</span>) &#123;</span><br><span class="line">	<span class="comment">// Code</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="while"><a href="#while" class="headerlink" title="while"></a>while</h3><p><code>while</code>和<code>(</code>有空格<br><code>)</code>和<code>{</code>有空格  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="comment">/* Condition */</span>) &#123;</span><br><span class="line">	<span class="comment">// Code</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>特别地，当多组数据循环<code>t</code>次时：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (t --&gt; <span class="number">0</span>) &#123;</span><br><span class="line">	<span class="comment">// Code</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="do-while"><a href="#do-while" class="headerlink" title="do-while"></a>do-while</h3><p>不常用，忽略  </p>
<h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p>NULL</p>
<h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>一般会用<code>#define</code>而不是<code>const int</code>之类<br>常量名也就那几个<br><code>Ha</code> = 取模的数<br><code>MAXN</code>/<code>MAXM</code> = 数据上限  </p>
<h3 id="常用"><a href="#常用" class="headerlink" title="常用"></a>常用</h3><p>一些奇奇怪怪的<code>define</code>出来的东西  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> for_each(it, a) for (auto it = a.begin(); it != a.end(); ++it)</span></span><br></pre></td></tr></table></figure>
<h1 id="Advanced"><a href="#Advanced" class="headerlink" title="Advanced"></a>Advanced</h1><h2 id="class"><a href="#class" class="headerlink" title="class"></a>class</h2><p><code>CLASS_NAME</code>和<code>{</code>之间有空格<br><code>public</code>,<code>private</code>/<code>protected</code>比<code>class</code>多一级缩进<br>成员和<code>public</code>/<code>private</code>/<code>protected</code>相同缩进<br>构造函数会尽量用<code>Class() = default</code>形式<br>如果<code>default</code>不能用会用<code>Class() : val1(0), val2(0) {}</code>的形式  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> /* <span class="title">Name</span> */ &#123;</span></span><br><span class="line">	<span class="keyword">public</span>;</span><br><span class="line">	<span class="comment">/* Name */</span>() = <span class="keyword">default</span>;</span><br><span class="line">	~<span class="comment">/* Name */</span>() &#123;&#125;</span><br><span class="line">	<span class="comment">/* Type */</span> <span class="comment">/* Member */</span>(<span class="comment">/* Args */</span>) &#123;</span><br><span class="line">		<span class="comment">// Code</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="λ表达式"><a href="#λ表达式" class="headerlink" title="λ表达式"></a>λ表达式</h2><p><code>[]()</code>和<code>-&gt;</code>之间有空格<br><code>-&gt;</code>和返回值类型之间有空格<br>类型和函数体之间有空格  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> func = [](<span class="comment">/* Args */</span>) -&gt; <span class="comment">/* Type */</span> &#123; <span class="comment">/* Code */</span> &#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>灌水区</category>
      </categories>
      <tags>
        <tag>代码风格</tag>
      </tags>
  </entry>
  <entry>
    <title>「题解」 SPOJ BALNUM</title>
    <url>/posts/aa64ca17909928ae/</url>
    <content><![CDATA[<p>数位+状压的毒瘤（恼<br><del>算法标签的暴力枚举是啥啊！</del></p>
<a id="more"></a>
<p><a href="https://www.luogu.com.cn/problem/SP10606" target="_blank" rel="noopener">Luogu - SP10606</a><br><a href="https://www.spoj.com/problems/BALNUM/" target="_blank" rel="noopener">SPOJ BALNUM</a>  </p>
<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><p>给定$l,r$，问有多少$l,r$之间的数满足「偶数出现奇数次，奇数出现偶数次」  </p>
<p>$1 \leq l,r \leq 10^{19}$  </p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>看题面和数据范围显然是数位DP  </p>
<blockquote>
<p>数位DP<br>看到number我就知道了</p>
<p style="text-align: right">–Herself32</p>
</blockquote>
<p>orz herself32  </p>
<p>至于状态……<br>$f[dep][c_0][c_1][c_2][c_3][c_4][c_5][c_6][c_7][c_8][c_9]$<br>长度为$dep$,若$c_i$的值为$2$表示$i$没有出现，否则为出现次数对2取模后的结果<br>这种东西硬写的话<code>dfs</code>的片段应该是非常壮观的<br>但是用<code>vector</code>的话会慢死<br>所以状压一下<br>由于$c_i$最大是2，所以为每个数分配2个位就够了<br>这样用的空间最大大概是$8 \times 20 \times (1 \operatorname{Lsh} 20) = 160 \times 2^{20} = 1.6e8 \text{Bytes} = 160 \text{MiB}$，能过<br>为了写起来方便，把0-9倒过来压，即$x \operatorname{Rsh} (2n) \operatorname{And} 3$(<code>(x &gt;&gt; (n &lt;&lt; 1)) &amp; 3</code>)表示$c_n$<br>然后就是数位DP老套路了<br>MoveToEx很菜，如果状压写的不好，在吊打他的时候请手下留情</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><div class="note warning">反作弊</div>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> get(x, n) (((x) &gt;&gt; ((n) &lt;&lt; 1)) &amp; 3)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"></span><br><span class="line">ull f[<span class="number">21</span>][<span class="number">1</span> &lt;&lt; <span class="number">20</span>];</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">21</span>];</span><br><span class="line"><span class="keyword">int</span> t;</span><br><span class="line">ull l, r;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> n, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">	x &amp;= (~(<span class="number">3</span> &lt;&lt; (n * <span class="number">2</span>)));</span><br><span class="line">	x |= (v &lt;&lt; (n * <span class="number">2</span>));</span><br><span class="line">	<span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ull <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> dep, <span class="keyword">int</span> x, <span class="keyword">int</span> zro, <span class="keyword">int</span> equ)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!dep) &#123;</span><br><span class="line">		ull ans = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">9</span>; ++i, x &gt;&gt;= <span class="number">2</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (i &amp; <span class="number">1</span>) ans = ans &amp;&amp; ((x &amp; <span class="number">3</span>) ^ <span class="number">1</span>);</span><br><span class="line">			<span class="keyword">else</span> ans = ans &amp;&amp; (x &amp; <span class="number">3</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> ans;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (!equ &amp;&amp; zro &amp;&amp; ~f[dep][x]) <span class="keyword">return</span> f[dep][x];</span><br><span class="line">	ull ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> lim = equ ? a[dep] : <span class="number">9</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= lim; ++i) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!i) &#123;</span><br><span class="line">			ans += dfs(dep - <span class="number">1</span>, change(x, <span class="number">0</span>, zro ? ((x &amp; <span class="number">3</span>) == <span class="number">2</span> ? <span class="number">1</span> : !(x &amp; <span class="number">3</span>)) : (x &amp; <span class="number">3</span>)), zro, equ &amp;&amp; i == lim);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			ans += dfs(dep - <span class="number">1</span>, change(x, i, get(x,i) == <span class="number">2</span> ? <span class="number">1</span> : !get(x,i)), <span class="number">1</span>, equ &amp;&amp; i == lim);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (!equ) f[dep][x] = ans;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ull <span class="title">solve</span><span class="params">(ull x)</span> </span>&#123;</span><br><span class="line">	a[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (x) &#123;</span><br><span class="line">		a[++a[<span class="number">0</span>]] = x % <span class="number">10</span>;</span><br><span class="line">		x /= <span class="number">10</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> dfs(a[<span class="number">0</span>], <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(f, <span class="number">0xff</span>, <span class="keyword">sizeof</span>(f));</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">	<span class="keyword">while</span> (t --&gt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; l &gt;&gt; r;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; (solve(r) - solve(l - <span class="number">1</span>)) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>数位DP</tag>
        <tag>状压DP</tag>
      </tags>
  </entry>
  <entry>
    <title>Visual Studio Code 配置小记</title>
    <url>/posts/86e5d79b5160c70e/</url>
    <content><![CDATA[<p>咕~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  </p>
<p>换回NexT主题<br>mdui有亿点慢</p>
<a id="more"></a>
<p>咕了这么长时间了，今天来搞搞VSC  </p>
<p>本文假设您已经有基础的JSON等知识（能够理解<code>MoveToEx.isJuRuo</code>之类<br>请注意，Visual Studio Code在打开文件夹时会有最佳的效果，本文假定您已经打开了一个文件夹  </p>
<h1 id="基础配置"><a href="#基础配置" class="headerlink" title="基础配置"></a>基础配置</h1><h2 id="编译-amp-运行环境"><a href="#编译-amp-运行环境" class="headerlink" title="编译&amp;运行环境"></a>编译&amp;运行环境</h2><h3 id="中文语言包"><a href="#中文语言包" class="headerlink" title="中文语言包"></a>中文语言包</h3><p>中文环境<br>扩展-&gt;Chinese (Simplified) Language Pack for Visual Studio Code-&gt;Install<br>完成后按照提示重启code即可</p>
<h3 id="C-C"><a href="#C-C" class="headerlink" title="C/C++"></a>C/C++</h3><p>这还有啥好说的<br>扩展-&gt;C/C++-&gt;Install即可  </p>
<h3 id="Code-Runner"><a href="#Code-Runner" class="headerlink" title="Code Runner"></a>Code Runner</h3><p>扩展-&gt;Code Runner-&gt;Install即可  </p>
<p>不过运行C++代码需要改动一下配置文件<br>以下是我的有关CodeRunner的配置<br><kbd>Ctrl</kbd>+<kbd>Shift</kbd>+<kbd>P</kbd> 输入 <code>Preferences: Open Settings (JSON)</code> 后回车  </p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">"code-runner.customCommand": "",</span><br><span class="line">"code-runner.runInTerminal": true,</span><br><span class="line">"code-runner.clearPreviousOutput": true,</span><br><span class="line">"code-runner.saveFileBeforeRun": true</span><br></pre></td></tr></table></figure>
<p>然后去MinGW的官网安装一个MinGW<br>当然你想用MinGW-W64没人拦着你<br>这里偷个懒 不放链接了  </p>
<p>Linux用户确保<code>g++</code>已安装即可  </p>
<p>编译运行<kbd>Ctrl</kbd>+<kbd>Alt</kbd>+<kbd>N</kbd><br>注意这个插件用的时候不要有选中的文本<br>否则选中的部分会被写入<code>tempCodeRunnerFile.cpp</code>并被运行<br>这个功能本意大概是为 Python/Javascript 等类似的语言提供最简便的运行体验<br>写 Python 的时候选中运行大概有点用（（（<br>在 C++ 确实没啥用  </p>
<h2 id="调试环境"><a href="#调试环境" class="headerlink" title="调试环境"></a>调试环境</h2><p>左边那栏那个长得像虫子(bug)一样的就是调试菜单<br>请确保安装了 <code>gdb</code>  </p>
<p>在<code>./.vscode/</code>下创建<code>launch.json</code>，填入以下内容：<br>（当然用默认的也可以  </p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 使用 IntelliSense 了解相关属性。 </span></span><br><span class="line">	<span class="comment">// 悬停以查看现有属性的描述。</span></span><br><span class="line">	<span class="comment">// 欲了解更多信息，请访问: https://go.microsoft.com/fwlink/?linkid=830387</span></span><br><span class="line">	<span class="attr">"version"</span>: <span class="string">"0.2.0"</span>,</span><br><span class="line">	<span class="attr">"configurations"</span>: [</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="attr">"name"</span>: <span class="string">"(gdb) 启动"</span>,</span><br><span class="line">			<span class="attr">"type"</span>: <span class="string">"cppdbg"</span>,</span><br><span class="line">			<span class="attr">"request"</span>: <span class="string">"launch"</span>,</span><br><span class="line">			<span class="attr">"program"</span>: <span class="string">"$&#123;fileDirname&#125;\\$&#123;fileBasenameNoExtension&#125;.exe"</span>,</span><br><span class="line">			<span class="attr">"args"</span>: [],</span><br><span class="line">			<span class="attr">"stopAtEntry"</span>: <span class="literal">false</span>,</span><br><span class="line">			<span class="attr">"cwd"</span>: <span class="string">"$&#123;workspaceFolder&#125;"</span>,</span><br><span class="line">			<span class="attr">"environment"</span>: [],</span><br><span class="line">			<span class="attr">"externalConsole"</span>: <span class="literal">true</span>,</span><br><span class="line">			<span class="attr">"MIMode"</span>: <span class="string">"gdb"</span>,</span><br><span class="line">			<span class="attr">"miDebuggerPath"</span>: <span class="string">"/path/to/gdb.exe"</span>,</span><br><span class="line">			<span class="attr">"setupCommands"</span>: [</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="attr">"description"</span>: <span class="string">"为 gdb 启用整齐打印"</span>,</span><br><span class="line">					<span class="attr">"text"</span>: <span class="string">"-enable-pretty-printing"</span>,</span><br><span class="line">					<span class="attr">"ignoreFailures"</span>: <span class="literal">true</span></span><br><span class="line">				&#125;</span><br><span class="line">			],</span><br><span class="line">			<span class="attr">"preLaunchTask"</span>: <span class="string">"g++"</span></span><br><span class="line">		&#125;</span><br><span class="line">	]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（以上代码的<code>miDebuggerPath</code>请替换为自己的<code>gdb</code>路径  </p>
<p>在<code>./.vscode/</code>下创建<code>tasks.json</code>，填入以下内容：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"tasks"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"type"</span>: <span class="string">"shell"</span>,</span><br><span class="line">            <span class="attr">"label"</span>: <span class="string">"g++"</span>,</span><br><span class="line">            <span class="attr">"command"</span>: <span class="string">"/path/to/g++.exe"</span>,</span><br><span class="line">            <span class="attr">"args"</span>: [</span><br><span class="line">                <span class="string">"-g"</span>,</span><br><span class="line">                <span class="string">"$&#123;file&#125;"</span>,</span><br><span class="line">                <span class="string">"-o"</span>,</span><br><span class="line">                <span class="string">"$&#123;fileDirname&#125;\\$&#123;fileBasenameNoExtension&#125;.exe"</span></span><br><span class="line">            ],</span><br><span class="line">            <span class="attr">"options"</span>: &#123;</span><br><span class="line">                <span class="attr">"cwd"</span>: <span class="string">""</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">"version"</span>: <span class="string">"2.0.0"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（以上代码的<code>command</code>替换为自己的<code>g++</code>路径，<code>options.cwd</code>替换为包含<code>g++.exe</code>的文件夹路径  </p>
<p>打开要调试的文件，打开调试菜单<br>点上面的运行图标或按<kbd>F5</kbd><br>即可开始调试<br>不调试仅运行可以按<kbd>Ctrl</kbd>+<kbd>F5</kbd>  </p>
<p>常见的调试操作不再赘述<br>但是这个调试不知道怎么的不能暂停  </p>
<h2 id="一些有用的扩展"><a href="#一些有用的扩展" class="headerlink" title="一些有用的扩展"></a>一些有用的扩展</h2><p>每个扩展的安装就不复读了<br>扩展名就是标题  </p>
<h3 id="Bracket-Pair-Colorizer"><a href="#Bracket-Pair-Colorizer" class="headerlink" title="Bracket Pair Colorizer"></a>Bracket Pair Colorizer</h3><p>给成对的括号上色<br>默认颜色有 <span style="color: Orchid">■</span> #da70d6(Orchid) <span style="color: Gold">■</span>#ffd700(Gold) <span style="color: LightSkyBlue">■</span>#87cefa(LightSkyBlue)<br>在括号匹配出错的时候会使用<span style="color: Red">■</span>#ff0000标出出错的括号  </p>
<h3 id="Comment-Translate"><a href="#Comment-Translate" class="headerlink" title="Comment Translate"></a>Comment Translate</h3><p>使用咕鸽翻译注释<br>挺好使的<br>只不过有的时候比较智障罢了  </p>
<h3 id="TabNine"><a href="#TabNine" class="headerlink" title="TabNine"></a>TabNine</h3><p>强推！<br>神仙人工智能代码补全插件<br>（电脑中低配的放弃吧<br>甚至有根据函数名补全函数体的神仙功能<br>顺便说一下 TabNine 的默认语言服务器是 cquery<br>据说不咋好使<br>而且不好配置<br>所以我们选择更普遍的<code>clangd</code><br>（请确保<code>LLVM</code>已安装<br>开个cpp输入<code>TabNine::config_dir</code>，把打开的网页中的那个路径打开<br>然后  </p>
<p>当然，神仙功能的背后，其占用也是比较神仙的……<br><kbd>Ctrl</kbd>+<kbd>Shift</kbd>+<kbd>Esc</kbd> 打开 TaskMgr ，找到<code>TabNine.exe</code>，看一下内存占用<br>如果要发挥较好的效果，请为 TabNine 留出 2G 以上的空余空间<br>并保证 CPU 运算能力较强<br>（MoveToEx的电脑很辣鸡，所以他没有装 TabNine<br>（因为 TabNine 安装后用的时候甚至要等1至2s才能弹出补全（（（</p>
<h3 id="Live-Share"><a href="#Live-Share" class="headerlink" title="Live Share"></a>Live Share</h3><p>曾经在qbxt晚自习的时候和 @<a href="blog.liuzhe.site">liuzhe</a> 大佬用这个联机敲代码（<br>一个能让多人同时写代码的工具  </p>
<h3 id="Live-Share-Chat"><a href="#Live-Share-Chat" class="headerlink" title="Live Share Chat"></a>Live Share Chat</h3><p>正如其名<br>让 Live Share 支持发送文字消息</p>
<h3 id="Live-Share-Extension-Pack"><a href="#Live-Share-Extension-Pack" class="headerlink" title="Live Share Extension Pack"></a>Live Share Extension Pack</h3><p>MS 出品的 LiveShare 的扩展包的集合<br>（包含音频扩展</p>
<h3 id="Markdown-All-in-One"><a href="#Markdown-All-in-One" class="headerlink" title="Markdown All in One"></a>Markdown All in One</h3><p>写 M↓ 用的<br>不多说  </p>
<h3 id="Markdown-Math"><a href="#Markdown-Math" class="headerlink" title="Markdown Math"></a>Markdown Math</h3><p>也是写 M↓ 用的<br>让 M↓ 能写数学公式<br>但是貌似 Markdown AIO 自带这个功能</p>
<h3 id="Polacode-2019"><a href="#Polacode-2019" class="headerlink" title="Polacode-2019"></a>Polacode-2019</h3><p>生成代码图片<br>使用时 <kbd> Ctrl</kbd> + <kbd> Shift </kbd> + <kbd>P</kbd> 输入 <code>polacode</code> 回车打开窗口，选中要生成的代码即可<br>点下方的看起来像快门的东西即可保存图片  </p>
<h3 id="Remote-WSL"><a href="#Remote-WSL" class="headerlink" title="Remote - WSL"></a>Remote - WSL</h3><p><span style="color: rgb(106, 153, 85)">// 仅限 Windows 10 且安装了 WSL 的用户</span>  </p>
<p>在 WSL 中开启 vscode<br>MS 黑科技  </p>
<h3 id="vscode-icons"><a href="#vscode-icons" class="headerlink" title="vscode-icons"></a>vscode-icons</h3><p>vscode 的图标包  </p>
<blockquote>
<p>我*， 这个什么时候变得这么好看了？  </p>
<p style="text-align: right">--@<a href="blog.liuzhe.site">liuzhe</a></p>  
</blockquote>
<p>（星号请自行脑补  </p>
<h2 id="美化"><a href="#美化" class="headerlink" title="美化"></a>美化</h2><p>其实vscode我感觉不需要美化（（（<br>默认Dark+主题很好看啊  </p>
<p>如果感觉Dark+不好看，扩展搜索框输入<code>@category:themes</code><br>搜出来的都是主题<br>选一个好看的下载换上即可  </p>
<h1 id="稍微进阶的配置"><a href="#稍微进阶的配置" class="headerlink" title="稍微进阶的配置"></a>稍微进阶的配置</h1><h2 id="更改-C-C-扩展配置"><a href="#更改-C-C-扩展配置" class="headerlink" title="更改 C/C++ 扩展配置"></a>更改 C/C++ 扩展配置</h2><p>这个扩展的配置文件位于<code>./.vscode/c_cpp_properties.json</code><br>或者<kbd>Ctrl</kbd> + <kbd>Shift</kbd> + <kbd>P</kbd> 输入 <code>C/C++: Edit Configurations (JSON)</code>也可以（<br>如果想用 UI 的设置，<code>C/C++: Edit Configurations (UI)</code>即可<br>至于解释啥的直接看 UI 设置就好  </p>
<h2 id="用户代码片段"><a href="#用户代码片段" class="headerlink" title="用户代码片段"></a>用户代码片段</h2><p>左下角设置 -&gt; 用户代码片段 -&gt; cpp  </p>
<p>里面的就是编写 C++ 时应用的代码片段，单个片段格式如下：  </p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">"Name": &#123;</span><br><span class="line">	"prefix": "_init",</span><br><span class="line">	"body": [</span><br><span class="line">		"#include &lt;bits/stdc++.h&gt;",</span><br><span class="line">		"",</span><br><span class="line">		"using namespace std;",</span><br><span class="line">		"",</span><br><span class="line">		"int main() &#123;",</span><br><span class="line">		"\t$0",</span><br><span class="line">		"\treturn 0;",</span><br><span class="line">		<span class="string">"&#125;"</span></span><br><span class="line">	]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>开头的<code>Name</code> 替换为这个代码片段的名字<br><code>prefix</code> 的值替换为激活代码片段需要输入的文本<br><code>body</code> 的值替换为代码内容，其每一个元素占一行，可以使用转义字符  </p>
<p>以上边的代码为例，使用这一个代码片段，只需输入<code>_init</code>然后选择添加的代码片段，回车/Tab 即可<br>代码片段还有一些很神奇的光标操作，格式为<code>${id:place_holder}</code>或<code>$id</code>(id&gt;=1)<br>id为0的是最终的光标位置<br>输入代码片段后会移动光标至选中id除0外最小的一个，如果有 place_holder ，其内容将被选中，此时编辑内容<br>按<kbd>Tab</kbd>以切换到下一个id<br>所有id全部过了一遍后，按下<kbd>Tab</kbd>将返回<code>$0</code>位置<br>比如，<code>body</code>值为：  </p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">	<span class="string">"#include &lt;bits/stdc++.h&gt;"</span>,</span><br><span class="line">	<span class="string">""</span>,</span><br><span class="line">	<span class="string">"using namespace std;"</span>,</span><br><span class="line">	<span class="string">""</span>,</span><br><span class="line">	<span class="string">"int main() &#123;"</span></span><br><span class="line">	<span class="string">"\tcout &lt;&lt; \"$&#123;1:MoveToEx is juruo!&#125;\" &lt;&lt; endl;"</span>,</span><br><span class="line">	<span class="string">"\tcout &lt;&lt; \"$&#123;2:MoveToEx is juruo!&#125;\" &lt;&lt; endl;"</span>,</span><br><span class="line">	<span class="string">"$0"</span>,</span><br><span class="line">	<span class="string">"&#125;"</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>输入指定文本触发代码片段 -&gt; 光标移至第一个<code>MoveToEx is juruo!</code>并选中 -&gt; （编辑内容） -&gt; <kbd>Tab</kbd> -&gt; 光标移至第二个<code>MoveToEx is juruo!</code>并选中 -&gt; （编辑内容） -&gt; <kbd>Tab</kbd> -&gt; 光标移至<code>$0</code>处  </p>
<p>（懒得录gif了  </p>
<h2 id="键盘快捷方式"><a href="#键盘快捷方式" class="headerlink" title="键盘快捷方式"></a>键盘快捷方式</h2><p>vscode 的比较神仙的功能<br>对于MoveToEx这个OIer, 常用的有：  </p>
<ul>
<li><kbd>Ctrl</kbd>+<kbd>Backspace</kbd>: 删除光标左侧的一个 Word（<code>MoveToEx,[{:,isjuruo</code>中的Word有<code>MoveToEx</code>,<code>,[{:</code>,<code>isjuruo</code></li>
<li><kbd>Ctrl</kbd>+<kbd>Delete</kbd>: 删除光标右侧的一个 Word</li>
<li><kbd>Ctrl</kbd>+<kbd>K</kbd> <kbd>M</kbd>: 切换语言模式</li>
<li><kbd>Ctrl</kbd>+<kbd>K</kbd> <kbd>Ctrl</kbd>+<kbd>T</kbd>: 切换主题</li>
<li><kbd>Ctrl</kbd>+<kbd>`~</kbd>: 显示/隐藏终端</li>
<li><kbd>Ctrl</kbd>+<kbd>[{</kbd>/<kbd>]}</kbd>: 在当前行左侧 添加/删除 一个Tab缩进</li>
<li><kbd>Ctrl</kbd>+<kbd>|</kbd>: 拆分编辑器</li>
<li><kbd>Ctrl</kbd>+<kbd>=+</kbd>/<kbd>-_</kbd>: 放大/缩小</li>
<li><kbd>Ctrl</kbd>+<kbd>B</kbd>: (写M↓)加粗/(其他文件)打开/隐藏侧边栏</li>
<li><kbd>Ctrl</kbd>+(<kbd>Shift</kbd>)+<kbd>Tab</kbd>: 打开一个标签页列表，越晚切出排的越上，连续按<kbd>Tab</kbd>可以连续切换，松开<kbd>Ctrl</kbd>使切换生效</li>
<li><kbd>Ctrl</kbd>+<kbd>D</kbd>: 若（当前已有选中内容）{ 将下一个查找结果选中；} 否则 { 选中光标所在 Word } （这个神仙功能用好了非常加效率</li>
<li><kbd>Ctrl</kbd>+<kbd>Shift</kbd>+<kbd>T</kbd>: 打开最近关闭的文件</li>
<li><kbd>Ctrl</kbd>+<kbd>Space</kbd>: 打开代码补全提示</li>
<li><kbd>Shift</kbd>+<kbd>Delete</kbd>: 剪切当前行</li>
<li><kbd>Shift</kbd>+<kbd>↑</kbd>/<kbd>↓</kbd>: 当前行复制到上/下一行</li>
<li><kbd>Shift</kbd>+<kbd>Alt</kbd>+<kbd>F</kbd>: 格式化代码</li>
<li>……</li>
</ul>
<p>一般也没必要改这些东西<br>不习惯的话多用几遍就习惯了（<br>如果真的要改的话 <kbd>Ctrl</kbd>+<kbd>K</kbd> <kbd>Ctrl</kbd>+<kbd>S</kbd>修改即可<br>如果愿意可以去下载 vim 或者 sublime 之类的键映射  </p>
<h2 id="代码格式化"><a href="#代码格式化" class="headerlink" title="代码格式化"></a>代码格式化</h2><p>先安装 LLVM （<br>然后去自己找一个适合自己的 <code>.clang-format</code> 文件<br>如果懒得去找，这是我的：  </p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">Language:</span>        <span class="string">Cpp</span></span><br><span class="line"><span class="attr">BasedOnStyle:</span> <span class="string">LLVM</span></span><br><span class="line"><span class="attr">AccessModifierOffset:</span> <span class="number">-2</span></span><br><span class="line"><span class="attr">AlignAfterOpenBracket:</span> <span class="string">Align</span></span><br><span class="line"><span class="attr">AlignConsecutiveAssignments:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">AlignConsecutiveDeclarations:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">AlignEscapedNewlines:</span> <span class="string">Right</span></span><br><span class="line"><span class="attr">AlignOperands:</span>   <span class="literal">true</span></span><br><span class="line"><span class="attr">AlignTrailingComments:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">AllowAllParametersOfDeclarationOnNextLine:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">AllowShortBlocksOnASingleLine:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">AllowShortCaseLabelsOnASingleLine:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">AllowShortFunctionsOnASingleLine:</span> <span class="string">All</span></span><br><span class="line"><span class="attr">AllowShortIfStatementsOnASingleLine:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">AllowShortLoopsOnASingleLine:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">AlwaysBreakAfterDefinitionReturnType:</span> <span class="string">None</span></span><br><span class="line"><span class="attr">AlwaysBreakAfterReturnType:</span> <span class="string">None</span></span><br><span class="line"><span class="attr">AlwaysBreakBeforeMultilineStrings:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">AlwaysBreakTemplateDeclarations:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">BinPackArguments:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">BinPackParameters:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">BraceWrapping:</span>   </span><br><span class="line">  <span class="attr">AfterClass:</span>      <span class="literal">false</span></span><br><span class="line">  <span class="attr">AfterControlStatement:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">AfterEnum:</span>       <span class="literal">false</span></span><br><span class="line">  <span class="attr">AfterFunction:</span>   <span class="literal">false</span></span><br><span class="line">  <span class="attr">AfterNamespace:</span>  <span class="literal">false</span></span><br><span class="line">  <span class="attr">AfterObjCDeclaration:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">AfterStruct:</span>     <span class="literal">false</span></span><br><span class="line">  <span class="attr">AfterUnion:</span>      <span class="literal">false</span></span><br><span class="line">  <span class="attr">AfterExternBlock:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">BeforeCatch:</span>     <span class="literal">false</span></span><br><span class="line">  <span class="attr">BeforeElse:</span>      <span class="literal">false</span></span><br><span class="line">  <span class="attr">IndentBraces:</span>    <span class="literal">false</span></span><br><span class="line">  <span class="attr">SplitEmptyFunction:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">SplitEmptyRecord:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">SplitEmptyNamespace:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">BreakBeforeBinaryOperators:</span> <span class="string">None</span></span><br><span class="line"><span class="attr">BreakBeforeBraces:</span> <span class="string">Custom</span></span><br><span class="line"><span class="attr">BreakBeforeInheritanceComma:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">BreakBeforeTernaryOperators:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">BreakConstructorInitializersBeforeComma:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">BreakConstructorInitializers:</span> <span class="string">BeforeColon</span></span><br><span class="line"><span class="attr">BreakAfterJavaFieldAnnotations:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">BreakStringLiterals:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">ColumnLimit:</span>     <span class="number">0</span></span><br><span class="line"><span class="attr">CommentPragmas:</span>  <span class="string">'^ IWYU pragma:'</span></span><br><span class="line"><span class="attr">CompactNamespaces:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">ConstructorInitializerAllOnOneLineOrOnePerLine:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">ConstructorInitializerIndentWidth:</span> <span class="number">4</span></span><br><span class="line"><span class="attr">ContinuationIndentWidth:</span> <span class="number">4</span></span><br><span class="line"><span class="attr">Cpp11BracedListStyle:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">DerivePointerAlignment:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">DisableFormat:</span>   <span class="literal">false</span></span><br><span class="line"><span class="attr">ExperimentalAutoDetectBinPacking:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">FixNamespaceComments:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">ForEachMacros:</span>   </span><br><span class="line">  <span class="bullet">-</span> <span class="string">foreach</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">Q_FOREACH</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">BOOST_FOREACH</span></span><br><span class="line"><span class="attr">IncludeBlocks:</span>   <span class="string">Preserve</span></span><br><span class="line"><span class="attr">IncludeCategories:</span> </span><br><span class="line">  <span class="bullet">-</span> <span class="attr">Regex:</span>           <span class="string">'^"(llvm|llvm-c|clang|clang-c)/'</span></span><br><span class="line">    <span class="attr">Priority:</span>        <span class="number">2</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">Regex:</span>           <span class="string">'^(&lt;|"(gtest|gmock|isl|json)/)'</span></span><br><span class="line">    <span class="attr">Priority:</span>        <span class="number">3</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">Regex:</span>           <span class="string">'.*'</span></span><br><span class="line">    <span class="attr">Priority:</span>        <span class="number">1</span></span><br><span class="line"><span class="attr">IncludeIsMainRegex:</span> <span class="string">'(Test)?$'</span></span><br><span class="line"><span class="attr">IndentCaseLabels:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">IndentPPDirectives:</span> <span class="string">None</span></span><br><span class="line"><span class="attr">IndentWidth:</span>     <span class="number">4</span></span><br><span class="line"><span class="attr">IndentWrappedFunctionNames:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">JavaScriptQuotes:</span> <span class="string">Leave</span></span><br><span class="line"><span class="attr">JavaScriptWrapImports:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">KeepEmptyLinesAtTheStartOfBlocks:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">MacroBlockBegin:</span> <span class="string">''</span></span><br><span class="line"><span class="attr">MacroBlockEnd:</span>   <span class="string">''</span></span><br><span class="line"><span class="attr">MaxEmptyLinesToKeep:</span> <span class="number">1</span></span><br><span class="line"><span class="attr">NamespaceIndentation:</span> <span class="string">None</span></span><br><span class="line"><span class="attr">ObjCBlockIndentWidth:</span> <span class="number">2</span></span><br><span class="line"><span class="attr">ObjCSpaceAfterProperty:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">ObjCSpaceBeforeProtocolList:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">PenaltyBreakAssignment:</span> <span class="number">2</span></span><br><span class="line"><span class="attr">PenaltyBreakBeforeFirstCallParameter:</span> <span class="number">19</span></span><br><span class="line"><span class="attr">PenaltyBreakComment:</span> <span class="number">300</span></span><br><span class="line"><span class="attr">PenaltyBreakFirstLessLess:</span> <span class="number">120</span></span><br><span class="line"><span class="attr">PenaltyBreakString:</span> <span class="number">1000</span></span><br><span class="line"><span class="attr">PenaltyExcessCharacter:</span> <span class="number">1000000</span></span><br><span class="line"><span class="attr">PenaltyReturnTypeOnItsOwnLine:</span> <span class="number">60</span></span><br><span class="line"><span class="attr">PointerAlignment:</span> <span class="string">Right</span></span><br><span class="line"><span class="attr">ReflowComments:</span>  <span class="literal">true</span></span><br><span class="line"><span class="attr">SortIncludes:</span>    <span class="literal">true</span></span><br><span class="line"><span class="attr">SortUsingDeclarations:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">SpaceAfterCStyleCast:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">SpaceAfterTemplateKeyword:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">SpaceBeforeAssignmentOperators:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">SpaceBeforeParens:</span> <span class="string">ControlStatements</span></span><br><span class="line"><span class="attr">Standard:</span>        <span class="string">Cpp11</span></span><br><span class="line"><span class="attr">TabWidth:</span>        <span class="number">4</span></span><br><span class="line"><span class="attr">UseTab:</span>          <span class="string">Always</span></span><br><span class="line"><span class="string">...</span></span><br></pre></td></tr></table></figure>
<p>将以上内容复制到当前文件夹的 <code>.clang-format</code> 文件中<br>在代码中<kbd>Shift</kbd>+<kbd>Alt</kbd>+<kbd>F</kbd>即可  </p>
<h2 id="LaTeX-环境配置"><a href="#LaTeX-环境配置" class="headerlink" title="LaTeX 环境配置"></a>LaTeX 环境配置</h2><p>不写$\LaTeX$的可以跳过本节  </p>
<p>首先安装<a href="https://miktex.org/" target="_blank" rel="noopener">MikTeX</a>和<a href="http://strawberryperl.com/" target="_blank" rel="noopener">Perl</a><br>装好之后 开始 -&gt; MikTeX x.x -&gt; MikTeX Console -&gt; 右边的终端图标<br>输入<code>mpm --install=latexmk</code>，回车<br>在vscode中安装<code>LaTeX Workshop</code><br>装好之后就可以创建<code>.tex</code>文件了<br>每次保存自动生成<code>.pdf</code>文件  </p>
<h1 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h1><p>不建议使用 Custom CSS Loader 之类修改 vscode 文件的扩展<br>会被 vscode 自带的 checksum 检测出来<br>然后就会在标题栏显示一个<code>[不受支持]</code><br>有个插件 vscode-fix-checksums 能删掉这个<code>[不受支持]</code><br>但是总感觉不大好（<br>目前我见过的所有背景和自定义CSS之类的扩展都是通过修改 vscode 实现的<br>所以不建议使用<br>（vscode本来也挺好看的  </p>
<p>（待续，争取这两天填完坑<br>（如果填不完坑……咕咕咕</p>
]]></content>
      <categories>
        <category>杂项</category>
        <category>VSC</category>
      </categories>
      <tags>
        <tag>VSC</tag>
        <tag>Code Editor</tag>
      </tags>
  </entry>
  <entry>
    <title>毒瘤二进制</title>
    <url>/posts/586658d6dc74ab44/</url>
    <content><![CDATA[<p><span style="font-size: 48px">咕咕咕</span><br>咕了挺长时间了……甚至一度被PayPhone-X神仙怀疑换域名了……  </p>
<p>那么今天就更一期<br>依旧是关于毒瘤</p>
<a id="more"></a> 
<p>二进制的概念及转换等相信各位非常熟悉<br>在此不再涉及  </p>
<p>本文主要涉及一些知道的人相对较少的东西  </p>
<p>本文写的比较仓促<br>有的东西想加但是来不及加<br>但是再不更新恐怕就没时间更了<br>所以有些地方涉及的比较浅<br>敬请谅解</p>
<h1 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h1><h2 id="按位与-amp"><a href="#按位与-amp" class="headerlink" title="按位与 (&amp;)"></a>按位与 (&amp;)</h2><p>都为1时则为1，否则为0  </p>
<p>即  </p>
<p>$0\ \&amp;\ 0 = 0$<br>$0\ \&amp;\ 1 = 0$<br>$1\ \&amp;\ 0 = 0$<br>$1\ \&amp;\ 1 = 1$  </p>
<h2 id="按位或"><a href="#按位或" class="headerlink" title="按位或 (|)"></a>按位或 (|)</h2><p>两个数有一个为1时即为1，否则为0  </p>
<p>即  </p>
<p>$0\ |\ 0 = 0$<br>$0\ |\ 1 = 1$<br>$1\ |\ 0 = 1$<br>$1\ |\ 1 = 1$  </p>
<h2 id="按位取反"><a href="#按位取反" class="headerlink" title="按位取反 (~)"></a>按位取反 (~)</h2><p>对一个数的每一位取反  </p>
<p>$\text{~}0=1$<br>$\text{~}1=0$  </p>
<h2 id="异或"><a href="#异或" class="headerlink" title="异或 (^)"></a>异或 (^)</h2><p>两个数相同则为0，否则为1<br>又称不进位加法</p>
<p>即</p>
<p>$0 \text{^} 0 = 0$<br>$0 \text{^} 1 = 1$<br>$1 \text{^} 0 = 1$<br>$1 \text{^} 1 = 0$</p>
<h1 id="毒瘤"><a href="#毒瘤" class="headerlink" title="毒瘤"></a>毒瘤</h1><p><del>MoveToEx最爱的毒瘤时间</del></p>
<h2 id="位运算加法"><a href="#位运算加法" class="headerlink" title="位运算加法"></a>位运算加法</h2><p>既然异或被称为不进位加法<br>那么不进位加法处理一下进位不就是加法了吗  </p>
<p>若$a$和$b$的二进制没有重合部分(不用处理进位，即<code>a &amp; b == 0</code>), 那么<code>a + b == a | b</code><br>否则，令<code>a = a ^ b</code>, <code>b = (a &amp; b) &lt;&lt; 1</code>，递归  </p>
<p>手动模拟一遍，  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  0011 0011</span><br><span class="line">+ 0101 1101</span><br><span class="line">-------------</span><br><span class="line">&#x3D; 0110 1110</span><br><span class="line">+ 0010 0010</span><br><span class="line">-------------</span><br><span class="line">&#x3D; 0100 1100</span><br><span class="line">+ 0100 0100</span><br><span class="line">-------------</span><br><span class="line">&#x3D; 0000 1000</span><br><span class="line">+ 1000 1000</span><br><span class="line">-------------</span><br><span class="line">&#x3D; 0000 0000</span><br><span class="line">+ 1001 0000</span><br><span class="line">-------------</span><br><span class="line">&#x3D; 1001 0000</span><br></pre></td></tr></table></figure>
<p>不是我不想用MathJax啊 这玩意渲染出来不正常啊</p>
<p>以上方法对负数同样适用  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (!(a &amp; b)) ? (a | b) : (vac(a ^ b, (a &amp; b) &lt;&lt; <span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="0-1-0-2"><a href="#0-1-0-2" class="headerlink" title="0.1 + 0.2"></a>0.1 + 0.2</h2><p>相信经常刷知乎的人一定刷到过这个东西  </p>
<p>显然$0.1+0.2=0.3$<br>但是把这个放到C++里跑一遍  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; fixed &lt;&lt; setprecision(<span class="number">17</span>) &lt;&lt; (<span class="number">0.1</span> + <span class="number">0.2</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0.30000000000000004</span><br></pre></td></tr></table></figure>
<p>???</p>
<p>这种问题同样存在于其他语言中  </p>
<p>C:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%.17f\n"</span>, <span class="number">0.1</span> + <span class="number">0.2</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0.30000000000000004</span><br></pre></td></tr></table></figure>
<p>Python3:</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">.1</span>+<span class="number">.2</span></span><br><span class="line"><span class="number">0.30000000000000004</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>_</span><br></pre></td></tr></table></figure>
<p>NodeJS:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&gt; <span class="number">0.1</span>+<span class="number">0.2</span></span><br><span class="line"><span class="number">0.30000000000000004</span></span><br><span class="line">&gt; <span class="number">0.1</span>+<span class="number">0.2</span> == <span class="number">0.3</span></span><br><span class="line"><span class="literal">false</span></span><br><span class="line">&gt; _</span><br></pre></td></tr></table></figure>
<p>ZSH:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"> ~ &gt; <span class="built_in">echo</span> <span class="string">"<span class="variable">$((.1+.2)</span>)"</span></span><br><span class="line">0.30000000000000004</span><br></pre></td></tr></table></figure>
<p>人间迷惑行为大赏啊</p>
<p>这是为什么呢  </p>
<p>因为 C++, Python, Javascript 等这些语言都使用 IEEE 二进制浮点数标准  </p>
<p>因为这个博主懒，就拿单精度浮点数讲吧</p>
<h3 id="IEEE"><a href="#IEEE" class="headerlink" title="IEEE"></a>IEEE</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sign exponent           fraction</span><br><span class="line"> ↓  ┌───┴──┐  ┌───────────┴───────────┐</span><br><span class="line">[0][00000000][0000000 00000000 00000000]</span><br><span class="line"> ↑         ↑                          ↑</span><br><span class="line">e+f        f                          0</span><br></pre></td></tr></table></figure>
<p><del>MoveToEx擅长于把代码块玩出花</del>  </p>
<p>下方的数字代表该位为内存地址中从低位（最右）到高位（最左）是第几位  </p>
<p>$e$为$\text{exponent}$的二进制位数<br>$f$为$\text{fraction}$的二进制位数  </p>
<p>对于单精度浮点数，$e=8,f=23$<br>对于双精度浮点数，$e=11,f=52$</p>
<p>一个浮点数，其值可以表示如下：</p>
<p>$\text{Value}=\text{sign} \times \text{exponent} \times \text{fraction}$  </p>
<p>$\text{sign}$: 符号位<br>$\text{exponent}$: 指数偏移值，又称阶码<br>$\text{fraction}$: 分数值，</p>
<h4 id="符号位"><a href="#符号位" class="headerlink" title="符号位"></a>符号位</h4><p>符号位即内存中最高位<br>$0$表示正，$\text{sign}=+1$<br>$1$表示负，$\text{sign}=-1$  </p>
<h4 id="指数偏移值"><a href="#指数偏移值" class="headerlink" title="指数偏移值"></a>指数偏移值</h4><p>第2至9位(第二块)，指数偏移值<br>等于指数的实际值加上一个固定的值<br>这个值应当能够使其能够表示的最小的数表示为所有位全为$0$的数，能表示的最大的数表示为所有位全为$1$的数<br>IEEE 754 规定该值为$2^{e-1}-1$<br>对于单精度浮点数，该值为$2^7-1=127$  </p>
<p>但是，对于单精度浮点数，这个数的实际取值范围是$[-126,127]$，$-127,128$被当作特殊值处理</p>
<p>如，若指数实际为$-7$，会被编码为$(-7)+127=120=01111000_2$<br>若某浮点数指数部分编码为$120$，那么其指数实际应为$120-127=-7$</p>
<p>若内存中的编码为$\text{exp}$，  那么<br>$\displaystyle \text{exponent}=2^{\text{exp}-(2^{e-1}-1)}$  </p>
<h4 id="分数值"><a href="#分数值" class="headerlink" title="分数值"></a>分数值</h4><p>分数值比指数偏移值好理解的多  </p>
<p>回想二进制整数，可以写成如下形式：<br>$10101=1\times2^4+1\times2^2+1\times2^0$  </p>
<p>分数值和这个有些类似<br>只不过是把指数换成了负的<br>但是顺序换成了从右到左</p>
<p>$\displaystyle .11001=1\times {1 \over 2^1}+1\times {1 \over 2^2} + 1 \times {1 \over 2^5 }$  </p>
<p><strong>但是</strong>，虽然$f=23$，但实际有效数位是$24$位<br>因为还有一位$1$是一定存在的<br>所以结果加上1  </p>
<p>即  </p>
<p>设按照上面的规则处理出来的数为 $\text{frac}$<br>那么<br>$\text{fraction}=1+\text{frac}$  </p>
<h4 id="规约形式"><a href="#规约形式" class="headerlink" title="规约形式"></a>规约形式</h4><p>若一个浮点数的指数部分满足$0 \lt \text{exponent} \leq 2^e-2$，且这个浮点数的分数$\text{fraction}$部分最高有效位为1<br>那么这个浮点数称为规约形式的浮点数，规约意为可以用唯一确定的浮点形式表示一个值  </p>
<p>例如，单精度规约形式浮点数该部分的值域为 $00000001_2$到$11111110_2$，分数部分值域为$000\dots000$(23 bit)到$111\dots111$</p>
<h4 id="非规约形式"><a href="#非规约形式" class="headerlink" title="非规约形式"></a>非规约形式</h4><p>如果一个浮点数指数部分编码为$0$，且分数部分非0，那么这个浮点数被称为非规约形式的浮点数，一般在某个数相当接近0时才会使用该种形式  </p>
<p>IEEE 754标准规定：非规约形式的浮点数的指数偏移值比规约形式的浮点数的指数偏移值小1  </p>
<h4 id="特殊值"><a href="#特殊值" class="headerlink" title="特殊值"></a>特殊值</h4><p>如果指数为$0$且小数部分为$0$，那么这个数为$\pm0$(具体取决于符号位)<br>如果指数为$2^e-1$且小数部分为$0$，那么这个数为$\pm \infty$(具体取决于符号位)<br>如果指数为$2^e-1$且小数部分非$0$，那么这个数为$\pm \text{NaN}$  </p>
<h4 id="例"><a href="#例" class="headerlink" title="例"></a>例</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sign exponent           fraction</span><br><span class="line"> ↓  ┌───┴──┐  ┌───────────┴───────────┐</span><br><span class="line">[0][01111100][0100000 00000000 00000000]</span><br><span class="line"> ↑         ↑                          ↑</span><br><span class="line">e+f        f                          0</span><br></pre></td></tr></table></figure>
<p>$\text{sign}=+1$<br>$\text{exponent}=124-127=-3$<br>$\displaystyle \text{fraction}=1+{1 \over 2^2}=1.25$<br>$\displaystyle \text{value} = (+1) \times 2^{-3} \times 1.25=0.15625$  </p>
<h3 id="回到我们的问题"><a href="#回到我们的问题" class="headerlink" title="回到我们的问题"></a>回到我们的问题</h3><p>我们把$0.1$和$0.2$转成二进制发现这俩都是无限不循环小数，<br><code>double</code>并不能存<br>所以只能根据规则(舍入到最接近的值，一样接近则取其中的偶数(二进制中以0结尾的一个))找个近似值<br>然后就多出来那一个4</p>
<p>$0.1_{10}=0\ 01111111011\ 1001100110011001100110011001100110011001100110011010_2$  </p>
<p>$0.2_{10}=0\ 01111111100\ 1001100110011001100110011001100110011001100110011010_2$  </p>
<p>加起来就得到了$0.30000000000000004$  </p>
<h2 id="0"><a href="#0" class="headerlink" title="-0"></a>-0</h2><p>像我们之前所说的，如果一个浮点数除符号位以外全是0，那么这个浮点数就是$-0$<br>所以，将一个全$0$的浮点数的最高位设为$1$，即可得到$-0$<br>在运算中，$-0=0$  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">double</span> f = <span class="number">0</span>;</span><br><span class="line">*(<span class="keyword">long</span> <span class="keyword">long</span>*)&amp;f |= ((<span class="keyword">long</span> <span class="keyword">long</span>)<span class="number">1</span> &lt;&lt; <span class="number">63</span>);</span><br></pre></td></tr></table></figure>
<h2 id="NaN"><a href="#NaN" class="headerlink" title="NaN"></a>NaN</h2><p>Not a Number<br>玄学至极的东西  </p>
<p>前面我们讲了，$\pm \text{NaN}$是一个满足以下条件的浮点数:  </p>
<ul>
<li>指数部分为$2^e-1$  </li>
<li>小数部分非$0$  </li>
</ul>
<p>那么二进制下，这几个数都是<code>-NaN</code>:<br>$1\ 11111111111\ 0000000000000000000000000000000000000000000000000001$<br>$1\ 11111111111\ 0000000000000000000000000000000000000000000000000011$<br>$1\ 11111111111\ 0000000000000000000000000000000001111111110011111111$  </p>
<h3 id="获取NaN"><a href="#获取NaN" class="headerlink" title="获取NaN"></a>获取NaN</h3><p>想要获取<code>NaN</code>，请使用指针或共用体(共同占用同一块内存的几个变量)  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">getNaN</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">double</span> ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> *p = (<span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span>*)&amp;ans;</span><br><span class="line">	*p |= ((<span class="keyword">long</span> <span class="keyword">long</span>) <span class="number">0x7ff</span> &lt;&lt; <span class="number">52</span>);</span><br><span class="line">	*p |= <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">getNaNWithUnion</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">union</span> &#123; <span class="keyword">double</span> f; <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> i; &#125; u;</span><br><span class="line">	u.i |= ((<span class="keyword">long</span> <span class="keyword">long</span>) <span class="number">0x7ff</span> &lt;&lt; <span class="number">52</span>);</span><br><span class="line">	u.i |= <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span> u.f;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>欲获取<code>-NaN</code>，请使用<code>-getNaN()</code>  </p>
<h3 id="毒瘤性质"><a href="#毒瘤性质" class="headerlink" title="毒瘤性质"></a>毒瘤性质</h3><p>$\text{NaN} \not = \text{NaN}$<br>$-\text{NaN} \not = 0 - \text{NaN}$($-0$同样)<br>所有数字加上$\text{NaN}$都是$\text{NaN}$<br>但是不等于$\text{NaN}$</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[cling]$ getNaN() != getNaN()</span><br><span class="line">(bool) <span class="literal">true</span></span><br><span class="line">[cling]$ -getNaN()</span><br><span class="line">(double) -nan</span><br><span class="line">[cling]$ 0 - getNaN()</span><br><span class="line">(double) nan</span><br></pre></td></tr></table></figure>
<h2 id="∞"><a href="#∞" class="headerlink" title="∞"></a>∞</h2><p>和$\text{NaN}$类似  </p>
<h3 id="获取∞"><a href="#获取∞" class="headerlink" title="获取∞"></a>获取∞</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">getInf</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">double</span> ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span> *p = (<span class="keyword">long</span> <span class="keyword">long</span>*)&amp;ans;</span><br><span class="line">	*p |= ((<span class="keyword">long</span> <span class="keyword">long</span>) <span class="number">0x7ff</span> &lt;&lt; <span class="number">52</span>);</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>欲获取$-\infty$，请使用<code>-getInf()</code>  </p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://zh.wikipedia.org/wiki/IEEE_754" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/IEEE_754</a><br><a href="https://zh.wikipedia.org/wiki/%E5%96%AE%E7%B2%BE%E5%BA%A6%E6%B5%AE%E9%BB%9E%E6%95%B8" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/%E5%96%AE%E7%B2%BE%E5%BA%A6%E6%B5%AE%E9%BB%9E%E6%95%B8</a><br><a href="https://zh.wikipedia.org/wiki/%E7%A7%BB%E7%A0%81" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/%E7%A7%BB%E7%A0%81</a>  </p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Manjaro折腾记</title>
    <url>/posts/dd22d31e7d6f2b88/</url>
    <content><![CDATA[<p>本菜货复活了（雾<br>前段时间因为中考，导致LYOI二队的大多数成员博客都半死不活了<br>当然也包括我的  </p>
<p>扯回正题<br>最近在折腾Manjaro<br>然后自闭了<br>这篇文章主要记录下自己踩的坑<br>省的以后再重装又得费事（雾</p>
<a id="more"></a>
<p>重装了大概三四次<br>第一次是手贱改了HOME目录下的目录名还没改配置文件，登陆界面卡住进不去了<br>第二次是语言选成英文结果换中文还提示更新系统，懒得折腾<br>第三次说来话长<br>因为要用VSCode，所以装了个electron，然后发现有个<code>libicu***.so.64</code>文件找不到<br>然后直接上<a href="https://archive.archlinux.org" target="_blank" rel="noopener"><code>archive.archlinux.org</code></a>下了个icu-64在根目录解压了<br><code>code</code>也能用了<br>但是软件包更新的时候提示错误，说是在目录下找到了那几个文件，所以无法更新（鬼畜设定<br>于是就想着删那几个文件<br>本来应该是<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">(/usr/bin) mv ./*.64 ~/Tmp/</span><br></pre></td></tr></table></figure><br>不慎手滑，<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">(/usr/bin) mv ./* ~/Tmp/</span><br></pre></td></tr></table></figure><br>遂卒</p>
<h1 id="制作安装盘"><a href="#制作安装盘" class="headerlink" title="制作安装盘"></a>制作安装盘</h1><p><strong>不要用Ultra ISO</strong><br>用Rufus，选DD模式<br>其他的按照默认来就好   </p>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>进启动界面<br>用方向键把焦点移到<code>lang=en_US</code>上，按回车，找到最后的<code>zh_CN</code>，按2次回车<br><code>driver</code>选<code>nonfree</code>(闭源硬件驱动)更好<br>移到<code>Boot</code>，回车   </p>
<p>进系统后，把那个向导关上，联网，单击左上角的<code>Install Manjaro</code>，选好语言，等它大概2分钟，就能安装了<br>选项啥的自己看着来就好<br>反正我懒得去折腾分区啥的就直接全装一个空闲分区了也没见啥问题</p>
<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><h2 id="双系统时间不同步"><a href="#双系统时间不同步" class="headerlink" title="双系统时间不同步"></a>双系统时间不同步</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo timedatectl <span class="built_in">set</span>-local-rtc 1</span><br></pre></td></tr></table></figure>
<p>重启到Windows，把时间改回去   </p>
<h2 id="中文输入法"><a href="#中文输入法" class="headerlink" title="中文输入法"></a>中文输入法</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo pacman -S fcitx fcitx-im fcitx-googlepinyin fcitx-configtool kcm-fcitx fcitx-libpinyin</span><br></pre></td></tr></table></figure>
<p>主目录下新建<code>.xprofile</code>，输入以下内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export GTK2_RC_FILES&#x3D;&quot;$HOME&#x2F;.gtkrc-2.0&quot;</span><br><span class="line">export LC_CTYPE&#x3D;zh_CN.UTF-8</span><br><span class="line">export XMODIFIERS&#x3D;@im&#x3D;fcitx</span><br><span class="line">export GTK_IM_MODULE&#x3D;fcitx</span><br><span class="line">export QT_IM_MODULE&#x3D;fcitx</span><br></pre></td></tr></table></figure>
<p>重启即可</p>
<p>看到网上有的人用<code>ibus</code>，我试过，装都装不了，与依赖项有冲突</p>
<h2 id="更换源"><a href="#更换源" class="headerlink" title="更换源"></a>更换源</h2><p>换源后可以提升下载速度   </p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo pacman-mirrors -i -c China -m rank</span><br></pre></td></tr></table></figure>
<p>然后会弹出对话框，选一个喜欢的源就好<br>我选的是<a href="https://mirrors.tuna.tsinghua.edu.cn" target="_blank" rel="noopener">TUNA</a>   </p>
<p>然后更新包列表   </p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo pacman -Sy</span><br></pre></td></tr></table></figure>
<h2 id="electron缺失库"><a href="#electron缺失库" class="headerlink" title="electron缺失库"></a>electron缺失库</h2><p>其实就是包太旧了<br>更新就好</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo pacman -Su</span><br></pre></td></tr></table></figure>
<h2 id="VIM缺失GLIBC"><a href="#VIM缺失GLIBC" class="headerlink" title="VIM缺失GLIBC"></a>VIM缺失GLIBC</h2><p>同上</p>
<h2 id="重命名主目录"><a href="#重命名主目录" class="headerlink" title="重命名主目录"></a>重命名主目录</h2><p>主目录里的文件夹都是中文<br>但是终端输中文很不方便   </p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo pacman -S xdg-user-dirs-gtk</span><br><span class="line"><span class="built_in">export</span> LANG=en_US</span><br><span class="line">xdg-user-dirs-gtk-update</span><br><span class="line"><span class="comment"># 有对话框提示更改，更新即可</span></span><br><span class="line"><span class="built_in">export</span> LANG=zh_CN.UTF-8</span><br></pre></td></tr></table></figure>
<p>桌面文件夹需要重启后自行删除   </p>
<h1 id="常用软件"><a href="#常用软件" class="headerlink" title="常用软件"></a>常用软件</h1><h2 id="code"><a href="#code" class="headerlink" title="code"></a>code</h2><p>VSCode，不多说</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo pacman -S code</span><br></pre></td></tr></table></figure>
<h2 id="uget"><a href="#uget" class="headerlink" title="uget"></a>uget</h2><p>神仙下载工具，支持aria2插件</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo pacman -S uget</span><br></pre></td></tr></table></figure>
<h2 id="aria2"><a href="#aria2" class="headerlink" title="aria2"></a>aria2</h2><p>下载工具uget的插件</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo pacman -S aria2</span><br></pre></td></tr></table></figure>
<p>然后打开uget，在设置里切换到aria2</p>
<h2 id="oh-my-zsh"><a href="#oh-my-zsh" class="headerlink" title="oh-my-zsh"></a>oh-my-zsh</h2><h3 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sh -c <span class="string">"<span class="variable">$(wget https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh -O -)</span>"</span></span><br></pre></td></tr></table></figure>
<p>等到出现<code>password:</code>或<code>密码：</code>时输入当前用户的密码   </p>
<h3 id="主题"><a href="#主题" class="headerlink" title="主题"></a>主题</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">vim ~/.zshrc</span><br></pre></td></tr></table></figure>
<p>把<code>ZSH_THEME=</code>后面的字符串换成你喜欢的主题，记得加引号<br>我用的是<code>agnoster</code>   </p>
<h3 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h3><p>以语法高亮插件为例</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/zsh-users/zsh-syntax-highlighting.git <span class="variable">$&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;</span>/plugins/zsh-syntax-highlighting</span><br></pre></td></tr></table></figure>
<p>打开<code>~/.zshrc</code><br>找到</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">plugins&#x3D;(git)</span><br></pre></td></tr></table></figure>
<p>格式化，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">plugins&#x3D;(</span><br><span class="line">    git</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>再添加插件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">plugins&#x3D;(</span><br><span class="line">    git</span><br><span class="line">    zsh-syntax-highlighting</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>或者，不换行，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">plugins&#x3D;(git zsh-syntax-highlighting)</span><br></pre></td></tr></table></figure>
<h2 id="deepin-wine-tim"><a href="#deepin-wine-tim" class="headerlink" title="deepin-wine-tim"></a>deepin-wine-tim</h2><p>[2020/02/06] Upd: QQ for Linux 出了 有Arch的 想用的 <a href="https://im.qq.com/linuxqq/download.html" target="_blank" rel="noopener">戳我</a>  </p>
<p>TIM本没有原生Linux版本（摔<br>结果有神仙把Deepin上的Wine TIM给移植过去了   </p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo pacman -S yaourt</span><br><span class="line">yaourt -S deepin-wine-tim</span><br></pre></td></tr></table></figure>
<p>安装后可以在程序列表找到Wine TIM，点开即可按照Windows的方式安装，安装完成后程序列表中的Wine TIM就是TIM的入口。  </p>
]]></content>
      <categories>
        <category>Linux</category>
        <category>Manjaro</category>
      </categories>
      <tags>
        <tag>Manjaro</tag>
      </tags>
  </entry>
  <entry>
    <title>CF784G 「BF Calculator」 题解</title>
    <url>/posts/29332c4b70e33d51/</url>
    <content><![CDATA[<p>MoveToEx蒟蒻也开始写题解了QAQ</p>
<a id="more"></a>
<p><a href="https://www.luogu.org/problemnew/show/CF784G" target="_blank" rel="noopener">Luogu - CF784G</a><br><a href="https://codeforces.com/contest/784/problem/G" target="_blank" rel="noopener">CodeForces - 784G</a>  </p>
<p>愚人节比赛G题  </p>
<h1 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>Translated by <a href="https://www.luogu.org/space/show?uid=60864" target="_blank" rel="noopener">tiger2005@Luogu</a></p>
<p>在这个问题中，你要写一个可以生成Brainfuck语言的代码以算出数学表达式值的生成器。</p>
<p>给你一个算术表达式，其中包括数字0~255以及加减号，你需要生成一个可以算出并输出算术表达式结果的Brainfuck代码</p>
<p>我们将用一个绝对标准的Brainfuck编译器来判断你的Brainfuck代码的正误。</p>
<p>有30000个位置供你使用。</p>
<p>一个位置用无字符8比特的位置储存0~255的整数。</p>
<p>不支持输入（即不能出现’,’请求输入），在本题中也并不需要。</p>
<h2 id="输入输出"><a href="#输入输出" class="headerlink" title="输入输出"></a>输入输出</h2><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>输入仅有一行，包括一个算术表达式，内含2~10次运算对象，数字用 + 和/或 - 分离。每个运算对象将是一个在0和255间的整数。保证输出为0与225间的整数（在计算过程中可能会超出储存范围）。</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>输出一个Brainfuck程序，以计算表达式的值，这个表达式不得多过5000000个字符，在50000000次操作内就要结束。</p>
<h2 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h2><h3 id="Input-1"><a href="#Input-1" class="headerlink" title="Input #1"></a>Input #1</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2+3</span><br></pre></td></tr></table></figure>
<h3 id="Output-1"><a href="#Output-1" class="headerlink" title="Output #1"></a>Output #1</h3><figure class="highlight brainfuck"><table><tr><td class="code"><pre><span class="line">++&gt;<span class="comment">;</span></span><br><span class="line"><span class="comment"></span>++<span class="literal">+</span>&gt;<span class="comment">;</span></span><br><span class="line"><span class="comment"></span>&lt;<span class="comment">;</span><span class="title">[</span>&lt;<span class="comment">;</span><span class="literal">+</span>&gt;<span class="comment">;</span><span class="literal">-</span><span class="title">]</span>&lt;<span class="comment">;</span></span><br><span class="line"><span class="comment"></span>++<span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="string">.</span></span><br></pre></td></tr></table></figure>
<p><del>MoveToEx: 哦豁NexT代码高亮竟然支持BF</del></p>
<h3 id="Input-2"><a href="#Input-2" class="headerlink" title="Input #2"></a>Input #2</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">9-7</span><br></pre></td></tr></table></figure>
<h3 id="Output-2"><a href="#Output-2" class="headerlink" title="Output #2"></a>Output #2</h3><figure class="highlight brainfuck"><table><tr><td class="code"><pre><span class="line">++<span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span>&gt;<span class="comment">;</span></span><br><span class="line"><span class="comment"></span>++<span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span>&gt;<span class="comment">;</span></span><br><span class="line"><span class="comment"></span>&lt;<span class="comment">;</span><span class="title">[</span>&lt;<span class="comment">;</span><span class="literal">-</span>&gt;<span class="comment">;</span><span class="literal">-</span><span class="title">]</span>&lt;<span class="comment">;</span></span><br><span class="line"><span class="comment"></span>++<span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="string">.</span></span><br></pre></td></tr></table></figure>
<h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>BF可以在<a href="http://fatiherikli.github.io/brainfuck-visualizer" target="_blank" rel="noopener">BF Visualizer</a>运行。   </p>
<p>CF使用一种SPJ的东西，把我们的程序放到BF编译器里运行一遍，在根据BF程序的输出判断评测结果。   </p>
<p>其实如果要输出计算的结果的话<br>我们计算出来直接输出不就好了吗  </p>
<p>拿Input1来说，显然，$2+3=5$，所以我们写一个只输出5的程序即可。</p>
<figure class="highlight brainfuck"><table><tr><td class="code"><pre><span class="line">++<span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="string">.</span></span><br></pre></td></tr></table></figure>
<p>主要是这道题有几个坑…<br>BF只能输出字符，而这道题有的数据结果是大于9的<br>表达式会有多个运算对象，即使样例没有给出<br><strong>答案为0时手动转字符串的可能会卡掉</strong>   </p>
<p>关键是怎么计算<br>那些Python的做法就不说了吧<br>主要看C++</p>
<p>由于某些毒瘤的原因，我使用了C++11。   </p>
<p>首先，把数字和运算符从字符串当中提取出来。   </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">extract</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; num, <span class="built_in">vector</span>&lt;function&lt;<span class="keyword">int</span>(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt; &gt;&amp; ope)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; str;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); ++i) &#123;      <span class="comment">// 提取字符串形式的数字</span></span><br><span class="line">        <span class="keyword">int</span> tmp = i;</span><br><span class="line">        <span class="keyword">while</span>(s[i] != <span class="string">'+'</span> &amp;&amp; s[i] != <span class="string">'-'</span>) &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (tmp != i) str.push_back(s.substr(tmp, i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); ++i) &#123;      <span class="comment">// 处理运算符</span></span><br><span class="line">        <span class="keyword">if</span> (s[i] == <span class="string">'+'</span>) &#123;</span><br><span class="line">            ope.push_back([](<span class="keyword">int</span> a, <span class="keyword">int</span> b) -&gt; <span class="keyword">int</span> &#123; <span class="keyword">return</span> a + b; &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">'-'</span>) &#123;</span><br><span class="line">            ope.push_back([](<span class="keyword">int</span> a, <span class="keyword">int</span> b) -&gt; <span class="keyword">int</span> &#123; <span class="keyword">return</span> a - b; &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;::iterator it = str.begin(); it != str.end(); ++it) &#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = <span class="number">0</span>;                    <span class="comment">// 转至整数</span></span><br><span class="line">        <span class="built_in">sscanf</span>(it-&gt;c_str(), <span class="string">"%d"</span>, &amp;tmp);</span><br><span class="line">        num.push_back(tmp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后，把结果计算出来。   </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">calc</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; num;</span><br><span class="line">    <span class="built_in">vector</span>&lt;function&lt;<span class="keyword">int</span>(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt; &gt; ope;</span><br><span class="line">    extract(s, num, ope);</span><br><span class="line">    ans = num[<span class="number">0</span>];</span><br><span class="line">    num.erase(num.begin());</span><br><span class="line">    <span class="keyword">while</span>(!num.empty()) &#123;</span><br><span class="line">        ans = ope[<span class="number">0</span>](ans, num[<span class="number">0</span>]);</span><br><span class="line">        ope.erase(ope.begin());</span><br><span class="line">        num.erase(num.begin());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后，输出。<br>请注意，BF的输出不是输出数字而是以字符形式输出，所以我们需要对结果进行一些处理。<br>把答案转成字符串，输出即可。<br>格式大概是对于结果的每位数$a_i$，输出$a_i+48$个<code>+</code>和<code>.&gt;</code>即可。<br>当然如果有人想尝试一些骚操作的话我也不反对，毕竟CF那边用的是SPJ。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">string</span> s;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;   <span class="comment">// 被卡警告</span></span><br><span class="line">        s = <span class="string">"0"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(n) &#123;</span><br><span class="line">        s += (n % <span class="number">10</span> + <span class="string">'0'</span>);</span><br><span class="line">        n /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    reverse(s.begin(), s.end());</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; s[i]; ++j) &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">'+'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">".&gt;"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>[完]</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p>请勿抄袭<br>抄的话会有惊喜</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">extract</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; num, <span class="built_in">vector</span>&lt;function&lt;<span class="keyword">int</span>(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt; &gt;&amp; ope)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; str;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = i;</span><br><span class="line">        <span class="keyword">while</span>(s[i] != <span class="string">'+'</span> &amp;&amp; s[i] != <span class="string">'-'</span>) &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (tmp != i) str.push_back(s.substr(tmp, i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i] == <span class="string">'+'</span>) &#123;</span><br><span class="line">            ope.push_back([](<span class="keyword">int</span> a, <span class="keyword">int</span> b) -&gt; <span class="keyword">int</span> &#123; <span class="keyword">return</span> a + b; &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">'-'</span>) &#123;</span><br><span class="line">            ope.push_back([](<span class="keyword">int</span> a, <span class="keyword">int</span> b) -&gt; <span class="keyword">int</span> &#123; <span class="keyword">return</span> a - b; &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;::iterator it = str.begin(); it != str.end(); ++it) &#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">sscanf</span>(it-&gt;c_str(), <span class="string">"%d"</span>, &amp;tmp);</span><br><span class="line">        num.push_back(tmp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">calc</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; num;</span><br><span class="line">    <span class="built_in">vector</span>&lt;function&lt;<span class="keyword">int</span>(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt; &gt; ope;</span><br><span class="line">    extract(s, num, ope);</span><br><span class="line">    ans = num[<span class="number">0</span>];</span><br><span class="line">    num.erase(num.begin());</span><br><span class="line">    <span class="keyword">while</span>(!num.empty()) &#123;</span><br><span class="line">        ans = ope[<span class="number">0</span>](ans, num[<span class="number">0</span>]);</span><br><span class="line">        ope.erase(ope.begin());</span><br><span class="line">        num.erase(num.begin());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">string</span> s;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">        s = <span class="string">"0"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(n) &#123;</span><br><span class="line">        s += (n % <span class="number">10</span> + <span class="string">'0'</span>);</span><br><span class="line">        n /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    reverse(s.begin(), s.end());</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; s[i]; ++j) &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">'+'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">".&gt;"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">string</span> s;</span><br><span class="line">    output(calc(s));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>题解</category>
        <category>CodeForces</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>暴力</tag>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title>「长期更新」 如何优雅地机惨别人 for Win</title>
    <url>/posts/b871c09cf73bca69/</url>
    <content><![CDATA[<p>当你身边的人出去时没有锁电脑……</p>
<a id="more"></a>
<p>[2019/08/03] Upd: 做了一些补充，顺便加上liuzhe被机惨的几次（大雾<br>[2019/08/13] Upd: 增加关于PE头的内容，并将本文列为LTS。<br>[2020/04/24] Upd: 增加关于BIOS的内容</p>
<div class="note warning">声明：本页所有操作引发的后果(包括但不限于被核平、自己被机惨、电脑硬件损坏等)，与本人无关。</div><br>本页所有方法均在Windows平台上测试通过 <del>（在平时的机惨中</del><br><br># 「毒瘤I级」<br><br>## 关机<br><br>当他在写一些毒瘤的东西但是<strong>没有保存</strong>的话，这个方法会很有用。<br><br><figure class="highlight bat"><table><tr><td class="code"><pre><span class="line">shutdown -f -p</span><br></pre></td></tr></table></figure><br><br>随手<kbd>Ctrl</kbd>+<kbd>S</kbd>以预防。<br><br>顺便说一下这个对VSC及Notepad++之类的没用<br><br>## 杀explorer<br><br>终止资源管理器，配合<kbd><i class="fa fa-windows"></i></kbd>+<kbd>D</kbd>使用更佳。<br><br><figure class="highlight bat"><table><tr><td class="code"><pre><span class="line"><span class="built_in">taskkill</span> /im explorer.exe /f</span><br></pre></td></tr></table></figure><br><br>可通过<kbd><i class="fa fa-windows"></i></kbd>+<kbd>R</kbd> <code>explorer.exe</code>解决。<br><br>## 账号<br><br>最常见的机惨手段<br>不说了吧<br><br>用他的账号比如洛咕或者QQ啥的做一些奇奇怪怪的事情……比如<code>I AK IOI</code>啥的<br><br>一般 <del>经常机惨别人或经常被机惨</del> 的OIer都会对此种机惨方式有所防范。<br><br>&gt; 我最强了<br>&gt;<br>&gt; <p style="text-align: right">–被机惨的Herself32</p><br><br>&gt; 我tql<br>&gt;<br>&gt; <p style="text-align: right">–被机惨的Payphone-X</p><br><br>&gt; wtxdy<br>&gt;<br>&gt; <p style="text-align: right">–被机惨的MoveToEx菜鸡</p><br><br>&gt; iakioi<br>&gt; I AK IOI!<br>&gt; IAKIOI<br>&gt; wtxdy<br>&gt;<br>&gt; <p style="text-align: right">–被机惨的liuhe</p><br><br>&gt; I AK IOI!<br>&gt;<br>&gt; <p style="text-align: right">–被机惨的机房某同学</p><br><br><br>各位离开电脑的时候一定要锁电脑（<br>一般一个OIer发送<code>wtxdy</code>或<code>I AK IOI</code>所用时间不超过5s<br><br>没啥好办法预防<br>注意锁电脑和账户<br><br># 「毒瘤II级」<br><br>## 魔改编译器<br><br>### Dev-C++<br><br>点开 工具-&gt;编译选项 ，勾选”在编译时加入以下命令”，然后……<br><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">--help</span><br></pre></td></tr></table></figure><br><br>如果你比较毒瘤……<br><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-Dmain&#x3D;mian</span><br><span class="line">-Dwmain&#x3D;wmian</span><br><span class="line">-DWinMain&#x3D;WinMian</span><br><span class="line">-DwWinMain&#x3D;wWinMian</span><br><span class="line">-DONLINE_JUDGE</span><br></pre></td></tr></table></figure><br><br>比较不容易被发现<br>但会暴露在下方输出框的编译命令里<br><br>### VSCode<br><br>各扩展提供的编译方式不同，请自行更改，在此以AIO Compiler 2.0.0为例<br><br>文件:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">%USERPROFILE%\\.vscode\\extensions\\aztechcorps.aio-compiler-2.0.0\\extension.js</span><br></pre></td></tr></table></figure><br><br>第 24~28 行:<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">"compile"</span>: &#123;</span><br><span class="line">    <span class="string">"c"</span>: <span class="string">`gcc -o .output<span class="subst">$&#123;pathDelimiter&#125;</span>main -lm `</span>,</span><br><span class="line">    <span class="string">"cpp"</span>: <span class="string">`g++ -o .output<span class="subst">$&#123;pathDelimiter&#125;</span>main `</span>,</span><br><span class="line">    <span class="string">"java"</span>: <span class="string">"javac -d \".output\" "</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><br><br>可能稍有不同<br>这是编译的命令<br>自己魔改吧<br><br>VS的话就算了<br>MSBuild不是一般OIer会改的<br>我更不会（<br><br>## 魔改头文件<br><br>按住Ctrl，点击他包括的最后一个头文件，在末尾加入本站<a href="/duliu/Programs/JC-Header.html">毒瘤/机惨标头</a>中的代码。<br>对于万能头(<code>&lt;bits/stdc++.h&gt;</code>)尤其好用<br><br>对VS和VSC及<strong>比较现代</strong>的编辑器不适用，因为这些编辑器都能够分析代码并给出提示<br>只要把光标放在宏的位置……<br><br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(<span class="string">"MoveToEx is juruo!"</span>);</span><br><span class="line">              ┌────────────────────────┐</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; le│ <span class="meta">#<span class="meta-keyword">define</span> strlen(x) -1   │</span></span><br><span class="line">              ├────────────────────────┤</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; │ Expands to:            │</span><br><span class="line">&#125;             │ <span class="number">-1</span>                     │</span><br><span class="line">              └────────────────────────┘</span><br></pre></td></tr></table></figure><br><br><br>可通过换用VSC或VS解决（大雾<br><br>## 魔改其他文件<br><br>曾经Handwer太阳被机惨的时候用户密码被删了，博客也被改了<br><br>&gt; 折腾了一个中午才恢复过来<br>&gt;<br>&gt; <p style="text-align: right">–HandwerSTD</p><br><br>或者把他桌面的快捷方式改一下<br>改成指向<code>shutdown -p -f</code>，把图标改到原来的图标<br><br>但是不保证没人会像我一样毒瘤<br>我的桌面图标基本上是拿来看的<br>一般用Wox+开始+任务栏<br>（Wox大法好啊<br><br>同样，记得锁电脑<br><br># 「毒瘤III级」<br><br><div class="note warning">以下内容被WL带师认为是迫害，请自行把握尺度，避免被核平</div>

<p>如果关系没有好到一定程度的话<strong>请勿尝试</strong></p>
<h2 id="修改BIOS"><a href="#修改BIOS" class="headerlink" title="修改BIOS"></a>修改BIOS</h2><p>首先关机<br>如果没法关的话长按电源键  </p>
<p>然后开机进入BIOS<br>如果不知道是哪个键的话就用手指在<kbd>F1</kbd>-<kbd>F12</kbd>滚几遍就好了<br>有的电脑可能需要按住<kbd>Fn</kbd></p>
<p>然后就作吧<br>BIOS可以禁用无线网络<br>可以设定硬盘密码<br>啥的  </p>
<h2 id="魔改EXE"><a href="#魔改EXE" class="headerlink" title="魔改EXE"></a>魔改EXE</h2><p>emmmmmmm</p>
<p>Windows启动程序时，会从程序中读取一份关于程序从外部引入的标识符(可以是函数及变量名等)的列表(称为<code>PE头</code>)，按照这个列表加载DLL。由于EXE中保存的列表一般不变，这种方式也被称为静态加载  </p>
<p>PE头保存在EXE文件中  </p>
<p>有一种程序，能够读取程序的PE头，并有能力重建和编辑PE头  </p>
<p>只要预先准备好对应的DLL，就能让程序从停止运行到关机再到砍<code>Program Files</code>……  </p>
<p>改哪个程序不需要我说了吧 Dev 颓废工具啥的<br>当然如果被修改的程序要求管理员权限就更有意思了（（（  </p>
<p>编辑PE头推荐<code>LordPE</code>。<br>编译DLL文件推荐<code>Visual Studio</code>系列。<br>(记得Dev好像能编译DLL来的)  </p>
<p>相对隐秘，不易发现<br>但是相对麻烦的多，要求机惨者了解Windows相关技术<br>而且重装被修改的软件即可修复（  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Shlobj.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LIBAPI __declspec(dllexport)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> &#123;</span><br><span class="line">    <span class="function">LIBAPI <span class="keyword">void</span> <span class="title">crash</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> *p = &amp;a;</span><br><span class="line">        p += <span class="number">2333</span>;</span><br><span class="line">        (*p)++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">LIBAPI <span class="keyword">void</span> <span class="title">memory_limit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>) <span class="keyword">new</span> <span class="keyword">int</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">LIBAPI <span class="keyword">void</span> <span class="title">time_limit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">LIBAPI <span class="keyword">void</span> <span class="title">kill_explorer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">            system(<span class="string">"taskkill /im explorer.exe /f"</span>);</span><br><span class="line">            Sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">LIBAPI <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        system(<span class="string">"shutdown -p"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">LIBAPI <span class="keyword">void</span> <span class="title">delete_program_files</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!IsUserAnAdmin()) &#123;</span><br><span class="line">            crash();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        system(<span class="string">"del /q \"C:\\Program Files\""</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="魔改注册表"><a href="#魔改注册表" class="headerlink" title="魔改注册表"></a>魔改注册表</h2><p>注册表是个好东西<br>不仅键值目录复杂的让人头疼<br>键值的意义也难以弄清<br>所以注册表可以拿来机惨用，不仅难以确定问题所在，还难以恢复   </p>
<p>比如<br>Windows注册表有一个位置<br>它的值列出了一些DLL文件<br><code>User32.dll</code>会在每一个加载<code>User32.dll</code>的程序运行时加载这些DLL文件并调用<code>DllMain</code>，<code>fdwReason</code>传入<code>DLL_PROCESS_ATTACH</code><br>(该特性在最新版本的Windows不确定是否被保留，Win7实测可行)<br>然后……   </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">BOOL WINAPI <span class="title">DllMain</span><span class="params">(HINSTANCE hInstDll, DWORD fdwReason, PVOID fImpLoad)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span>(fdwReason) &#123;</span><br><span class="line">        <span class="keyword">case</span> DLL_PROCESS_ATTACH: &#123;</span><br><span class="line">            MessageBox(<span class="literal">NULL</span>, TEXT(<span class="string">"This program ran into an error."</span>), TEXT(<span class="string">"Error"</span>), MB_ICONERROR);</span><br><span class="line">            ExitProcess(<span class="number">0</span>);     <span class="comment">// 退出进程</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">default</span>: &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>嚄嚄嚄嚄  </p>
<p>这个位置：<br><code>HKEY_LOCAL_MACHINE\Software\Microsoft\Windows NT\CurrentVersion\Windows</code></p>
<p>[2019/08/03] Upd: 当时手残，<code>HKEY</code>打成<code>HEKY</code>，已修复  </p>
<p>这个位置下的<code>LoadAppInit_DLLs</code>键的值为<code>1</code>的时候，<code>AppInit_DLLs</code>才会生效。<br>这个位置下的<code>AppInit_DLLs</code>键的值指定一个或一组DLL的文件名，用<code>&#39; &#39;</code>或<code>&#39;,&#39;</code>分隔。    </p>
<p>在VM试了一遍，确实能用，不过需要编译时指定运行方的Windows平台，否则会提示找不到<code>vcruntime140.dll</code>啥的……<br>然后就是<code>control</code>，<code>cmd</code>，甚至<code>taskkill</code>一类的东西开启的时候都会加载那个链接库<br>啊当然也包括你自己写的  </p>
<p>倒也有解决方法<br>就是在U盘或者什么地方保存一份注册表的备份，并经常更新（  </p>
<p>[2019/08/03] Upd: 请注意：</p>
<blockquote>
<p>This feature may not be available in future versions of the Windows operating system.<br>(该特性在未来的Windows系统版本中可能不可用(指<code>AppInit_DLLs</code>))</p>
<p style="text-align: right">–<a href="https://support.microsoft.com/en-us/help/197571/working-with-the-appinit-dlls-registry-value" target="_blank" rel="noopener">Microsoft</a></p>
</blockquote>
<h2 id="格式化"><a href="#格式化" class="headerlink" title="格式化"></a>格式化</h2><p>emmmmmmm<br>如果不想被核平解决掉的话请不要尝试  </p>
<p>请在具有管理员权限的Powershell窗口中运行  </p>
<figure class="highlight ps"><table><tr><td class="code"><pre><span class="line">format D: /u /s</span><br><span class="line">format E: /u /s</span><br><span class="line">format F: /u /s</span><br></pre></td></tr></table></figure>
<p>能通过恢复工具找回不少<br>但是如果他毒瘤的要死帮你用弄个37次随机覆写啥的……<br>弄死他</p>
<h2 id="删除分区"><a href="#删除分区" class="headerlink" title="删除分区"></a>删除分区</h2><p>emmmmmmm*2</p>
<figure class="highlight bat"><table><tr><td class="code"><pre><span class="line">diskpart</span><br><span class="line">list disk</span><br><span class="line">select disk <span class="number">0</span></span><br><span class="line">list partition</span><br></pre></td></tr></table></figure>
<p>然后随机挑选一个幸运分区进行delete。   </p>
<p>基本无解</p>
<p>[2019/08/01] Upd<br>有解<br>可以用DiskGenius恢复绝大部分<br>但是文件路径不保证全部正确  </p>
<p>别问我为啥知道（QAQ</p>
<h2 id="删除引导"><a href="#删除引导" class="headerlink" title="删除引导"></a>删除引导</h2><p>不说了<br>不会的就算了<br>别去祸害社会<br>至于那些会的我劝你善良</p>
<p>可通过重装系统解决   </p>
]]></content>
      <categories>
        <category>灌水区</category>
      </categories>
      <tags>
        <tag>极致毒瘤</tag>
      </tags>
  </entry>
  <entry>
    <title>「长期更新」 安利</title>
    <url>/posts/c6fa5907e5d1119c/</url>
    <content><![CDATA[<p>闲着没事安利一发自己用的顺手的东西  </p>
<a id="more"></a>
<style>
.list-item {
    display: inline-block;
    width: 233px;

}
.list-item > a {
    cursor: default;
    width: 100%;
}
.card {
    text-align: center;
    overflow: hidden;
    border-radius: 4px;
    height: 74px;
    width: 223px;
    transition: all .3s;
}
.card:hover {
    box-shadow: 3px 3px 3px rgba(0, 0, 0, .3);
    background-color: #ddd;
    transition: all .3s;
}
.title {
    height: 20px;
    margin: 0;
    margin-top: 14px;
}
.descr {
    text-align: center;
    font-size: 10px;
    color: #222;
}
.angle {
    color: white;
    transition: all .3s;
}
.card:hover > .titles > .title > .angle {
    color: blue;
    transition: all .3s;
}
</style>

<p>[2020/4/9] Upd: 换个布局，原来的又难看又繁琐<br>然后成功给我写炸了 /kk  </p>
<h1 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h1><div class="_container" data="Windows"><ul class="list"></ul></div>

<p>PanDownload 的事相信大家都知道，就不废话了<br>感谢作者让我们白嫖了某度网盘这么长时间  </p>
<h1 id="Android"><a href="#Android" class="headerlink" title="Android"></a>Android</h1><div class="note warning">请从 Google Play 获取</div>

<div class="_container" data="Android"><ul class="list"></ul></div>

<h1 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h1><div class="_container" data="Font"><ul class="list"></ul></div>

<script>
var v = {
    "Windows": [
        { "link": "https://www.bandisoft.com/bandizip/", "name": "Bandizip", "descr": "压缩工具" },
        { "link": "http://www.ccleaner.com/ccleaner", "name": "CCleaner", "descr": "清理垃圾" },
        { "link": "https://cmder.net/", "name": "Cmder", "descr": "命令行工具" },
        { "link": "https://github.com/0xd4d/dnSpy/releases", "name": "dnSpy", "descr": ".NET & C# 反编译"},
        { "link": "https://macpaw.com/encrypto", "name": "Encrypto", "descr": "文件加密"},
        { "link": "https://www.voidtools.com/", "name": "Everything", "descr": "文件搜索" },
        { "link": "https://www.geogebra.org/", "name": "Geogebra", "descr": "数学绘图" },
        { "link": "https://www.pandownload.com", "name": "<i class=\"fa fa-info-circle\"></i>PanDownload", "descr": "百度网盘下载工具" },
        { "link": "https://potplayer.daum.net/", "name": "PotPlayer", "descr": "视频播放" },
        { "link": "https://github.com/microsoft/PowerToys", "name": "Power Toys", "descr": "一些有用的小工具" },
        { "link": "https://docs.microsoft.com/en-us/sysinternals/downloads/process-explorer", "name": "Process Explorer", "descr": "进程管理" },
        { "link": "https://www.qbittorrent.org/", "name": "qBitTorrent", "descr": "torrent下载" },
        { "link": "https://www.sandboxie.com/", "name": "Sandboxie", "descr": "沙盒环境" },
        { "link": "https://www.screentogif.com/", "name": "Screen to GIF", "descr": "动图录制" },
        { "link": "https://www.snipaste.com/", "name": "Snipaste", "descr": "屏幕截图" },
        { "link": "http://www.uderzo.it/main_products/space_sniffer/download.html", "name": "Space Sniffer", "descr": "空间占用可视化"},
        { "link": "https://typora.io/", "name": "Typora", "descr": "M↓编辑器" },
        { "link": "https://www.veracrypt.fr/en/Home.html", "name": "VeraCrypt", "descr": "驱动器加密" },
        { "link": "https://code.visualstudio.com/", "name": "Visual Studio Code", "descr": "代码编辑器" },
        { "link": "https://github.com/Microsoft/Terminal", "name": "Windows Terminal", "descr": "终端工具" },
        { "link": "http://www.wox.one/", "name": "Wox", "descr": "快速启动工具" }
    ],
    "Android": [
        { "link": "https://play.google.com/store/apps/details?id=ru.iiec.cxxdroid&hl=en_US", "name": "CxxDroid", "descr": "C++编辑 & 编译" },
        { "link": "https://play.google.com/store/apps/details?id=com.fastaccess.github", "name": "FastHub", "descr": "Github第三方客户端" },
        { "link": "https://play.google.com/store/apps/details?id=com.termux", "name": "Termux", "descr": "终端模拟器" }
    ],
    "Font": [
        { "link": "https://github.com/adobe-fonts/source-code-pro", "name": "<span style=\"font-family: SourceCodePro\">Source Code Pro</span>", "descr": "Adobe出品，为代码而生"},
        { "link": "https://github.com/tonsky/FiraCode", "name": "<span style=\"font-family: FiraCode\">Fira Code</span>", "descr": "<span style=\"font-family: FiraCode\">支持连字，代码专用>=_<= </span>" }
    ]
};

var ctnr = document.querySelector('._container');

for (var i in v) {
    ctnr = document.querySelector(`._container[data=${i}]`);
    for (var item in v[i]) {
            ctnr.innerHTML += `
        <li class="list-item">
            <a href="${v[i][item].link}" target="_blank">
                <div class="card">
                    <div class="titles">
                        <p class="title"><i class="fa fa-angle-right angle"></i> ${v[i][item].name}</p>
                        <p class="descr">${v[i][item].descr}</p>
                    </div>
                </div>
            </a>
        </li>`;
    }
}
</script>]]></content>
      <categories>
        <category>灌水区</category>
      </categories>
      <tags>
        <tag>N/A</tag>
      </tags>
  </entry>
  <entry>
    <title>Lambda表达式</title>
    <url>/posts/79e68f4965059f8c/</url>
    <content><![CDATA[<p>和JS有点像<br>不过多了个作用域的限制<br><a id="more"></a></p>
<h1 id="Lambda简介"><a href="#Lambda简介" class="headerlink" title="Lambda简介"></a>Lambda简介</h1><p>（Lambda表达式被Wiki重定向至匿名函数）</p>
<blockquote>
<p>在计算机编程中，匿名函数（英语：anonymous function）是指一类无需定义标识符（函数名）的函数或子程序，普遍存在于多种编程语言中。<br>1958年LISP首先采用匿名函数，自此之后，越来越多编程语言陆续采用，主流的编程语言如PHP和C++也在不久前采用。   </p>
<p style="text-align: right">–<a href="https://zh.wikipedia.org/wiki/%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0" target="_blank" rel="noopener">匿名函数-维基百科</a></p>
</blockquote>
<p>Lambda表达式就是这种东西:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> f = [](<span class="keyword">int</span> a) -&gt; <span class="keyword">int</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> a * a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>emmmmmm<br>看起来很像JS啊   </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> f = <span class="function">(<span class="params">a</span>) =&gt;</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> a * a;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>但是为啥他们都要用箭头啊</p>
<p>话说最近C++添加的和别的语言相似的东西越来越多了，比如<code>std::for_each</code>啥的   </p>
<p>CR对这个的介绍是这样的：</p>
<blockquote>
<p>构造闭包：能够捕获作用域中变量的无名函数对象。</p>
<p style="text-align: right">–<a href="https://zh.cppreference.com/w/cpp/language/lambda" target="_blank" rel="noopener">cppreference.com</a></p>
</blockquote>
<p>emmmm</p>
<p>不知道怎么描述的更加通俗易懂……   </p>
<h1 id="基本形式"><a href="#基本形式" class="headerlink" title="基本形式"></a>基本形式</h1><p>lambda函数大多是这样的：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">[capture] (parameters) -&gt; <span class="keyword">mutable</span> return_type &#123; body &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>Capture: 用于捕获Lambda表达式外的变量，如下：<ul>
<li><code>[]</code>: 不指定任何变量，使用表达式外的变量将导致CE，但是不加<code>[]</code>也会CE。</li>
<li><code>[x]</code>: <code>x</code>按值传递。</li>
<li><code>[&amp;x]</code>: <code>x</code>按引用传递。</li>
<li><code>[=]</code>: 任何<strong>被使用到</strong>的外部变量按值传递。</li>
<li><code>[&amp;]</code>: 任何<strong>被使用到</strong>的外部变量按引用传递。</li>
<li><code>[&amp;, x]</code>: <code>x</code>按值传递，其他用到的变量按引用传递，可以改变变量的个数，不可互换位置。</li>
<li><code>[=, &amp;x]</code>: <code>x</code>按引用传递，其他按值传递，可以改变变量的个数，不可互换位置。   </li>
<li>特别的，类或结构体中的Lambda表达式需要显式捕捉<code>this</code>指针从而使用当前对象中的成员。</li>
<li>函数可以访问的变量有：<ul>
<li>参数</li>
<li>函数内声明的变量</li>
<li>对象成员</li>
<li>全局变量</li>
<li>被捕获的变量</li>
</ul>
</li>
</ul>
</li>
<li>Parameters: 函数的参数，定义方法和C++中一般函数相同。注意，Lambda表达式与一般函数有下列不同：<ul>
<li>不能有缺省值 (如<code>int fun(int a = 10)</code>)</li>
<li>不能有可变参数 (如<code>int fun(int cnt, ...)</code>)</li>
<li>不能有无名参数 (如<code>int fun(int, int) {}</code>)</li>
</ul>
</li>
<li><code>mutable</code>: 如果出现<code>mutable</code>， 在Capture中指定<strong>按值传入的</strong>外部变量可以被更改，否则默认其为只读变量。</li>
<li>Return_type: 函数的返回值类型。对于<code>void</code>函数，该项和前面的<code>-&gt;</code>可省略，但不可只出现一个。    </li>
<li>Body: 函数体。</li>
</ul>
<p>Lambda表达式需要用<code>std::function&lt;&gt;</code>(定义于<code>&lt;functional&gt;</code>)或<code>auto</code>类型的变量存储，<code>function</code>的模板中填入形如<code>int(int,int)</code>的函数类型和参数。如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::function&lt;<span class="keyword">int</span>(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt; add = [](<span class="keyword">int</span> a, <span class="keyword">int</span> b) -&gt; <span class="keyword">int</span> &#123; <span class="keyword">return</span> a + b; &#125;;</span><br><span class="line"><span class="keyword">auto</span> sub = [](<span class="keyword">int</span> a, <span class="keyword">int</span> b) -&gt; <span class="keyword">int</span> &#123; <span class="keyword">return</span> a - b; &#125;</span><br></pre></td></tr></table></figure>
<h1 id="调用"><a href="#调用" class="headerlink" title="调用"></a>调用</h1><p>以<code>变量名(参数列表)</code>形式调用即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">auto</span> println = [](<span class="keyword">int</span> i) &#123; <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>; &#125;;</span><br><span class="line">	println(<span class="number">1</span>);</span><br><span class="line">	println(<span class="number">2</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><h2 id="P1001-A-B"><a href="#P1001-A-B" class="headerlink" title="P1001 A + B"></a>P1001 A + B</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a, b;</span><br><span class="line">	function&lt;<span class="keyword">int</span>(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt; add = [](<span class="keyword">int</span> a, <span class="keyword">int</span> b) -&gt; <span class="keyword">int</span> &#123; <span class="keyword">return</span> a + b; &#125;;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; add(a, b) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, a[<span class="number">1001</span>];</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">    sort(a, a + n, [](<span class="keyword">int</span> a, <span class="keyword">int</span> b) -&gt; <span class="keyword">bool</span> &#123; <span class="keyword">return</span> a &lt; b; &#125;);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) <span class="built_in">cout</span> &lt;&lt; a[i];</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    sort(a, a + n, [](<span class="keyword">int</span> a, <span class="keyword">int</span> b) -&gt; <span class="keyword">bool</span> &#123; <span class="keyword">return</span> a &gt; b; &#125;);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) <span class="built_in">cout</span> &lt;&lt; a[i];</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++</category>
        <category>C++11</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>新语法&amp;新特性</tag>
      </tags>
  </entry>
  <entry>
    <title>Trie</title>
    <url>/posts/ee5ec8ffcb4b8966/</url>
    <content><![CDATA[<p><del>最近码风越来越毒瘤了</del>   </p>
<p>Trie，又称字典树、前缀树，是一种用于存储字符串的数据结构。<br><del>这种东西在一个我之前用过的OJ上是入门级别的</del><br><del>可怕</del>   </p>
<a id="more"></a>
<p>在洛咕跳题玩的时候跳到了<a href="https://www.luogu.org/problemnew/show/P2580" target="_blank" rel="noopener">P2580</a>，众所周知，这是一个map水题，但是题目的标签既然有<code>Trie</code>……<br>那我们就用Trie做就是了……   </p>
<p><del>毕竟是全谷Trie最水的题了</del></p>
<h1 id="什么是Trie"><a href="#什么是Trie" class="headerlink" title="什么是Trie"></a>什么是Trie</h1><p>Trie,其作者Edward Fredkin将其读作/ˈtriː/(“tree”)，但是，更多的人比较倾向于使用/ˈtraɪ/(“try”)。   </p>
<p>Trie，是一种树形结构，有插入和查找两种操作，以字符串为键，鬼畜的一批，因为这种树的键不会保存在节点中，而是由节点在树中的位置决定，Trie树的任意节点的子节点都有相同前缀。   </p>
<p>大概长这样：</p>
<p><img src="/post_images/Trie.png" alt="Trie"></p>
<p>（在这里，节点所显示的字符串为方便理解所加，并不实际储存在节点中）</p>
<h1 id="Trie的基本思路"><a href="#Trie的基本思路" class="headerlink" title="Trie的基本思路"></a>Trie的基本思路</h1><h2 id="根节点"><a href="#根节点" class="headerlink" title="根节点"></a>根节点</h2><p>作为一棵树，需要一个根节点，而Trie的根节点不存储任何东西，所以可以直接用一个数字或者指针，如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">char</span> Start, <span class="keyword">size_t</span> MaxSize&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Trie</span> &#123;</span></span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">			<span class="comment">// ...</span></span><br><span class="line">		&#125;;</span><br><span class="line">		<span class="comment">// 1:</span></span><br><span class="line">		Node* head;</span><br><span class="line">		<span class="comment">// 2:</span></span><br><span class="line">		<span class="keyword">int</span> head = <span class="number">0</span>;</span><br><span class="line">		<span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至于这里的<code>Start</code>和<code>MaxSize</code>……<br>Trie树中的每个节点的子节点数目如果弄成<code>MAX_CHAR</code>是很致命的，会有一大堆空间（如果使用指针，还有时间）浪费，所以只能设置一个起始点，一个最大大小，这样找子节点时用<code>s[i] - Start</code>就可以了。</p>
<h2 id="节点"><a href="#节点" class="headerlink" title="节点"></a>节点</h2><p>Trie树的节点不需要储存字符，只需要储存当前节点的子节点，因为Trie树中键不需要被显式保存。<br>所以它的节点大概长这样：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">	Node* child[...];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>当然，有很多时候我们需要自行魔改，这只是个基本的节点。<br>至于为啥用指针写……<br>Trie这种空间换时间的东西占空间太大，在我的WSL上节点数组开到1e6就……炸了<br>我也不知道是不是WSL的问题<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">movetoex@MoveToEx-PC:~$ sed -n <span class="string">'10,14p'</span> Trie_Array.cpp</span><br><span class="line">  typedef struct tagNode &#123;</span><br><span class="line">      bool IsStr;</span><br><span class="line">      int child[27];</span><br><span class="line">    &#125; Node;</span><br><span class="line">  Node nodes[100001];</span><br><span class="line">movetoex@MoveToEx-PC:~$ ./Array</span><br><span class="line">段错误 (核心已转储)</span><br></pre></td></tr></table></figure></p>
<p>然后开到1e5，弄1k个字符串，每个30字符的数据测的时候……</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">movetoex@MoveToEx-PC:~$ ./Array &lt; ./Input</span><br><span class="line">段错误 (核心已转储)</span><br></pre></td></tr></table></figure>
<p>卒<br>再来看指针……</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">movetoex@MoveToEx-PC:~$ ./Ptr &lt; ./Input</span><br><span class="line">1</span><br></pre></td></tr></table></figure>
<p>所以我选择动态内存……   </p>
<p>（但是在洛咕上面数组和指针都能用，我也不知道是什么鬼畜操作）   </p>
<p>或者，加一个判断当前节点是否为完整字符串的布尔变量：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">	<span class="keyword">bool</span> bIsStr;</span><br><span class="line">	Node* child[...];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2><p>循环$|s|$次，每次查找当前节点的第$s_i$个子节点，如果为<code>0</code>或<code>NULL</code>，插入新节点，否则使当前节点指针指向子节点（至于数组怎么说……自行理解吧）   </p>
<p>时间复杂度大概$\mathcal O(|s|)$</p>
<p>直接上代码   </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(<span class="keyword">char</span>* szString, <span class="keyword">size_t</span> iLen)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> tmp = <span class="number">0</span>;</span><br><span class="line">	Trie::Node *p = <span class="keyword">this</span>-&gt;head;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; iLen; ++i) &#123;</span><br><span class="line">		tmp = szString[i] - Start;</span><br><span class="line">		<span class="keyword">if</span> (p-&gt;child[tmp] == <span class="literal">NULL</span>) &#123;</span><br><span class="line">			p-&gt;child[tmp] = <span class="keyword">this</span>-&gt;_alloc();</span><br><span class="line">		&#125;</span><br><span class="line">		p = p-&gt;child[tmp];</span><br><span class="line">	&#125;</span><br><span class="line">	p-&gt;IsStr = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><p>循环$|s|$次，每次查找当前节点的第$s_i$个子节点，如果为<code>0</code>或<code>NULL</code>返回<code>false</code>，否则使当前节点指针指向子节点。最后，返回当前节点是否为一个完整字符串。   </p>
<p>时间复杂度大概$\mathcal O(|s|)$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Trie::Find</span><span class="params">(<span class="keyword">char</span>* szString, <span class="keyword">size_t</span> iLen)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> tmp = <span class="number">0</span>;</span><br><span class="line">	Node* p = <span class="keyword">this</span>-&gt;head;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; iLen; ++i) &#123;</span><br><span class="line">		tmp = szString[i] - Start;</span><br><span class="line">		<span class="keyword">if</span> (p-&gt;child[tmp] == <span class="literal">NULL</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			p = p-&gt;child[tmp];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> p-&gt;IsStr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Trie代码"><a href="#Trie代码" class="headerlink" title="Trie代码"></a>Trie代码</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">char</span> Start, <span class="keyword">size_t</span> MaxSize&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Trie</span> &#123;</span></span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tagNode</span> &#123;</span></span><br><span class="line">		<span class="keyword">bool</span> IsStr;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">tagNode</span> *<span class="title">child</span>[<span class="title">MaxSize</span> + 1];</span></span><br><span class="line">	&#125; Node;</span><br><span class="line">	Node* head;</span><br><span class="line">	<span class="keyword">inline</span> Trie::Node* _alloc() &#123;</span><br><span class="line">		Trie::Node* p = <span class="keyword">new</span> Trie::Node;</span><br><span class="line">		<span class="built_in">memset</span>(p, <span class="number">0</span>, <span class="keyword">sizeof</span>(Trie::Node));</span><br><span class="line">		<span class="keyword">return</span> p;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">void</span> _free(Trie::Node** p) &#123;</span><br><span class="line">		<span class="keyword">if</span> (*p) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= MaxSize; ++i) &#123;</span><br><span class="line">				<span class="keyword">if</span> ((*p)-&gt;child[i]) &#123;</span><br><span class="line">					<span class="keyword">this</span>-&gt;_free(&amp;(*p)-&gt;child[i]);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">delete</span> *p;</span><br><span class="line">			*p = <span class="literal">NULL</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">	Trie() &#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;head = <span class="keyword">this</span>-&gt;_alloc();</span><br><span class="line">	&#125;</span><br><span class="line">	~Trie() &#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;_free(&amp;<span class="keyword">this</span>-&gt;head);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* szString, <span class="keyword">size_t</span> iLen)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> tmp = <span class="number">0</span>;</span><br><span class="line">		Trie::Node *p = <span class="keyword">this</span>-&gt;head;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; iLen; ++i) &#123;</span><br><span class="line">			tmp = szString[i] - Start;</span><br><span class="line">			<span class="keyword">if</span> (p-&gt;child[tmp] == <span class="literal">NULL</span>) &#123;</span><br><span class="line">				p-&gt;child[tmp] = <span class="keyword">this</span>-&gt;_alloc();</span><br><span class="line">				p-&gt;child[tmp]-&gt;c = szString[i];</span><br><span class="line">			&#125;</span><br><span class="line">			p = p-&gt;child[tmp];</span><br><span class="line">		&#125;</span><br><span class="line">		p-&gt;IsStr = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">Find</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* szString, <span class="keyword">size_t</span> iLen)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> tmp = <span class="number">0</span>;</span><br><span class="line">		Node* p = <span class="keyword">this</span>-&gt;head;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; iLen; ++i) &#123;</span><br><span class="line">			tmp = szString[i] - Start;</span><br><span class="line">			<span class="keyword">if</span> (p-&gt;child[tmp] == <span class="literal">NULL</span>) &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				p = p-&gt;child[tmp];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> p-&gt;IsStr;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
        <category>数据结构</category>
        <category>Trie</category>
      </categories>
      <tags>
        <tag>OI</tag>
        <tag>Trie</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>显式载入DLL</title>
    <url>/posts/de09178a92b63b99/</url>
    <content><![CDATA[<p>之前，我讲过在代码中使用动态链接库的方法，不过把DLL路径嵌到程序中的方法似乎并不总能满足我们的需求，于是就有了显式载入DLL这种神奇的东西。   </p>
<p>比如加载一个目录下的所有DLL……</p>
<a id="more"></a>
<h1 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h1><p>加载DLL使用<code>LoadLibrary</code>函数。   </p>
<p>该函数有扩展版本<code>LoadLibraryEx</code>，但<code>LoadLibrary</code>已经足够一般使用。</p>
<p>如果指定的DLL已经被<strong>当前进程</strong>使用，即已经被映射到当前进程的内存空间，系统会增加其使用计数，使用计数由操作系统维护，当某个模块的使用计数降至0，由系统销毁当前模块占用的内存。</p>
<h2 id="LoadLibrary"><a href="#LoadLibrary" class="headerlink" title="LoadLibrary"></a>LoadLibrary</h2><h3 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h3><p>MSDN:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">HMODULE <span class="title">LoadLibraryA</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  LPCSTR lpLibFileName</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><h4 id="lpLibFileName"><a href="#lpLibFileName" class="headerlink" title="lpLibFileName"></a>lpLibFileName</h4><p>DLL的文件名，可以使用绝对路径(文件夹之间使用<code>\\</code>而不是<code>/</code>分隔)或相对路径或文件名。<br>如果使用文件名，函数将首先搜索EXE的路径，然后搜索<code>%PATH%</code>，如果找不到，则函数失败。   </p>
<h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3><p>如果函数成功，返回模块的<code>HMODULE</code>（和<code>HINSTANCE</code>是一个东西）<br>如果函数失败，返回<code>NULL</code>。   </p>
<h1 id="卸载"><a href="#卸载" class="headerlink" title="卸载"></a>卸载</h1><p>卸载模块使用<code>FreeLibrary</code>函数。   </p>
<p>该函数递减使用计数。</p>
<h2 id="FreeLibrary"><a href="#FreeLibrary" class="headerlink" title="FreeLibrary"></a>FreeLibrary</h2><h3 id="声明-1"><a href="#声明-1" class="headerlink" title="声明"></a>声明</h3><p>MSDN:   </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">FreeLibrary</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  HMODULE hLibModule</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="参数-1"><a href="#参数-1" class="headerlink" title="参数"></a>参数</h3><h4 id="hLibModule"><a href="#hLibModule" class="headerlink" title="hLibModule"></a>hLibModule</h4><p>要卸载的模块的句柄。   </p>
<p>函数会将模块的使用计数递减，当计数降为0时，由操作系统销毁内存中的模块。   </p>
<h3 id="返回值-1"><a href="#返回值-1" class="headerlink" title="返回值"></a>返回值</h3><p>函数成功，则返回值为非零<br>函数失败，则返回值为0</p>
<h1 id="调用"><a href="#调用" class="headerlink" title="调用"></a>调用</h1><p>最毒瘤的地方来了！   </p>
<p>调用DLL中的函数，首先要取得这个函数的地址。<br>获取地址使用<code>GetProcAddress</code>函数。   </p>
<h2 id="GetProcAddress"><a href="#GetProcAddress" class="headerlink" title="GetProcAddress"></a>GetProcAddress</h2><h3 id="声明-2"><a href="#声明-2" class="headerlink" title="声明"></a>声明</h3><p>MSDN:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">FARPROC WINAPI <span class="title">GetProcAddress</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_ HMODULE hModule,</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_ LPCSTR  lpProcName</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="参数-2"><a href="#参数-2" class="headerlink" title="参数"></a>参数</h3><h4 id="in-hModule"><a href="#in-hModule" class="headerlink" title="[in]hModule"></a>[in]hModule</h4><p>要加载的模块句柄。   </p>
<h4 id="in-lpProcName"><a href="#in-lpProcName" class="headerlink" title="[in]lpProcName"></a>[in]lpProcName</h4><p>函数名，<strong>ANSI字符串</strong>。<br>不知道为什么没有Unicode版本……<br>Unicode转ANSI使用函数<code>WideCharToMultiByte</code><br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// szUnicode: Unicode string</span></span><br><span class="line"><span class="comment">// szANSI: ANSI string</span></span><br><span class="line">WideCharToMultiByte(CP_ACP, <span class="number">0</span>, szUnicode, _tcslen(szUnicode), szANSI, _countof(szANSI),</span><br><span class="line">	<span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure></p>
<p>还有一种使用方式，就是使用序号，像这样：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">GetProcAddress(hLib, MAKEINTRESOURCE(i));</span><br></pre></td></tr></table></figure>
<p>其中$i$为函数序号。</p>
<p><strong>MS强烈反对使用序号</strong>，所以这种用法基本不会用到。</p>
<h3 id="返回值-2"><a href="#返回值-2" class="headerlink" title="返回值"></a>返回值</h3><p>成功，返回函数地址(<code>PROC</code>类型，可自行转换)<br>失败，返回<code>NULL</code></p>
<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>先介绍一个十分毒瘤的工具，名叫<code>DumpBin</code>。<br>打开开始，找到Visual Studio 2017文件夹，点开，找到<code>VS 2017的开发人员命令提示符</code>。<br>进入要dump的文件的路径，然后像这样：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dumpbin &#x2F;exports [File]</span><br></pre></td></tr></table></figure>
<p>可以查看<code>[File]</code>文件的所有导出函数。   </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dumpbin &#x2F;imports [File]</span><br></pre></td></tr></table></figure>
<p>查看<code>[File]</code>文件的所有从外部加载的函数。   </p>
<p>输出格式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Dump of file &#123;File&#125;</span><br><span class="line"></span><br><span class="line">File Type: &#123;Type&#125;</span><br><span class="line"></span><br><span class="line">	Section contains the following exports for &#123;File&#125;</span><br><span class="line"></span><br><span class="line">    00000000			characteristics</span><br><span class="line">    FFFFFFFF			time date stamp</span><br><span class="line">        &#123;Ver&#125;			version</span><br><span class="line">        1				ordinal base</span><br><span class="line">        &#123;FuncNumber&#125;	number of functions</span><br><span class="line">        &#123;NameNumber&#125;	number of names</span><br><span class="line"></span><br><span class="line">	ordinal hint RVA      name</span><br><span class="line">	      *    *   *      &#123;Name&#125; &#x3D; @ILT+*(&#123;Name&#125;)</span><br><span class="line">	</span><br><span class="line">	Summary</span><br><span class="line"></span><br><span class="line">		...</span><br></pre></td></tr></table></figure>
<p>主要是中间的<code>ordinal~name</code>那堆东西，后面的Summary没啥用……</p>
<p>所以不要说VS装一大堆东西那么臃肿，多好用啊<br>像<code>Spy++</code>这种东西多强大啊（雾）</p>
<p>如果我们使用以前的方式编译DLL，毒瘤的编译器会修改我们的函数名，比如，我们写了一个类，包含这些：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Plugin</span> &#123;</span></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">	Plugin();</span><br><span class="line">	<span class="function">BOOL <span class="title">Load</span><span class="params">(LPCTSTR, LPTSR)</span></span>;</span><br><span class="line">	<span class="function">DWORD <span class="title">Call</span><span class="params">(LPVOID)</span></span>;</span><br><span class="line">	<span class="function">BOOL <span class="title">Destroy</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这是以前的函数名:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Plugin::Plugin();</span><br><span class="line">Plugin::Load(LPCTSTR, LPSTR);</span><br><span class="line">Plugin::Call(LPVOID);</span><br><span class="line">Plugin::Destroy();</span><br></pre></td></tr></table></figure>
<p>多么正常……<br>但是！这样编译出来的DLL是不能用<code>GetProcAddress</code>寻找函数地址的……<br>如果用DumpBin查看一下……<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">??0Plugin@@QAE@XZ &#x3D; @ILT+605(??0Plugin@@QAE@XZ)</span><br><span class="line">??4Plugin@@QAEAAV0@$$QAV0@@Z &#x3D; @ILT+110(??4Plugin@@QAEAAV0@$$QAV0@@Z)</span><br><span class="line">??4Plugin@@QAEAAV0@ABV0@@Z &#x3D; @ILT+465(??4Plugin@@QAEAAV0@ABV0@@Z)</span><br><span class="line">?Call@Plugin@@QAEKPAX@Z &#x3D; @ILT+200(?Call@Plugin@@QAEKPAX@Z)</span><br><span class="line">?Destroy@Plugin@@QAEHXZ &#x3D; @ILT+5(?Destroy@Plugin@@QAEHXZ)</span><br><span class="line">?Load@Plugin@@QAEHPA_WPAD@Z &#x3D; @ILT+225(?Load@Plugin@@QAEHPA_WPAD@Z)</span><br><span class="line">?__autoclassinit2@Plugin@@QAEXI@Z &#x3D; @ILT+355(?__autoclassinit2@Plugin@@QAEXI@Z)</span><br></pre></td></tr></table></figure><br>？？？<br>沙雕？</p>
<p>所以，我们必须强制编译器不修改我们的函数名。<br>有意思的是，C++会魔改函数名，而C不会。<br>所以我们需要强制编译器按照C的方式编译程序，像这样：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> &#123;</span><br><span class="line">	<span class="comment">// code</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>就会使大括号中的函数按照C的方式被编译，而在C中，这样又会出错（现在哪有人用C（雾）），所以需要加上预编译:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="comment">// code</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>(C++中会定义<code>__cplusplus</code>宏，而C中没有)   </p>
<p>这种操作在Windows中十分常见，Windows的每一个头文件都有这么几行。   </p>
<p>像这样，编译器只会在我们的函数名前加一个<code>_</code>，像这样:</p>
<p>前：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void Main();</span><br></pre></td></tr></table></figure>
<p>后：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Main &#x3D; @ILT+120(_Main)</span><br></pre></td></tr></table></figure>
<p>正常多了……   </p>
<h2 id="调用函数"><a href="#调用函数" class="headerlink" title="调用函数"></a>调用函数</h2><p>别急，我们还需要一步：定义我们的函数指针类型。   </p>
<p>先复习一下函数指针类型如何定义：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> [Return_Type](*[Type_Name])([Args_List]);</span><br></pre></td></tr></table></figure>
<p>如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">BOOL</span><span class="params">(*PLUGINENTRY)</span><span class="params">(LPVOID)</span></span>;</span><br></pre></td></tr></table></figure>
<p>指向一个这样的函数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">Func</span><span class="params">(LPVOID pvParam)</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>然后，将<code>GetProcAddress</code>得到的地址强制转换为这个类型，调用即可。<br>如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">BOOL</span><span class="params">(*PLUGINENTRY)</span><span class="params">(LPVOID)</span></span>;</span><br><span class="line">PROC hProc = GetProcAddress(<span class="string">"Main"</span>);</span><br><span class="line"><span class="keyword">if</span>(hProc) &#123;</span><br><span class="line">	((PLUGINENTRY)hProc)(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="其他操作"><a href="#其他操作" class="headerlink" title="其他操作"></a>其他操作</h1><h2 id="FreeLibraryAndExitThread"><a href="#FreeLibraryAndExitThread" class="headerlink" title="FreeLibraryAndExitThread"></a>FreeLibraryAndExitThread</h2><p>emmm<br>这个东西很神奇，使用之前，先来了解一下为什么会有这个函数。   </p>
<p>假设，我们在编写一个DLL，这个DLL会在被加载时，创建一个线程来完成一些任务，在线程完成任务后，卸载DLL并退出线程。<br>一般，我们可能会这么写：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">DWORD CALLBACK <span class="title">ThreadFunc</span><span class="params">(LPVOID pvParam)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">	FreeLibrary(hLib);</span><br><span class="line">	ExitThread(<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">DWORD CALLBACK <span class="title">DllMain</span><span class="params">(...)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">	HANDLE hThread = CreateThread(</span><br><span class="line">		...,</span><br><span class="line">		ThreadFunc,</span><br><span class="line">		...</span><br><span class="line">	);</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是，这样有问题。   </p>
<p>如果<code>FreeLibrary</code>直接从内存中卸载了模块，那么存在于这个模块中的当前线程函数也会被一起销毁，在内存空间中也就不存在了，然后，线程试图执行下一条，也就是一条不存在的指令，于是……</p>
<p><img src="/post_images/RE.png" alt="RE">   </p>
<p><img src="/post_images/RE_2.png" alt="RE">   </p>
<p>为了避免这种情况，MS提供了这个函数，可以卸载模块并退出线程，<code>Kernel32.dll</code>中的实现大概如下。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">VOID <span class="title">FreeLibraryAndExitThread</span><span class="params">(HMOUDLE hDll, DWORD dwExitCode)</span> </span>&#123;</span><br><span class="line">	FreeLibrary(hDll);</span><br><span class="line">	ExitThread(dwExitCode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为这两条命令都在<code>Kernel32.dll</code>中，并没有被卸载，被卸载的只是我们编写的模块，所以不会引发RE。   </p>
<h2 id="GetModuleHandle"><a href="#GetModuleHandle" class="headerlink" title="GetModuleHandle"></a>GetModuleHandle</h2><h1 id="DllMain"><a href="#DllMain" class="headerlink" title="DllMain"></a>DllMain</h1><p>和我们的程序一样，DLL也有主函数，叫<code>DllMain</code>，但是存在与否不会影响DLL的加载和调用，一般用于通知模块以正确的初始化&amp;结束。<br>显式加载和隐式加载都会调用<code>DllMain</code>。<br>一般情况下，DllMain位于<code>[ProjectName]/dllmain.cpp</code>中。   </p>
<h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">BOOL WINAPI <span class="title">DllMain</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">	HINSTANCE hDll,</span></span></span><br><span class="line"><span class="function"><span class="params">	DWORD dwReason,</span></span></span><br><span class="line"><span class="function"><span class="params">	PVOID fImpLoad)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">switch</span> (dwReason) &#123;</span><br><span class="line">		<span class="keyword">case</span> DLL_PROCESS_ATTACH: &#123;</span><br><span class="line">			<span class="comment">// The DLL is being mapped into the process' address space.</span></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">case</span> DLL_THREAD_ATTACH: &#123;</span><br><span class="line">			<span class="comment">// A thread is being created.</span></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">case</span> DLL_THREAD_DETACH: &#123;</span><br><span class="line">			<span class="comment">// A thread is exiting cleanly.</span></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">case</span> DLL_PROCESS_DETACH: &#123;</span><br><span class="line">			<span class="comment">// The DLL is being unmapped into the process' address space.</span></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> TRUE;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意大小写。不是<code>DLLMain</code>而是<code>DllMain</code>。</strong></p>
<h2 id="参数-3"><a href="#参数-3" class="headerlink" title="参数"></a>参数</h2><h3 id="hDll"><a href="#hDll" class="headerlink" title="hDll"></a>hDll</h3><p>DLL的实例句柄。   </p>
<h3 id="dwReason"><a href="#dwReason" class="headerlink" title="dwReason"></a>dwReason</h3><p>系统为何调用<code>DllMain</code>。<br>可能的值有<code>DLL_PROCESS_ATTACH</code>/<code>DLL_THREAD_ATTACH</code>/<code>DLL_PROCESS_DETACH</code>/<code>DLL_THREAD_DETACH</code>。</p>
<h4 id="DLL-PROCESS-ATTACH"><a href="#DLL-PROCESS-ATTACH" class="headerlink" title="DLL_PROCESS_ATTACH"></a>DLL_PROCESS_ATTACH</h4><p>当系统将一个DLL映射到内存(不是增加其使用计数)时，将调用<code>DllMain</code>并将<code>dwReason</code>设为该值。   </p>
<p>DLL在处理这个值时应当执行与进程相关的初始化。   </p>
<p>在隐式加载时，</p>
<h4 id="DLL-THREAD-ATTACH"><a href="#DLL-THREAD-ATTACH" class="headerlink" title="DLL_THREAD_ATTACH"></a>DLL_THREAD_ATTACH</h4><p>未完待续</p>
]]></content>
      <categories>
        <category>Windows</category>
        <category>DLL</category>
      </categories>
      <tags>
        <tag>Windows</tag>
        <tag>DLL</tag>
        <tag>中度毒瘤</tag>
      </tags>
  </entry>
  <entry>
    <title>那些毒瘤的排序算法</title>
    <url>/posts/933ca3151e976795/</url>
    <content><![CDATA[<p>排序的实现方式不少，很多，非常多……   </p>
<a id="more"></a>
<p>本文部分算法参考维基。</p>
<p>[2019/03/10] Upd: 逛维基的时候发现一堆毒瘤排序，更新<br>[2019/03/26] Upd: 逛知乎发现竟然还有更沙雕的算法，更新<br>[2019/06/22] Upd: extmool设计了一个沙雕的算法，更新</p>
<h1 id="正常点的"><a href="#正常点的" class="headerlink" title="正常点的"></a>正常点的</h1><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><h3 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h3><p>懒得说了……   </p>
<p>时间复杂度$\mathcal O(n)$ ~ $\mathcal O(n^2)$<br>平均时间复杂度$\mathcal O(n^2)$<br>空间复杂度$\mathcal O(1)$</p>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// &lt;algorithm&gt; - swap</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BubbleSort</span><span class="params">(<span class="keyword">int</span>* pnArr, <span class="keyword">int</span> nLength)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nLength; i++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; nLength - i; j++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (pnArr[j] &gt; pnArr[j + <span class="number">1</span>])</span><br><span class="line">				<span class="built_in">std</span>::swap(pnArr[j], pnArr[j + <span class="number">1</span>]);</span><br><span class="line">		&#125; </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><h3 id="基本思想-1"><a href="#基本思想-1" class="headerlink" title="基本思想"></a>基本思想</h3><p>给定长度$n$的数组$a$，循环$n-1$次，每次找出一个数并在其后面找出一个最小的数，交换。</p>
<p>时间复杂度$\mathcal O(n^2)$<br>空间复杂度$\mathcal O(1)$</p>
<h3 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// &lt;algorithm&gt; - swap()</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SelectionSort</span><span class="params">(<span class="keyword">int</span>* pnArr, <span class="keyword">int</span> nLength)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> nMin = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nLength - <span class="number">1</span>; i++) &#123;</span><br><span class="line">		nMin = i;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; nLength; j++) &#123;</span><br><span class="line">			<span class="keyword">if</span>(pnArr[nMin] &gt; pnArr[j]) &#123;</span><br><span class="line">				nMin=j;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(nMin != i) &#123;</span><br><span class="line">			<span class="built_in">std</span>::swap(pnArr[nMin], pnArr[i]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><h3 id="基本思想-2"><a href="#基本思想-2" class="headerlink" title="基本思想"></a>基本思想</h3><blockquote>
<p>快速排序使用分治法（Divide and conquer）策略来把一个序列（list）分为两个子序列（sub-lists）。<br>步骤为：   </p>
<ul>
<li>从数列中挑出一个元素，称为“基准”（pivot），   </li>
<li>重新排序数列，所有比基准值小的元素摆放在基准前面，所有比基准值大的元素摆在基准后面（相同的数可以到任何一边）。在这个分割结束之后，该基准就处于数列的中间位置。这个称为 <strong>分割（partition）</strong> 操作。</li>
<li>递归地（recursively）把小于基准值元素的子数列和大于基准值元素的子数列排序。</li>
</ul>
<p>递归到最底部时，数列的大小是零或一，也就是已经排序好了。这个算法一定会结束，因为在每次的迭代（iteration）中，它至少会把一个元素摆到它最后的位置去。   </p>
<p style="text-align: right;">–<a href="https://zh.wikipedia.org/wiki/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F" target="_blank" rel="noopener">Wikipedia</a></p>
</blockquote>
<p>时间复杂度$\mathcal O(n \log_2 n)$ ~ $\mathcal O(n^2)$<br>空间复杂度$\mathcal O(\log n)$ ~ $\mathcal O(n)$   </p>
<h3 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// &lt;algorithm&gt; - swap()</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QuickSort</span><span class="params">(<span class="keyword">int</span>* pnArr, <span class="keyword">int</span> nLeft,<span class="keyword">int</span> nRight)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i = nLeft, j = nRight;</span><br><span class="line">	<span class="keyword">int</span> k = pnArr[nLeft];</span><br><span class="line">	<span class="keyword">if</span>(i &gt;= j)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">		<span class="keyword">while</span>((i &lt; j) &amp;&amp; pnArr[j] &gt;= k)</span><br><span class="line">			j--;</span><br><span class="line">		<span class="built_in">std</span>::swap(pnArr[i], pnArr[j]);</span><br><span class="line">		<span class="keyword">while</span>((i &lt; j) &amp;&amp; (pnArr[i] &lt; k))</span><br><span class="line">			i++;</span><br><span class="line">		<span class="built_in">std</span>::swap(pnArr[i], pnArr[j]);</span><br><span class="line">	&#125;</span><br><span class="line">	QuickSort(pnArr, nLeft, i - <span class="number">1</span>);</span><br><span class="line">	QuickSort(pnArr, i + <span class="number">1</span>, nRight);</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h2><h3 id="基本思想-3"><a href="#基本思想-3" class="headerlink" title="基本思想"></a>基本思想</h3><p>对于每个数组元素$a_i$，使$tmp_{a_i}$++，按照$tmp$数组输出即可。<br>时间复杂度$\mathcal O(n)$<br>空间复杂度$\mathcal O(n + m)$<br>$m$为桶的数量。</p>
<h3 id="实现-3"><a href="#实现-3" class="headerlink" title="实现"></a>实现</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_BUCKET 100000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// &lt;algorithm&gt; - swap()</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BucketSort</span><span class="params">(<span class="keyword">int</span>* pnArr, <span class="keyword">int</span> nLength)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> *pnBucket = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">int</span> iMax = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">// Protection</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nLength; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span>(pnArr[i] &gt; MAX_BUCKET || pnArr[i] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	pnBucket = <span class="keyword">new</span> <span class="keyword">int</span>[MAX_BUCKET + <span class="number">1</span>];</span><br><span class="line">	<span class="built_in">memset</span>(pnBucket, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">int</span>) * (MAX_BUCKET + <span class="number">1</span>));</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nLength; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (iMax &lt; pnArr[i]) &#123;</span><br><span class="line">			iMax = pnArr[i];</span><br><span class="line">		&#125;</span><br><span class="line">		pnBucket[pnArr[i]]++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= iMax; i++) &#123;</span><br><span class="line">		<span class="keyword">while</span>(pnBucket[i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">			pnBucket[i]--;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">delete</span> pnBucket;</span><br><span class="line">	pnBucket = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>emmmm这个实现增加了很多避免RE的保护措施……<br>但是由于某种神奇的原因并没有用……起码在我的电脑上是这样的……   </p>
<h1 id="毒瘤I级"><a href="#毒瘤I级" class="headerlink" title="毒瘤I级"></a>毒瘤I级</h1><h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><h3 id="基本思想-4"><a href="#基本思想-4" class="headerlink" title="基本思想"></a>基本思想</h3><blockquote>
<p>原始的算法实现在最坏的情况下需要进行$\mathcal O(n^2)$的比较和交换。V. Pratt的书[1]对算法进行了少量修改，可以使得性能提升至$\mathcal O(n \log_2 n)$。这比最好的比较算法的$\mathcal O(n \log n)$要差一些。<br>希尔排序通过将比较的全部元素分为几个区域来提升插入排序的性能。这样可以让一个元素可以一次性地朝最终位置前进一大步。然后算法再取越来越小的步长进行排序，算法的最后一步就是普通的插入排序，但是到了这步，需排序的数据几乎是已排好的了（此时插入排序较快）。<br>假设有一个很小的数据在一个已按升序排好序的数组的末端。如果用复杂度为O(n2)的排序（冒泡排序或插入排序），可能会进行n次的比较和交换才能将该数据移至正确位置。而希尔排序会用较大的步长移动数据，所以小数据只需进行少数比较和交换即可到正确位置。<br>一个更好理解的希尔排序实现：将数组列在一个表中并对列排序（用插入排序）。重复这过程，不过每次用更长的列来进行。最后整个表就只有一列了。将数组转换至表是为了更好地理解这算法，算法本身仅仅对原数组进行排序（通过增加索引的步长，例如是用<code>i += step_size</code>而不是<code>i++</code>）。</p>
<p style="text-align: right;">–<a href="https://zh.wikipedia.org/wiki/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F" target="_blank" rel="noopener">Wikipedia</a></p>
</blockquote>
<p>这是啥!!!<br>时间复杂度$\mathcal O(n^{1.3})$ ~ $\mathcal O(n^2)$<br>平均时间复杂度$\mathcal O(n \log_2 n)$<br>空间复杂度$\mathcal O(1)$</p>
<h3 id="实现-4"><a href="#实现-4" class="headerlink" title="实现"></a>实现</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// &lt;algorithm&gt; - swap()</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShellSort</span><span class="params">(<span class="keyword">int</span>* pnArr, <span class="keyword">int</span> nLength)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> div = nLength / <span class="number">2</span>; div &gt;= <span class="number">1</span>; div = div / <span class="number">2</span>) &#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; div; ++i) &#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt; nLength - div; j += div) &#123;</span><br><span class="line">				<span class="keyword">for</span>(<span class="keyword">int</span> k = j; k &lt; nLength; k += div) &#123;</span><br><span class="line">					<span class="keyword">if</span>(pnArr[j] &gt; pnArr[k]) &#123;</span><br><span class="line">      						<span class="built_in">std</span>::swap(pnArr[j], pnArr[k]);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><h3 id="基本思想-5"><a href="#基本思想-5" class="headerlink" title="基本思想"></a>基本思想</h3><p>将数组塞到堆里，让堆进行排序。</p>
<p>时间复杂度$\mathcal O(n \log_2 n)$<br>空间复杂度$\mathcal O(2n)$</p>
<h3 id="实现-5"><a href="#实现-5" class="headerlink" title="实现"></a>实现</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// &lt;algorithm&gt; - swap()</span></span><br><span class="line"><span class="comment">// &lt;cstring&gt;/&lt;memory.h&gt; - memset()</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">size_t</span> MaxSize&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Heap</span> &#123;</span></span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">	  T pHeap[MaxSize];</span><br><span class="line">	  <span class="keyword">int</span> nSize;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">	Heap()&#123;</span><br><span class="line">		<span class="built_in">memset</span>(<span class="keyword">this</span>-&gt;pHeap, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">this</span>-&gt;pHeap));</span><br><span class="line">		<span class="keyword">this</span>-&gt;nSize = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	~Heap()&#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">Push</span><span class="params">(T x)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;pHeap[++<span class="keyword">this</span>-&gt;nSize] = x;</span><br><span class="line">		<span class="keyword">int</span> i = <span class="keyword">this</span>-&gt;nSize, j = i &gt;&gt; <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">while</span>(<span class="keyword">this</span>-&gt;pHeap[j] &gt; <span class="keyword">this</span>-&gt;pHeap[i] &amp;&amp; i) &#123;</span><br><span class="line">			<span class="built_in">std</span>::swap(<span class="keyword">this</span>-&gt;pHeap[i], <span class="keyword">this</span>-&gt;pHeap[j]);</span><br><span class="line">			i = j, j = i &gt;&gt; <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">Pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;pHeap[<span class="number">1</span>] = <span class="keyword">this</span>-&gt;pHeap[<span class="keyword">this</span>-&gt;nSize--];</span><br><span class="line">		<span class="keyword">int</span> n = <span class="number">1</span>, nL = <span class="number">2</span>, nR = <span class="number">3</span>;</span><br><span class="line">		<span class="keyword">while</span> ((<span class="keyword">this</span>-&gt;pHeap[n] &gt; <span class="keyword">this</span>-&gt;pHeap[nL] || <span class="keyword">this</span>-&gt;pHeap[n] &gt; <span class="keyword">this</span>-&gt;pHeap[nR]) &amp;&amp; nL &lt;= <span class="keyword">this</span>-&gt;nSize) &#123;</span><br><span class="line">			<span class="keyword">int</span> tmp = ((<span class="keyword">this</span>-&gt;pHeap[nL] &gt; <span class="keyword">this</span>-&gt;pHeap[nR]) ? nR : nL);</span><br><span class="line">			<span class="built_in">std</span>::swap(<span class="keyword">this</span>-&gt;pHeap[tmp], <span class="keyword">this</span>-&gt;pHeap[n]);</span><br><span class="line">			n = tmp, nL = n &lt;&lt; <span class="number">1</span>, nR = nL + <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">T <span class="title">Top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>-&gt;pHeap[<span class="number">1</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">Empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> !<span class="keyword">this</span>-&gt;nSize;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="毒瘤II级"><a href="#毒瘤II级" class="headerlink" title="毒瘤II级"></a>毒瘤II级</h1><h2 id="猴子排序"><a href="#猴子排序" class="headerlink" title="猴子排序"></a>猴子排序</h2><h3 id="基本思想-6"><a href="#基本思想-6" class="headerlink" title="基本思想"></a>基本思想</h3><p>检查数组是否有序，如果是，结束。如果不是，随机打乱，再检查一遍。   </p>
<p>时间复杂度:<br>运气好 + 数据良心，$\mathcal O(n)$<br>运气不好 + 数据毒瘤，$\mathcal O( \infty)$<br>平均时间复杂度$\mathcal O(n \times n!)$<br>空间复杂度$\mathcal O(1)$</p>
<p>那些编译不了的换C++11  </p>
<h3 id="实现-6"><a href="#实现-6" class="headerlink" title="实现"></a>实现</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// &lt;algorithm&gt; - is_sorted() &amp; random_shuffle()</span></span><br><span class="line"><span class="comment">// &lt;ctime&gt; - time()</span></span><br><span class="line"><span class="comment">// &lt;cstdlib&gt; - srand()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Note: is_sorted() is not supported before C++11.</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BogoSort</span><span class="params">(<span class="keyword">int</span>* pnArr, <span class="keyword">int</span> nLength)</span> </span>&#123;</span><br><span class="line">	srand((<span class="keyword">unsigned</span>)time(<span class="literal">NULL</span>));</span><br><span class="line">	<span class="keyword">while</span>(!is_sorted(pnArr, pnArr + nLength)) &#123;</span><br><span class="line">		random_shuffle(pnArr, pnArr + nLength);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="臭皮匠排序"><a href="#臭皮匠排序" class="headerlink" title="臭皮匠排序"></a>臭皮匠排序</h2><p>妈耶这个沙雕的名字……   </p>
<blockquote>
<p>该算法得名于三个臭皮匠，每个臭皮匠都打其他两个</p>
<p style="text-align: right">–<a href="https://zh.wikipedia.org/wiki/%E8%87%AD%E7%9A%AE%E5%8C%A0%E6%8E%92%E5%BA%8F" target="_blank" rel="noopener">Wikipedia</a></p>
</blockquote>
<h3 id="基本思想-7"><a href="#基本思想-7" class="headerlink" title="基本思想"></a>基本思想</h3><blockquote>
<p>如果最后一个值小于第一个值，则交换这两个数<br>如果当前集合元素数量大于等于3：   </p>
<ul>
<li>使用臭皮匠排序前2/3的元素</li>
<li>使用臭皮匠排序后2/3的元素</li>
<li>再次使用臭皮匠排序前2/3的元素</li>
</ul>
<p style="text-align: right">–<a href="https://zh.wikipedia.org/wiki/%E8%87%AD%E7%9A%AE%E5%8C%A0%E6%8E%92%E5%BA%8F" target="_blank" rel="noopener">Wikipedia</a></p>
</blockquote>
<p>时间复杂度$\mathcal O(n^{\log(3) \over \log(1.5)})$ ~ $\mathcal O(n^{2.7})$<br>空间复杂度$\mathcal O(1)$</p>
<h3 id="实现-7"><a href="#实现-7" class="headerlink" title="实现"></a>实现</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">StoogeSort</span><span class="params">(<span class="keyword">int</span>* pnArr, <span class="keyword">int</span> iL, <span class="keyword">int</span> iR)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (pnArr[iR] &lt; pnArr[iL]) &#123;</span><br><span class="line">		<span class="built_in">std</span>::swap(pnArr[iL], pnArr[iR]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (iR - iL + <span class="number">1</span> &gt;= <span class="number">3</span>) &#123;</span><br><span class="line">		<span class="keyword">int</span> t = (iR - iL + <span class="number">1</span>) / <span class="number">3</span>;</span><br><span class="line">		StoogeSort(pnArr, iL, iR - t);</span><br><span class="line">		StoogeSort(pnArr, iL + t, iR);</span><br><span class="line">		StoogeSort(pnArr, iL, iR - t);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="鸡尾酒排序"><a href="#鸡尾酒排序" class="headerlink" title="鸡尾酒排序"></a>鸡尾酒排序</h2><h3 id="基本思想-8"><a href="#基本思想-8" class="headerlink" title="基本思想"></a>基本思想</h3><blockquote>
<p>鸡尾酒排序等于是冒泡排序的轻微变形。不同的地方在于从低到高然后从高到低，而冒泡排序则仅从低到高去比较序列里的每个元素。他可以得到比冒泡排序稍微好一点的性能，原因是冒泡排序只从一个方向进行比对（由低到高），每次循环只移动一个项目。   </p>
<p style="text-align: right;">–<a href="https://zh.wikipedia.org/wiki/%E9%B8%A1%E5%B0%BE%E9%85%92%E6%8E%92%E5%BA%8F" target="_blank" rel="noopener">Wikipedia</a></p>
</blockquote>
<h3 id="实现-8"><a href="#实现-8" class="headerlink" title="实现"></a>实现</h3><p>代码魔改于<a href="https://zh.wikipedia.org/wiki/%E9%B8%A1%E5%B0%BE%E9%85%92%E6%8E%92%E5%BA%8F" target="_blank" rel="noopener">Wikipedia-鸡尾酒排序</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CocktailSort</span><span class="params">(<span class="keyword">int</span>* pnArr, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> j, left = <span class="number">0</span>, right = len - <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">		<span class="keyword">for</span> (j = left; j &lt; right; j++)</span><br><span class="line">			<span class="keyword">if</span> (pnArr[j] &gt; pnArr[j + <span class="number">1</span>])</span><br><span class="line">				swap(pnArr[j], pnArr[j + <span class="number">1</span>]);</span><br><span class="line">		right--;</span><br><span class="line">		<span class="keyword">for</span> (j = right; j &gt; left; j--)</span><br><span class="line">			<span class="keyword">if</span> (pnArr[j - <span class="number">1</span>] &gt; pnArr[j])</span><br><span class="line">				swap(pnArr[j - <span class="number">1</span>], pnArr[j]);</span><br><span class="line">		left++;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="毒瘤III级"><a href="#毒瘤III级" class="headerlink" title="毒瘤III级"></a>毒瘤III级</h1><div class="note danger">前方高能！</div>

<h2 id="睡眠排序"><a href="#睡眠排序" class="headerlink" title="睡眠排序"></a>睡眠排序</h2><h3 id="基本思想-9"><a href="#基本思想-9" class="headerlink" title="基本思想"></a>基本思想</h3><p>给定长度$n$的数组$a$，创建$n$个线程，分别睡眠$a_i ms$，被唤醒时将$a_i$输出即可，主线程等待各线程结束。<br>为了让结果精准，创建线程时即挂起，统一恢复。</p>
<p>从知乎上看到的……而且这个算法在知乎上广为流传……   </p>
<p>毒瘤啊！！！   </p>
<p>很明显，不允许存在负数。<br>很明显，数据越大，排序越精准。<br>在无法接收线程返回值时，只能输出有序数列，不能对数组排序。</p>
<p>时间复杂度未知<br>空间复杂度未知   </p>
<p>在增量较小时输出可能出现错序，如:</p>
<p>Input<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">10</span><br><span class="line">3 2 6 5 1 4 7 8 9 10</span><br></pre></td></tr></table></figure></p>
<p>Output<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 2 3 4 5 6 7 8 9 10</span><br></pre></td></tr></table></figure></p>
<p>可能的输出：<br>#1<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 2 3 4 5 6 7 89  10</span><br></pre></td></tr></table></figure><br>#2<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2 1 3 4 5 6 7 8 9 10</span><br></pre></td></tr></table></figure></p>
<h3 id="实现-9"><a href="#实现-9" class="headerlink" title="实现"></a>实现</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// &lt;Windows.h&gt; - Sleep() &amp; *Thread() &amp; WaitForMultipleObjects() &amp; CloseHandle()</span></span><br><span class="line"><span class="comment">// &lt;cstdio&gt; - putchar()</span></span><br><span class="line"><span class="function">DWORD CALLBACK <span class="title">SleepThread</span><span class="params">(LPVOID pvParam)</span> </span>&#123;</span><br><span class="line">	Sleep((DWORD)pvParam);</span><br><span class="line">	FastIO::Put((<span class="keyword">int</span>)pvParam);	<span class="comment">// Or use cout or printf</span></span><br><span class="line">	<span class="built_in">putchar</span>(<span class="string">' '</span>);</span><br><span class="line">	<span class="keyword">return</span> (DWORD)pvParam;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SleepSort</span><span class="params">(<span class="keyword">int</span>* pnArr, <span class="keyword">int</span> nLength)</span> </span>&#123;</span><br><span class="line">	DWORD dwThreadId[<span class="number">1001</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">	HANDLE hThread[<span class="number">1001</span>] = &#123; <span class="literal">NULL</span> &#125;;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nLength; i++) <span class="keyword">if</span> (pnArr[i] &lt; <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nLength; i++) 	<span class="comment">// Create suspended thread</span></span><br><span class="line">		hThread[i] = CreateThread(<span class="literal">NULL</span>, <span class="number">0</span>, SleepThread, (LPVOID)pnArr[i],</span><br><span class="line">			CREATE_SUSPENDED, &amp;dwThreadId[i]);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nLength; i++) 	<span class="comment">// Resume suspended thread</span></span><br><span class="line">		ResumeThread(hThread[i]);</span><br><span class="line"></span><br><span class="line">	WaitForMultipleObjects(nLength, hThread, TRUE, INFINITE);</span><br><span class="line">	<span class="comment">// Wait for thread to quit</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nLength; i++) &#123;</span><br><span class="line">		CloseHandle(hThread[i]);</span><br><span class="line">		hThread[i] = <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="太阳能比特翻转排序"><a href="#太阳能比特翻转排序" class="headerlink" title="太阳能比特翻转排序"></a>太阳能比特翻转排序</h2><h3 id="基本思想-10"><a href="#基本思想-10" class="headerlink" title="基本思想"></a>基本思想</h3><p><del>HandwerSTD</del>太阳发出的$\alpha$粒子偶尔能够反转内存中的比特位……   </p>
<ol>
<li>检查数组是否有序，如果是，退出。</li>
<li>等10秒并祈祷<del>HandwerSTD</del>太阳发出的辐射能使某一比特翻转，而且使得数组排好序，goto 1。</li>
</ol>
<p>时间复杂度接近$\mathcal O(\infty)$<br>空间复杂度$\mathcal O(1)$   </p>
<p>终于找到比猴排还慢的排序了（雾  </p>
<p>同样，<code>is_sorted</code>需要C++11。</p>
<p><del>靠近HandwerSTD以取得更加效果</del></p>
<h3 id="实现-10"><a href="#实现-10" class="headerlink" title="实现"></a>实现</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// &lt;algorithm&gt; - is_sorted()</span></span><br><span class="line"><span class="comment">// &lt;Windows.h&gt; - Sleep()</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SunSort</span><span class="params">(<span class="keyword">int</span>* pnArr, <span class="keyword">int</span> iLength)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(!is_sorted(pnArr, pnArr + iLength))</span><br><span class="line">		Sleep(<span class="number">10000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="extmool排序"><a href="#extmool排序" class="headerlink" title="extmool排序"></a>extmool排序</h2><h3 id="基本思想-11"><a href="#基本思想-11" class="headerlink" title="基本思想"></a>基本思想</h3><p>给定数组$a_i$，每次找出最大值，将其余的砍掉，最大值加入队列，将砍掉的继续上述操作，如此递归，直到$a.\text{size()} = 1$。</p>
<h3 id="实现-11"><a href="#实现-11" class="headerlink" title="实现"></a>实现</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// &lt;vector&gt; - vector&lt;&gt;</span></span><br><span class="line"><span class="comment">// &lt;queue&gt; - queue&lt;&gt;</span></span><br><span class="line"><span class="comment">// &lt;algorithm&gt; - max_element()</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">extmoolSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v, <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt;&amp; q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (v.size() == <span class="number">1</span>) &#123;</span><br><span class="line">        q.push(v[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator maxe = max_element(v.begin(), v.end());</span><br><span class="line">    q.push(*maxe);</span><br><span class="line">    v.erase(maxe);</span><br><span class="line">    extmoolSort(v, q);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="沙雕排序"><a href="#沙雕排序" class="headerlink" title="沙雕排序"></a>沙雕排序</h1><p>以下算法从网络中采集   </p>
<p>无法用代码实现   </p>
<p>简直沙雕的一批</p>
<h2 id="指鹿为马排序"><a href="#指鹿为马排序" class="headerlink" title="指鹿为马排序"></a>指鹿为马排序</h2><h3 id="基本思想-12"><a href="#基本思想-12" class="headerlink" title="基本思想"></a>基本思想</h3><p>聚集一帮人，向他们展示待排序数组，询问他们是否为排序好的，弄死其中认为没有排序好的，重复几次，直到所有人都认为是排序好的。   </p>
<p>（PS：使用本算法所产生的后果，本人概不负责）</p>
<h2 id="互联网排序"><a href="#互联网排序" class="headerlink" title="互联网排序"></a>互联网排序</h2><h3 id="实现-12"><a href="#实现-12" class="headerlink" title="实现"></a>实现</h3><p>类似于冒泡，但每一次都依赖于互联网，如”1和2哪个大?”   </p>
]]></content>
      <categories>
        <category>C++</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>极致毒瘤</tag>
      </tags>
  </entry>
  <entry>
    <title>各种神奇写法耗时对比</title>
    <url>/posts/e7a29b6fc6d89ed3/</url>
    <content><![CDATA[<p>把以前的那篇文章整合进来顺便加一些其他的qwq   </p>
<a id="more"></a>
<h1 id="测试环境"><a href="#测试环境" class="headerlink" title="测试环境"></a>测试环境</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> movetoex@MoveToEx-PC  ~  screenfetch</span><br><span class="line">awk: fatal: cannot open file &#96;&#x2F;proc&#x2F;fb&#39; for reading (No such file or directory)</span><br><span class="line">                          .&#x2F;+o+-       movetoex@MoveToEx-PC</span><br><span class="line">                  yyyyy- -yyyyyy+      OS: Ubuntu 18.04 bionic [Ubuntu on Windows 10]</span><br><span class="line">               :&#x2F;&#x2F;+&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;-yyyyyyo      Kernel: x86_64 Linux 4.4.0-17763-Microsoft</span><br><span class="line">           .++ .:&#x2F;++++++&#x2F;-.+sss&#x2F;&#96;      Uptime: 14m</span><br><span class="line">         .:++o:  &#x2F;++++++++&#x2F;:--:&#x2F;-      Packages: 559</span><br><span class="line">        o:+o+:++.&#96;..&#96;&#96;&#96;.-&#x2F;oo+++++&#x2F;     Shell: zsh 5.4.2</span><br><span class="line">       .:+o:+o&#x2F;.          &#96;+sssoo+&#x2F;    CPU: Intel Core i5-7200U @ 4x 2.701GHz</span><br><span class="line">  .++&#x2F;+:+oo+o:&#96;             &#x2F;sssooo.   GPU:</span><br><span class="line"> &#x2F;+++&#x2F;&#x2F;+:&#96;oo+o               &#x2F;::--:.   RAM: 4523MiB &#x2F; 8035MiB</span><br><span class="line"> \+&#x2F;+o+++&#96;o++o               ++&#x2F;&#x2F;&#x2F;&#x2F;.</span><br><span class="line">  .++.o+++oo+:&#96;             &#x2F;dddhhh.</span><br><span class="line">       .+.o+oo:.          &#96;oddhhhh+</span><br><span class="line">        \+.++o+o&#96;&#96;-&#96;&#96;&#96;&#96;.:ohdhhhhh+</span><br><span class="line">         &#96;:o+++ &#96;ohhhhhhhhyo++os:</span><br><span class="line">           .o:&#96;.syhhhhhhh&#x2F;.oo++o&#96;</span><br><span class="line">               &#x2F;osyyyyyyo++ooo+++&#x2F;</span><br><span class="line">                   &#96;&#96;&#96;&#96;&#96; +oo+++o\:</span><br><span class="line">                          &#96;oo++.</span><br></pre></td></tr></table></figure>
<h1 id="读取-amp-写入"><a href="#读取-amp-写入" class="headerlink" title="读取 &amp; 写入"></a>读取 &amp; 写入</h1><p>字符串:<code>&quot;1&quot;</code><br>读写次数:$10^8$</p>
<h2 id="读取文件"><a href="#读取文件" class="headerlink" title="读取文件"></a>读取文件</h2><h3 id="1"><a href="#1" class="headerlink" title="#1"></a>#1</h3><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> tmp = <span class="number">0</span>;</span><br><span class="line">	<span class="function">ifstream <span class="title">f</span><span class="params">(<span class="string">"test.in"</span>)</span></span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1e8</span>; i++) &#123;</span><br><span class="line">		f &gt;&gt; tmp;</span><br><span class="line">	&#125;</span><br><span class="line">	f.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h4><p>$4871ms$</p>
<h3 id="2"><a href="#2" class="headerlink" title="#2"></a>#2</h3><h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> tmp = <span class="number">0</span>;</span><br><span class="line">	FILE* fp = fopen(<span class="string">"test.in"</span>, <span class="string">"r"</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1e8</span>; i++) &#123;</span><br><span class="line">		<span class="built_in">fscanf</span>(fp, <span class="string">"%d"</span>, &amp;tmp);</span><br><span class="line">	&#125;</span><br><span class="line">	fclose(fp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="结果-1"><a href="#结果-1" class="headerlink" title="结果"></a>结果</h4><p>$5728ms$</p>
<h3 id="3"><a href="#3" class="headerlink" title="#3"></a>#3</h3><h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> tmp = <span class="number">0</span>;</span><br><span class="line">	freopen(<span class="string">"test.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1e8</span>; i++) &#123;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; tmp;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="结果-2"><a href="#结果-2" class="headerlink" title="结果"></a>结果</h4><p>$11349ms$</p>
<h3 id="4"><a href="#4" class="headerlink" title="#4"></a>#4</h3><h4 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> tmp = <span class="number">0</span>;</span><br><span class="line">	ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">	freopen(<span class="string">"test.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1e8</span>; i++) &#123;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; tmp;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="结果-3"><a href="#结果-3" class="headerlink" title="结果"></a>结果</h4><p>$5183ms$</p>
<h3 id="5"><a href="#5" class="headerlink" title="#5"></a>#5</h3><h4 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> tmp = <span class="number">0</span>;</span><br><span class="line">	freopen(<span class="string">"test.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1e8</span>; i++) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;tmp);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="结果-4"><a href="#结果-4" class="headerlink" title="结果"></a>结果</h4><p>$5425ms$</p>
<h3 id="6"><a href="#6" class="headerlink" title="#6"></a>#6</h3><h4 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h4><p>快读如果写错了还请大佬见谅QAQ   </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">geti</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">bool</span> f = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">char</span> c = getchar();</span><br><span class="line">	<span class="keyword">while</span>(!<span class="built_in">isdigit</span>(c))&#123; </span><br><span class="line">		<span class="keyword">if</span>(c == <span class="string">'-'</span>) f = <span class="number">1</span>;</span><br><span class="line">		 c = getchar();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">isdigit</span>(c)) </span><br><span class="line">		ans = ans * <span class="number">10</span> + c - <span class="string">'0'</span>, c = getchar();</span><br><span class="line">	<span class="keyword">return</span> ((f == <span class="literal">true</span>) ? -ans : ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	freopen(<span class="string">"test.out"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1e8</span>; i++) &#123;</span><br><span class="line">		geti();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="结果-5"><a href="#结果-5" class="headerlink" title="结果"></a>结果</h4><p>$1184ms$</p>
<h2 id="写入文件"><a href="#写入文件" class="headerlink" title="写入文件"></a>写入文件</h2><h3 id="1-1"><a href="#1-1" class="headerlink" title="#1"></a>#1</h3><h4 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Write</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="function">ofstream <span class="title">f</span><span class="params">(<span class="string">"test.out"</span>)</span></span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1e8</span>; i++) &#123;</span><br><span class="line">		f &lt;&lt; <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	f.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="结果-6"><a href="#结果-6" class="headerlink" title="结果"></a>结果</h4><p>$4036ms$</p>
<h3 id="2-1"><a href="#2-1" class="headerlink" title="#2"></a>#2</h3><h4 id="代码-7"><a href="#代码-7" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Write</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	FILE* fp = fopen(<span class="string">"test.out"</span>, <span class="string">"w"</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1e8</span>; i++) &#123;</span><br><span class="line">		<span class="built_in">fprintf</span>(fp, <span class="string">"%d"</span>, <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	fclose(fp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="结果-7"><a href="#结果-7" class="headerlink" title="结果"></a>结果</h4><p>$6035ms$</p>
<h3 id="3-1"><a href="#3-1" class="headerlink" title="#3"></a>#3</h3><h4 id="代码-8"><a href="#代码-8" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Write</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	freopen(<span class="string">"test.out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1e8</span>; i++) &#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="结果-8"><a href="#结果-8" class="headerlink" title="结果"></a>结果</h4><p>$5958ms$</p>
<h3 id="4-1"><a href="#4-1" class="headerlink" title="#4"></a>#4</h3><h4 id="代码-9"><a href="#代码-9" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Write</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">	freopen(<span class="string">"test.out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1e8</span>; i++) &#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="结果-9"><a href="#结果-9" class="headerlink" title="结果"></a>结果</h4><p>$4199ms$</p>
<h3 id="5-1"><a href="#5-1" class="headerlink" title="#5"></a>#5</h3><h4 id="代码-10"><a href="#代码-10" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Write</span><span class="params">()</span></span>&#123;</span><br><span class="line">	freopen(<span class="string">"test.out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1e8</span>; i++) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d"</span>, <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="结果-10"><a href="#结果-10" class="headerlink" title="结果"></a>结果</h4><p>$7626ms$</p>
<h3 id="6-1"><a href="#6-1" class="headerlink" title="#6"></a>#6</h3><h4 id="代码-11"><a href="#代码-11" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">puti</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(i &gt;= <span class="number">10</span>) puti(i / <span class="number">10</span>);</span><br><span class="line">	<span class="built_in">putchar</span>(i % <span class="number">10</span> + <span class="string">'0'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Write</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	freopen(<span class="string">"test.out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1e8</span>; i++) &#123;</span><br><span class="line">		puti(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="结果-11"><a href="#结果-11" class="headerlink" title="结果"></a>结果</h4><p>$1933ms$</p>
<h1 id="复制字符串"><a href="#复制字符串" class="headerlink" title="复制字符串"></a>复制字符串</h1><p>测试次数: $10^8$<br>测试数据:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> _Src[<span class="number">101</span>] = <span class="string">"MoveToEx is juruo"</span>, _Dest[<span class="number">101</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> _Len = <span class="number">17</span></span><br></pre></td></tr></table></figure></p>
<h2 id="1-2"><a href="#1-2" class="headerlink" title="#1"></a>#1</h2><h3 id="代码-12"><a href="#代码-12" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">StringCopy</span><span class="params">(<span class="keyword">char</span>* _Dest, <span class="keyword">char</span>* _Src)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="built_in">strlen</span>(_Src); i++) &#123;</span><br><span class="line">		_Dest[i] = _Src[i];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="结果-12"><a href="#结果-12" class="headerlink" title="结果"></a>结果</h3><p>$19239ms(19.239s)$   </p>
<p>测的时候还以为死循环了……<br>差点<code>^C</code>了……   </p>
<h2 id="2-2"><a href="#2-2" class="headerlink" title="#2"></a>#2</h2><h3 id="代码-13"><a href="#代码-13" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">StringCopy</span><span class="params">(<span class="keyword">char</span>* _Dest, <span class="keyword">char</span>* _Src)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> len = <span class="built_in">strlen</span>(_Src);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= l; i++) &#123;</span><br><span class="line">		_Dest[i] = _Src[i];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="结果-13"><a href="#结果-13" class="headerlink" title="结果"></a>结果</h3><p>$4480ms$</p>
<h2 id="3-2"><a href="#3-2" class="headerlink" title="#3"></a>#3</h2><h3 id="代码-14"><a href="#代码-14" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">StringCopy</span><span class="params">(<span class="keyword">char</span>* _Dest, <span class="keyword">char</span>* _Src)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; _Src[i]; i++) &#123;</span><br><span class="line">		_Dest[i] = _Src[i];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="结果-14"><a href="#结果-14" class="headerlink" title="结果"></a>结果</h3><p>$4891ms$   </p>
<h2 id="4-2"><a href="#4-2" class="headerlink" title="#4"></a>#4</h2><h3 id="代码-15"><a href="#代码-15" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">StringCopy</span><span class="params">(<span class="keyword">char</span>* _Dest, <span class="keyword">char</span>* _Src)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(_Src[i++]) &#123;</span><br><span class="line">		_Dest[i] = _Src[i];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="结果-15"><a href="#结果-15" class="headerlink" title="结果"></a>结果</h3><p>$5129ms$   </p>
<p>???</p>
<h2 id="5-2"><a href="#5-2" class="headerlink" title="#5"></a>#5</h2><h3 id="代码-16"><a href="#代码-16" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">StringCopy</span><span class="params">(<span class="keyword">char</span>* _Dest, <span class="keyword">char</span>* _Src, <span class="keyword">int</span> _Len)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">memcpy</span>(_Src, _Dest, <span class="keyword">sizeof</span>(<span class="keyword">char</span>) * _Len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="结果-16"><a href="#结果-16" class="headerlink" title="结果"></a>结果</h3><p>$453ms$<br>??????????????????????</p>
<h2 id="6-2"><a href="#6-2" class="headerlink" title="#6"></a>#6</h2><h3 id="代码-17"><a href="#代码-17" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">StringCopy</span><span class="params">(<span class="keyword">char</span>* _Dest, <span class="keyword">char</span>* _Src)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(_Dest[i] = _Src[i]) i++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="结果-17"><a href="#结果-17" class="headerlink" title="结果"></a>结果</h3><p>$5604ms$   </p>
<h2 id="7"><a href="#7" class="headerlink" title="#7"></a>#7</h2><h3 id="代码-18"><a href="#代码-18" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">StringCopy</span><span class="params">(<span class="keyword">char</span>* _Dest, <span class="keyword">char</span>* _Src)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(*(_Dest++) = *(_Src++));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="结果-18"><a href="#结果-18" class="headerlink" title="结果"></a>结果</h3><p>$4524ms$   </p>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>OI</tag>
        <tag>玄学</tag>
      </tags>
  </entry>
  <entry>
    <title>va_list的使用</title>
    <url>/posts/4793824e43f0d087/</url>
    <content><![CDATA[<p><code>va_list</code>用于接收函数的可变参数，<code>printf</code>之类的用于输入输出的函数经常使用可变参数列表。如<code>printf</code>的定义：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">_Check_return_opt_ </span><br><span class="line"><span class="function">_CRT_STDIO_INLINE <span class="keyword">int</span> __CRTDECL <span class="title">printf</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">	_In_z_ _Printf_format_string_ <span class="keyword">char</span> <span class="keyword">const</span>* <span class="keyword">const</span> _Format,</span></span></span><br><span class="line"><span class="function"><span class="params">	...)</span></span>;</span><br></pre></td></tr></table></figure>
<p>简化：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __cdecl <span class="title">printf</span><span class="params">(<span class="keyword">char</span> <span class="keyword">const</span>* _Format, ...)</span></span>;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h1 id="va-list是什么"><a href="#va-list是什么" class="headerlink" title="va_list是什么"></a>va_list是什么</h1><p><code>va_list</code>是位于<code>&lt;stdarg.h&gt;</code>(<code>&lt;cstdarg&gt;</code> for C++)中的一个类型，通常情况下，它被定义为<code>char*</code>。如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span>* va_list;</span><br></pre></td></tr></table></figure>
<p>它可以指向一个地址，通过指针运算得到下一个参数的地址，然后将类型强制转换为参数的类型。</p>
<h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p>首先，获取第一个可变参数的地址：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">va_list args;</span><br><span class="line">va_start(args,<span class="comment">/*可变参数前的最后一个参数*/</span>);</span><br></pre></td></tr></table></figure>
<p>然后，使用如下方式获取每一个参数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">&lt;Type&gt; tmp = va_arg(args, &lt;Type&gt;);</span><br></pre></td></tr></table></figure>
<p>使用完后，使用下列代码将va_list置零：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">va_end(args);</span><br></pre></td></tr></table></figure>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdarg&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Sum</span><span class="params">(<span class="keyword">int</span> iCount, ...)</span> </span>&#123;</span><br><span class="line">	va_list args;</span><br><span class="line">	<span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">	va_start(args, iCount);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; iCount; i++) &#123;</span><br><span class="line">		ans += va_arg(args, <span class="keyword">int</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	va_end(args);</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="built_in">cout</span> &lt;&lt; Sum(<span class="number">10</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>在使用<code>va_list</code>的时候，一定要指定一个参数或者通过某些特殊途径获取可变参数的个数，像<code>printf</code>系列函数可以通过统计字符串中<code>&#39;%&#39;</code>的个数及后面的字符获取参数的个数及类型。否则程序就不知道应该获取多少个可变参数，RE当然也不是什么稀奇的事。</p>
<h1 id="将字符串中格式符替换为参数"><a href="#将字符串中格式符替换为参数" class="headerlink" title="将字符串中格式符替换为参数"></a>将字符串中格式符替换为参数</h1><p>实际上如果像<code>sprintf</code>那样只是将可变参数替换到带<code>%d</code>等格式符的字符串中，我们可以使用专用于将<code>va_list</code>中的可变参数列表替换到字符串中的函数。一般使用<code>_vstprintf(_s)</code>。<br><code>*_s</code>函数是安全字符串函数，可以避免因为某种特殊原因而导致内存泄露，比如在<code>strcpy</code>的<code>_Desc</code>(用于接收)内存空间不足以容纳<code>_Src</code>(源字符串)时。<br>如果用的好，我们甚至可以手写<code>printf</code>函数神马的……</p>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>MSDN:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">vsprintf</span><span class="params">(  </span></span></span><br><span class="line"><span class="function"><span class="params">   <span class="keyword">char</span> *buffer,  </span></span></span><br><span class="line"><span class="function"><span class="params">   <span class="keyword">const</span> <span class="keyword">char</span> *format,  </span></span></span><br><span class="line"><span class="function"><span class="params">   va_list argptr   </span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">vswprintf</span><span class="params">(  </span></span></span><br><span class="line"><span class="function"><span class="params">   <span class="keyword">wchar_t</span> *buffer,  </span></span></span><br><span class="line"><span class="function"><span class="params">   <span class="keyword">size_t</span> count,  </span></span></span><br><span class="line"><span class="function"><span class="params">   <span class="keyword">const</span> <span class="keyword">wchar_t</span> *format,  </span></span></span><br><span class="line"><span class="function"><span class="params">   va_list argptr   </span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">size_t</span> size&gt;  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">vsprintf_s</span><span class="params">(  </span></span></span><br><span class="line"><span class="function"><span class="params">   <span class="keyword">char</span> (&amp;buffer)[size],  </span></span></span><br><span class="line"><span class="function"><span class="params">   <span class="keyword">const</span> <span class="keyword">char</span> *format,  </span></span></span><br><span class="line"><span class="function"><span class="params">   va_list argptr   </span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">size_t</span> size&gt;  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">vswprintf_s</span><span class="params">(  </span></span></span><br><span class="line"><span class="function"><span class="params">   <span class="keyword">wchar_t</span> (&amp;buffer)[size],  </span></span></span><br><span class="line"><span class="function"><span class="params">   <span class="keyword">const</span> <span class="keyword">wchar_t</span> *format,  </span></span></span><br><span class="line"><span class="function"><span class="params">   va_list argptr   </span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>
<p>注：在Unicode下<code>_vstprintf(_s)</code>为<code>vswprintf(_s)</code>，ANSI下<code>vsprintf(_s)</code>。<br><code>vs(w)printf(_s)</code>的<code>template</code>可以由编译器自动填充，无需特别指定。</p>
<p>Visual Studio 2017 - correct_wstdio.h:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">_Success_(<span class="keyword">return</span> &gt;= <span class="number">0</span>)</span><br><span class="line"><span class="function">_CRT_STDIO_INLINE <span class="keyword">int</span> __CRTDECL <span class="title">vswprintf_s</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">_Out_writes_(_BufferCount) _Always_(_Post_z_)	<span class="keyword">wchar_t</span>*       <span class="keyword">const</span> _Buffer,</span></span></span><br><span class="line"><span class="function"><span class="params">_In_											<span class="keyword">size_t</span>         <span class="keyword">const</span> _BufferCount,</span></span></span><br><span class="line"><span class="function"><span class="params">_In_z_ _Printf_format_string_					<span class="keyword">wchar_t</span> <span class="keyword">const</span>* <span class="keyword">const</span> _Format,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                va_list              _ArgList</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C++"</span> _SWPRINTFS_DEPRECATED _CRT_INSECURE_DEPRECATE(vswprintf_s)</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> __CRTDECL <span class="title">vswprintf</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    _Pre_notnull_ _Post_z_			<span class="keyword">wchar_t</span>*       <span class="keyword">const</span> _Buffer,</span></span></span><br><span class="line"><span class="function"><span class="params">    _In_z_ _Printf_format_string_	<span class="keyword">wchar_t</span> <span class="keyword">const</span>* <span class="keyword">const</span> _Format,</span></span></span><br><span class="line"><span class="function"><span class="params">                                	va_list              _ArgList</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br><span class="line">_Success_(<span class="keyword">return</span> &gt;= <span class="number">0</span>)</span><br><span class="line">_Check_return_opt_</span><br><span class="line"><span class="function">_CRT_STDIO_INLINE <span class="keyword">int</span> __CRTDECL <span class="title">vsprintf_s</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    _Out_writes_(_BufferCount) _Always_(_Post_z_)	<span class="keyword">char</span>*       <span class="keyword">const</span> _Buffer,</span></span></span><br><span class="line"><span class="function"><span class="params">    _In_											<span class="keyword">size_t</span>      <span class="keyword">const</span> _BufferCount,</span></span></span><br><span class="line"><span class="function"><span class="params">    _In_z_ _Printf_format_string_					<span class="keyword">char</span> <span class="keyword">const</span>* <span class="keyword">const</span> _Format,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                	va_list           _ArgList</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br><span class="line">_Success_(<span class="keyword">return</span> &gt;= <span class="number">0</span>)</span><br><span class="line">_Check_return_opt_ _CRT_INSECURE_DEPRECATE(vsprintf_s)</span><br><span class="line"><span class="function">_CRT_STDIO_INLINE <span class="keyword">int</span> __CRTDECL <span class="title">vsprintf</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    _Pre_notnull_ _Always_(_Post_z_)	<span class="keyword">char</span>*       <span class="keyword">const</span> _Buffer,</span></span></span><br><span class="line"><span class="function"><span class="params">    _In_z_ _Printf_format_string_		<span class="keyword">char</span> <span class="keyword">const</span>* <span class="keyword">const</span> _Format,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    	va_list           _ArgList</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>
<p>毒瘤依旧。<br>不过好像不是很全，这些东西好像有重载的来的……   </p>
<h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><h3 id="out-buffer-or-Buffer"><a href="#out-buffer-or-Buffer" class="headerlink" title="[out]buffer or _Buffer"></a>[out]buffer <em>or</em> _Buffer</h3><p>指定用于接收的内存空间。</p>
<h3 id="in-count-or-BufferCount"><a href="#in-count-or-BufferCount" class="headerlink" title="[in]count or _BufferCount"></a>[in]count <em>or</em> _BufferCount</h3><p>指定<code>buffer</code> <em>or</em> <code>_Buffer</code>的最大写入大小，一般设为<code>_countof(buffer)</code>。</p>
<h3 id="in-format-or-Format"><a href="#in-format-or-Format" class="headerlink" title="[in]format or _Format"></a>[in]format <em>or</em> _Format</h3><p>含<code>%d</code>等标志的格式字符串。</p>
<h3 id="argptr-or-ArgList"><a href="#argptr-or-ArgList" class="headerlink" title="argptr or _ArgList"></a>argptr <em>or</em> _ArgList</h3><p>指定可变参数列表。</p>
<p>通常情况下，先声明一个<code>char</code>(<em>or</em> <code>wchar_t</code>)的数组，然后将这个数组、指定个数的数字、格式字符串以及<code>va_list</code>一起传入函数。</p>
<h2 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MessageBoxArgW</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    _In_opt_ HWND hWnd,</span></span></span><br><span class="line"><span class="function"><span class="params">    _In_ LPWSTR lpText,</span></span></span><br><span class="line"><span class="function"><span class="params">    _In_ LPWSTR lpCaption,</span></span></span><br><span class="line"><span class="function"><span class="params">    _In_ UINT uType,</span></span></span><br><span class="line"><span class="function"><span class="params">    ...</span></span></span><br><span class="line"><span class="function"><span class="params">)</span> </span>&#123;</span><br><span class="line">    va_list args;</span><br><span class="line">    va_start(args, uType);</span><br><span class="line">    <span class="keyword">int</span> iReturn = <span class="number">0</span>;</span><br><span class="line">    vswprintf(lpText, lpText, args);</span><br><span class="line">    iReturn = MessageBoxW(hWnd, lpText, lpCaption, uType);</span><br><span class="line">    va_end(args);</span><br><span class="line">    <span class="keyword">return</span> iReturn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>DLL</title>
    <url>/posts/343ff8fdb6958d7d/</url>
    <content><![CDATA[<p>DLL(Dynamic Link Library,动态链接库/应用程序扩展)，是一种玄学的东西，它可以将程序用到的函数分成几个模块分别存储。<br><a id="more"></a></p>
<h1 id="何为DLL"><a href="#何为DLL" class="headerlink" title="何为DLL"></a>何为DLL</h1><p>DLL，就是一个二进制的映像文件，里面存着可以执行的二进制代码。某一个(或某一堆)程序会在运行时将DLL加载至内存空间，从而调用其中的函数。<br>如果程序检测到某个需要的DLL不存在，就会显示错误信息，然后终止程序。<br>但是比较玄学的东西就是，Windows的DLL搜索会遵循如下顺序：   </p>
<ul>
<li>程序当前目录</li>
<li>%HOMEDRIVE%\\Windows\\System32</li>
<li>%HOMEDRIVE%\\Windows\\System</li>
<li>%HOMEDRIVE%\\Windows</li>
<li>%PATH%中列出的目录</li>
</ul>
<p>所以如果我们知道一个程序使用的DLL中写了什么函数，我们就可以写一个伪装的DLL放在程序的目录下，程序会优先加载目录中的DLL，然后调用里面的函数，就可以……[手动滑稽]<br>说实话最近我用的优思授课系统的<code>WS_EX_TOPMOST</code>窗口样式搞得我很不爽，说不定哪天<code>YouSiedu TopMost Crack</code>……</p>
<h1 id="为什么要用DLL"><a href="#为什么要用DLL" class="headerlink" title="为什么要用DLL"></a>为什么要用DLL</h1><p>MS官方：</p>
<blockquote>
<ul>
<li>DLL介绍了程序的特性</li>
<li>DLL简化了项目管理</li>
<li>DLL有助于节省内存</li>
<li>DLL促进了资源共享</li>
<li>DLL促进了本地化</li>
<li>DLL有助于解决平台之间的差异</li>
<li>DLL可以用于特殊目的</li>
</ul>
</blockquote>
<h1 id="DLL基础知识"><a href="#DLL基础知识" class="headerlink" title="DLL基础知识"></a>DLL基础知识</h1><h2 id="构建"><a href="#构建" class="headerlink" title="构建"></a>构建</h2><p>MSBuild威武!<br>在DLL项目生成(MS官方的叫法)的时候，会同时生成一个.lib文件，用于储存导出的函数和变量等。由于这个文件只储存名称，并不保存可执行部分，所以体积并不大(起码没有DLL大)。<br>在VS2017中生成带DLL的EXE项目时，需要生成整个解决方案，因为如果不顺带生成DLL项目，编译器就找不到声明DLL中导出函数及变量的.lib文件，会导致生成终止。</p>
<h2 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h2><p>程序在生成的过程中，会被写入一些关于需要的DLL的信息(起码MSBuild是这样)，在执行的时候被操作系统读取并载入，这种方法称为”隐式载入”。<br>程序在代码中用<code>LoadLibrary(Ex)</code>函数手动将某个DLL加载至内存空间，叫做”显式载入”。<br>在程序执行的时候，其中存储的关DLL的信息就会被读取，然后系统会遵照上文提到的搜索顺序寻找该DLL文件，如果找到了，结束搜索并将DLL载入至内存空间，如果没找到，为了避免非法内存访问，会终止该程序的执行。<br>如果某DLL是显式加载，Windows会向DLL发送一个消息，由DLL中的<code>DllMain</code>函数进行处理，通常，在DLL被载入和卸载的时候都会给DLL发送信息，以让DLL进行初始化和销毁操作。</p>
<h1 id="创建DLL项目"><a href="#创建DLL项目" class="headerlink" title="创建DLL项目"></a>创建DLL项目</h1><p>建议不要为DLL新建解决方案，因为新建后调试会很麻烦。所以我们选择在现有解决方案创建新项目来演示。   </p>
<p><div class="note warning">以下适用于Visual Studio 2017，不同版本VS请自行更改设定。</div><br>在解决方案资源管理器中右击解决方案，点击添加-&gt;新建项目…，选择动态链接库(DLL)，输入项目名，点击确定。   </p>
<h1 id="DLL与程序的区别"><a href="#DLL与程序的区别" class="headerlink" title="DLL与程序的区别"></a>DLL与程序的区别</h1><h2 id="声明的变化"><a href="#声明的变化" class="headerlink" title="声明的变化"></a>声明的变化</h2><p>在DLL的代码中，变量及函数在声明的时候需要在声明时前面加上<code>__declspec(dllexport)</code>，引用DLL的程序写DLL函数变量声明时加<code>__declspec(dllimport)</code>。<br>出于习惯，将DLL中的代码塞进一个命名空间(<code>namespace</code>)中。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DLLAPI_EX __declspec(dllexport)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DLLAPI_IM __declspec(dllimport)</span></span><br></pre></td></tr></table></figure>
<h1 id="为DLL编写代码"><a href="#为DLL编写代码" class="headerlink" title="为DLL编写代码"></a>为DLL编写代码</h1><h2 id="标头"><a href="#标头" class="headerlink" title="标头"></a>标头</h2><p>在DLL项目下新建标头，一般命名为[项目名].h。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DLLAPI __declspec(dllexport)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Calc &#123;</span><br><span class="line">	<span class="comment">// 在此声明函数及变量等。</span></span><br><span class="line">	<span class="function">DLLAPI <span class="keyword">int</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> nLeft,<span class="keyword">int</span> nRight)</span></span>;</span><br><span class="line">	<span class="function">DLLAPI <span class="keyword">int</span> <span class="title">Sub</span><span class="params">(<span class="keyword">int</span> nLeft,<span class="keyword">int</span> nRight)</span></span>;</span><br><span class="line">	<span class="function">DLLAPI <span class="keyword">int</span> <span class="title">Mul</span><span class="params">(<span class="keyword">int</span> nLeft,<span class="keyword">int</span> nRight)</span></span>;</span><br><span class="line">	<span class="function">DLLAPI <span class="keyword">double</span> <span class="title">Div</span><span class="params">(<span class="keyword">double</span> fLeft,<span class="keyword">double</span> fRight)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// DLL类需要注意，DLLAPI需要这样用：</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">class</span> <span class="title">DLLAPI</span> <span class="title">Unk</span> &#123;</span></span><br><span class="line">		<span class="keyword">public</span>:</span><br><span class="line">		<span class="comment">// ...</span></span><br><span class="line">		<span class="keyword">int</span> unused;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="C-源"><a href="#C-源" class="headerlink" title="C++源"></a>C++源</h2><p>打开DLL项目下的[项目名].cpp，编写代码，注意，这里的代码不需要<code>DLLAPI_*</code>。   </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdafx.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Blog_test_dll.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Calc &#123;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> nLeft,<span class="keyword">int</span> nRight)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> nLeft + nRight;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">Sub</span><span class="params">(<span class="keyword">int</span> nLeft,<span class="keyword">int</span> nRight)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> nLeft - nRight;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">Mul</span><span class="params">(<span class="keyword">int</span> nLeft,<span class="keyword">int</span> nRight)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> nLeft * nRight;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">double</span> <span class="title">Div</span><span class="params">(<span class="keyword">double</span> fLeft,<span class="keyword">double</span> fRight)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> fLeft / fRight;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">class</span> <span class="title">Unk</span> &#123;</span></span><br><span class="line">		<span class="keyword">public</span>:</span><br><span class="line">		<span class="comment">// ...</span></span><br><span class="line">		<span class="keyword">int</span> unused;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="DLL的编译"><a href="#DLL的编译" class="headerlink" title="DLL的编译"></a>DLL的编译</h1><p>编译DLL，可以选择仅编译DLL项目或编译整个解决方案。<br>[生成]-&gt;[生成解决方案]或按F7(一些大佬可能喜欢Fn+F7)以重新生成解决方案。<br>选中DLL项目，点击[生成]-&gt;[仅生成%项目名%]以编译DLL项目。   </p>
<h1 id="DLL的使用"><a href="#DLL的使用" class="headerlink" title="DLL的使用"></a>DLL的使用</h1><p>既然DLL已经写出来了，我们就要用。<br>在EXE项目标头新建头文件，一般命名为[DLL项目名].h，写入DLL项目中的标头的内容，将<code>DLLAPI</code>的定义换成<code>__declspec(dllimport)</code>即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> DLLAPI</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> DLLAPI</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DLLAPI __declspec(dllimport)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Calc &#123;</span><br><span class="line">	<span class="function">DLLAPI <span class="keyword">int</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> nLeft,<span class="keyword">int</span> nRight)</span></span>;</span><br><span class="line">	<span class="function">DLLAPI <span class="keyword">int</span> <span class="title">Sub</span><span class="params">(<span class="keyword">int</span> nLeft,<span class="keyword">int</span> nRight)</span></span>;</span><br><span class="line">	<span class="function">DLLAPI <span class="keyword">int</span> <span class="title">Mul</span><span class="params">(<span class="keyword">int</span> nLeft,<span class="keyword">int</span> nRight)</span></span>;</span><br><span class="line">	<span class="function">DLLAPI <span class="keyword">double</span> <span class="title">Div</span><span class="params">(<span class="keyword">double</span> fLeft,<span class="keyword">double</span> fRight)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">class</span> <span class="title">DLLAPI</span> <span class="title">Unk</span> &#123;</span></span><br><span class="line">		<span class="keyword">public</span>:</span><br><span class="line">		<span class="comment">// ...</span></span><br><span class="line">		<span class="keyword">int</span> unused;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后，在cpp文件中加入<code>#include</code>将上面的头文件包括。<br>最后，使用如下代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(lib,<span class="meta-string">"../Debug/Calc.lib"</span>)</span></span><br></pre></td></tr></table></figure>
<p>将编译器生成的lib文件包括即可。   </p>
<p>最后，如果我们的程序想要运行，一！定！要将DLL与EXE放在同一个目录下，不然程序无法运行。</p>
]]></content>
      <categories>
        <category>Windows</category>
        <category>DLL</category>
      </categories>
      <tags>
        <tag>Windows</tag>
      </tags>
  </entry>
  <entry>
    <title>在Windows编写多线程程序</title>
    <url>/posts/ca98c17def689642/</url>
    <content><![CDATA[<p>多线程，可以大幅度提高程序运行效率。</p>
<a id="more"></a>
<h1 id="何为线程"><a href="#何为线程" class="headerlink" title="何为线程"></a>何为线程</h1><p>线程，就是可以和你的程序同时运行的东西。Windows是一个抢占式操作系统，CPU会将CPU时间按照优先级依次分配给各个线程。</p>
<h1 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h1><p>创建线程一般使用<code>CreateThread</code>函数。  </p>
<p>不过MS技术人员更加推荐<code>_beginthreadex()</code>，感兴趣的可以自己去翻官方文档。  </p>
<h2 id="CreateThread"><a href="#CreateThread" class="headerlink" title="CreateThread"></a>CreateThread</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>MSDN:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">HANDLE <span class="title">CreateThread</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  LPSECURITY_ATTRIBUTES   lpThreadAttributes,</span></span></span><br><span class="line"><span class="function"><span class="params">  SIZE_T                  dwStackSize,</span></span></span><br><span class="line"><span class="function"><span class="params">  LPTHREAD_START_ROUTINE  lpStartAddress,</span></span></span><br><span class="line"><span class="function"><span class="params">  __drv_aliasesMem LPVOID lpParameter,</span></span></span><br><span class="line"><span class="function"><span class="params">  DWORD                   dwCreationFlags,</span></span></span><br><span class="line"><span class="function"><span class="params">  LPDWORD                 lpThreadId</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>
<p>Visual Studio 2017 - <i class="fa fa-file-code-o"></i> processthreadapi.h:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">WINBASEAPI _Ret_maybenull_ HANDLE WINAPI <span class="title">CreateThread</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    _In_opt_ LPSECURITY_ATTRIBUTES lpThreadAttributes,</span></span></span><br><span class="line"><span class="function"><span class="params">    _In_ SIZE_T dwStackSize,</span></span></span><br><span class="line"><span class="function"><span class="params">    _In_ LPTHREAD_START_ROUTINE lpStartAddress,</span></span></span><br><span class="line"><span class="function"><span class="params">    _In_opt_ __drv_aliasesMem LPVOID lpParameter,</span></span></span><br><span class="line"><span class="function"><span class="params">    _In_ DWORD dwCreationFlags,</span></span></span><br><span class="line"><span class="function"><span class="params">    _Out_opt_ LPDWORD lpThreadId</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>
<p>毒瘤依旧</p>
<h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><h4 id="in-opt-lpThreadAttributes"><a href="#in-opt-lpThreadAttributes" class="headerlink" title="[in,opt]lpThreadAttributes"></a>[in,opt]lpThreadAttributes</h4><p>指向一个指示线程的安全描述符的指针，通常设为<code>NULL</code>以指示使用默认属性。</p>
<h4 id="in-dwStackSize"><a href="#in-dwStackSize" class="headerlink" title="[in]dwStackSize"></a>[in]dwStackSize</h4><p>一个指示线程的栈大小的双字，通常设为0以指示使用与主函数相同的栈大小。</p>
<h4 id="in-lpStartAddress"><a href="#in-lpStartAddress" class="headerlink" title="[in]lpStartAddress"></a>[in]lpStartAddress</h4><p>函数指针，指向线程运行的函数，通常像下面一样定义：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">DWORD CALLBACK <span class="title">ThreadFunc</span><span class="params">(LPVOID pvParam)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="in-opt-lpParameter"><a href="#in-opt-lpParameter" class="headerlink" title="[in,opt]lpParameter"></a>[in,opt]lpParameter</h4><p>传给线程函数的参数。</p>
<h4 id="in-dwCreationFlags"><a href="#in-dwCreationFlags" class="headerlink" title="[in]dwCreationFlags"></a>[in]dwCreationFlags</h4><p>常用值如下表：</p>
<table>
<thead>
<tr>
<th>值</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>线程创建后立即运行</td>
</tr>
<tr>
<td>CREATE_SUSPENDED</td>
<td>创建后挂起</td>
</tr>
</tbody>
</table>
<p>挂起的线程可用<code>ResumeThread</code>恢复。</p>
<h4 id="out-opt-lpThreadId"><a href="#out-opt-lpThreadId" class="headerlink" title="[out,opt]lpThreadId"></a>[out,opt]lpThreadId</h4><p>指向一个用于存放线程ID的双字，如果为<code>NULL</code>，则不为线程指定ID。</p>
<h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3><p>如果线程成功创建，返回线程的句柄。否则，返回<code>NULL</code>。</p>
<h1 id="让线程与主函数同步"><a href="#让线程与主函数同步" class="headerlink" title="让线程与主函数同步"></a>让线程与主函数同步</h1><p>在一些地方，线程需要和主程序的一些变量等东西同步，这种情况，一般会使用全局变量。如指示程序结束的变量：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">BOOL g_bClosed = FALSE;</span><br></pre></td></tr></table></figure>
<p>线程函数：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">DWORD CALLBACK <span class="title">ThreadFunc</span><span class="params">(LPVOID pvParam)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(!g_bClosed) &#123;</span><br><span class="line">    <span class="comment">// ... </span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="退出线程"><a href="#退出线程" class="headerlink" title="退出线程"></a>退出线程</h1><p>退出线程一般有4种方式：</p>
<ul>
<li>线程函数返回(最常用 最安全)  </li>
<li>线程调用<code>ExitThread</code>进行“自杀”  </li>
<li>其他线程调用<code>TerminateThread</code>强制终止当前线程  </li>
<li>创建线程的进程退出  </li>
</ul>
<h2 id="线程函数返回"><a href="#线程函数返回" class="headerlink" title="线程函数返回"></a>线程函数返回</h2><p>让线程执行的函数返回是最安全、最常用的方式。<br>当我们认为线程的任务完成了以后，就需要让线程执行的函数返回一个值，这个值通常为0。<br>让线程的函数返回可以让Windows正确的清理我们的线程运行使用的内存空间。</p>
<h2 id="ExitThread"><a href="#ExitThread" class="headerlink" title="ExitThread"></a>ExitThread</h2><p><code>ExitThread</code>是一个用于退出线程的函数。</p>
<h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><p>MSDN:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">DECLSPEC_NORETURN VOID <span class="title">ExitThread</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  DWORD dwExitCode</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>
<p>Visual Studio 2017 - processthreadapi.h:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">WINBASEAPI DECLSPEC_NORETURN VOID WINAPI <span class="title">ExitThread</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    _In_ DWORD dwExitCode</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="参数-1"><a href="#参数-1" class="headerlink" title="参数"></a>参数</h3><h4 id="in-dwExitCode"><a href="#in-dwExitCode" class="headerlink" title="[in]dwExitCode"></a>[in]dwExitCode</h4><p>线程的返回值，可用<code>GetExitCodeThread</code>获取。</p>
<h2 id="TerminateThread"><a href="#TerminateThread" class="headerlink" title="TerminateThread"></a>TerminateThread</h2><p><code>TerminateThread</code>是一个用于杀死其他进程的函数，MS官方极力反对这种方式。<code>TerminateThread</code>不会销毁线程占用的内存空间，因为其他线程可能还在使用这一段内存空间，如果Windows销毁的话……  </p>
<p><img src="/images/RE.png" alt="">   </p>
<p>在此不对<code>TerminateThread</code>做介绍。<s>省的读者拿去祸害人。</s></p>
<h1 id="关闭线程句柄"><a href="#关闭线程句柄" class="headerlink" title="关闭线程句柄"></a>关闭线程句柄</h1><p>线程运行完毕后，我们还需要将线程的句柄“归还”给Windows。否则就会有一大堆句柄占用空间却什么都不做。<br>关闭句柄使用<code>CloseHandle</code>函数。<br>要注意，关闭句柄并不代表线程停止运行，所以即使调用<code>CloseHandle</code>而不让线程退出，线程会一直运行下去。   </p>
<h2 id="CloseHandle"><a href="#CloseHandle" class="headerlink" title="CloseHandle"></a>CloseHandle</h2><h3 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h3><p>MSDN:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">BOOL WINAPI <span class="title">CloseHandle</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_ HANDLE hObject</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>
<p>Visual Studio 2017 - handleapi.h:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">WINBASEAPI BOOL WINAPI <span class="title">CloseHandle</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    _In_ _Post_ptr_invalid_ HANDLE hObject</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="参数-2"><a href="#参数-2" class="headerlink" title="参数"></a>参数</h3><h4 id="in-hObject"><a href="#in-hObject" class="headerlink" title="[in]hObject"></a>[in]hObject</h4><p>指示要关闭的句柄。<br><code>hObject</code>可以是任何允许被关闭的句柄，如文件、线程等。   </p>
]]></content>
      <categories>
        <category>Windows</category>
        <category>线程</category>
      </categories>
      <tags>
        <tag>Windows</tag>
      </tags>
  </entry>
  <entry>
    <title>虚拟按键编码</title>
    <url>/posts/9ea7215d45f55ac9/</url>
    <content><![CDATA[<p>本文列出常用的虚拟键码，一些比较重要的值用粗体标出。<br><a id="more"></a></p>
<table>
<thead>
<tr>
<th>值</th>
<th>对应按键</th>
</tr>
</thead>
<tbody>
<tr>
<td>VK_BACK</td>
<td>Backspace(退格)</td>
</tr>
<tr>
<td>VK_TAB</td>
<td>Tab</td>
</tr>
<tr>
<td><strong>VK_RETURN</strong></td>
<td><strong>回车</strong></td>
</tr>
<tr>
<td><strong>VK_SHIFT</strong></td>
<td><strong>Shift</strong></td>
</tr>
<tr>
<td><strong>VK_CONTROL</strong></td>
<td><strong>Ctrl</strong></td>
</tr>
<tr>
<td>VK_MENU</td>
<td>Alt</td>
</tr>
<tr>
<td>VK_PAUSE</td>
<td>PauseBreak</td>
</tr>
<tr>
<td>VK_CAPITAL</td>
<td>Caps Lock</td>
</tr>
<tr>
<td><strong>VK_ESCAPE</strong></td>
<td><strong>Esc</strong></td>
</tr>
<tr>
<td>VK_PRIOR</td>
<td>Page Up</td>
</tr>
<tr>
<td>VK_NEXT</td>
<td>Page Down</td>
</tr>
<tr>
<td>VK_END</td>
<td>End</td>
</tr>
<tr>
<td>VK_HOME</td>
<td>Home</td>
</tr>
<tr>
<td><strong>VK_LEFT</strong></td>
<td><strong>←</strong></td>
</tr>
<tr>
<td><strong>VK_UP</strong></td>
<td><strong>↑</strong></td>
</tr>
<tr>
<td><strong>VK_RIGHT</strong></td>
<td><strong>→</strong></td>
</tr>
<tr>
<td><strong>VK_DOWN</strong></td>
<td><strong>↓</strong></td>
</tr>
<tr>
<td>VK_INSERT</td>
<td>Insert</td>
</tr>
<tr>
<td>VK_DELETE</td>
<td>Delete</td>
</tr>
<tr>
<td>0x30 - 0x39</td>
<td>数字0-9</td>
</tr>
<tr>
<td>0x41 - 0x5A</td>
<td>字母A-Z</td>
</tr>
<tr>
<td>VK_LWIN</td>
<td>左Win键</td>
</tr>
<tr>
<td>VK_RWIN</td>
<td>右Win键(然鹅你并不能阻止开始的弹出)</td>
</tr>
<tr>
<td>VK_NUMPAD[0-9]</td>
<td>小键盘0-9</td>
</tr>
<tr>
<td>VK_F[1-24]</td>
<td>F1-F24(我也不知道什么电脑有F13-F24)</td>
</tr>
<tr>
<td>VK_NUMLOCK</td>
<td>NumLock</td>
</tr>
<tr>
<td>VK_SCROLL</td>
<td>ScrollLock</td>
</tr>
<tr>
<td>VK_LSHIFT</td>
<td>左Shift</td>
</tr>
<tr>
<td>VK_RSHIFT</td>
<td>右Shift</td>
</tr>
<tr>
<td>VK_LMENU</td>
<td>左Menu</td>
</tr>
<tr>
<td>VK_RMENU</td>
<td>右Menu</td>
</tr>
<tr>
<td>VK_MEDIA_NEXT_TRACK</td>
<td>下一曲</td>
</tr>
<tr>
<td>VK_MEDIA_PREV_TRACK</td>
<td>上一曲</td>
</tr>
<tr>
<td>VK_MEDIA_STOP</td>
<td>停止播放</td>
</tr>
<tr>
<td>VK_MEDIA_PLAY_PAUSE</td>
<td>继续/暂停</td>
</tr>
</tbody>
</table>
]]></content>
      <categories>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>Windows</tag>
      </tags>
  </entry>
  <entry>
    <title>处理键盘</title>
    <url>/posts/731288ea57414571/</url>
    <content><![CDATA[<p>键盘，是一个很重要的工具，负责用户输入。在CUI中，键盘处理从来就不是我们要操心的事，但是，我们现在是GUI。<br><a id="more"></a><br>处理键盘，主要有以下几种方法：</p>
<ul>
<li><code>WM_KEYDOWN</code>消息</li>
<li><code>WM_CHAR</code>消息</li>
<li><code>GetAsyncKeyState</code>函数</li>
</ul>
<h1 id="WM-KEYDOWN"><a href="#WM-KEYDOWN" class="headerlink" title="WM_KEYDOWN"></a>WM_KEYDOWN</h1><p>明显，这是一个Windows消息，会在键盘上的某个键被按下时发送。<br>但是如果真的用了这个消息，在按住时程序会很卡。</p>
<h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><p>这个称之为参数合适不合适……   </p>
<h3 id="wParam"><a href="#wParam" class="headerlink" title="wParam"></a>wParam</h3><p>按键的虚拟键码，参见<a href="/9ea7215d45f55ac9/">虚拟按键编码</a></p>
<h3 id="lParam"><a href="#lParam" class="headerlink" title="lParam"></a>lParam</h3><p><code>lParam</code>的不同的二进制位代表不同的含义。见下表：</p>
<table>
<thead>
<tr>
<th>位</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>0-15</td>
<td>用户按住键而自动重复击键的次数</td>
</tr>
<tr>
<td>16-23</td>
<td>按键扫描码，由键盘生产厂家决定</td>
</tr>
<tr>
<td>24</td>
<td>指示是否为扩展按键(我也不知道什么意思)</td>
</tr>
<tr>
<td>25-28</td>
<td>保留</td>
</tr>
<tr>
<td>29</td>
<td>MSDN说是”The context code”，对于<code>WM_KEYDOWN</code>总是0</td>
</tr>
<tr>
<td>30</td>
<td>如果消息发送的时候按键是按下的为0，否则为1</td>
</tr>
<tr>
<td>31</td>
<td>MSDN说是”The transition code”，对于<code>WM_KEYDOWN</code>总是0</td>
</tr>
</tbody>
</table>
<h1 id="WM-CHAR"><a href="#WM-CHAR" class="headerlink" title="WM_CHAR"></a>WM_CHAR</h1><p>同样，一个Windows消息。</p>
<h2 id="参数-1"><a href="#参数-1" class="headerlink" title="参数"></a>参数</h2><h3 id="wParam-1"><a href="#wParam-1" class="headerlink" title="wParam"></a>wParam</h3><p>按键的字符编码，可直接使用<code>L&#39;字符&#39;</code>的形式，记住，<code>WM_CHAR</code>的<code>wParam</code>一直使用UTF-16！</p>
<h3 id="lParam-1"><a href="#lParam-1" class="headerlink" title="lParam"></a>lParam</h3><p>同样是一堆以二进制位表示的东西，如下：</p>
<table>
<thead>
<tr>
<th>位</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>0-15</td>
<td>用户按住键而自动重复击键的次数</td>
</tr>
<tr>
<td>16-23</td>
<td>按键扫描码，由键盘生产厂家决定</td>
</tr>
<tr>
<td>24</td>
<td>指示是否为扩展按键(我也不知道什么意思)</td>
</tr>
<tr>
<td>25-28</td>
<td>保留</td>
</tr>
<tr>
<td>29</td>
<td>指示Alt是否按下</td>
</tr>
<tr>
<td>30</td>
<td>如果消息发送的时候按键是按下的为0，否则为1</td>
</tr>
<tr>
<td>31</td>
<td>指示当前按键是否正在释放</td>
</tr>
</tbody>
</table>
<h1 id="GetAsyncKeyState"><a href="#GetAsyncKeyState" class="headerlink" title="GetAsyncKeyState"></a>GetAsyncKeyState</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>MSDN:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">SHORT <span class="title">GetAsyncKeyState</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">int</span> vKey</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>
<p>Visual Studio 2017 - WinUser.h:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">WINUSERAPI SHORT WINAPI <span class="title">GetAsyncKeyState</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    _In_ <span class="keyword">int</span> vKey</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>
<h2 id="参数-2"><a href="#参数-2" class="headerlink" title="参数"></a>参数</h2><h3 id="in-vKey"><a href="#in-vKey" class="headerlink" title="[in]vKey"></a>[in]vKey</h3><p>指定要测试的键的虚拟键码。<br>值得一提的是，<code>GetAsyncKeyState</code>对单个键起作用，所以可以同时检测多个按键。</p>
<h2 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h2><p>返回一堆除了最高位都无卵用的东西。而且其他的位还不一定是0。为了排除这些干扰，我们可以定义一个宏：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KEYDOWN(vk_code) 	((GetAsyncKeyState(vk_code) &amp; 0x8000) ? 1 : 0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KEYUP(vk_code)		((GetAsyncKeyState(vk_code) &amp; 0x8000) ? 0 : 1)</span></span><br></pre></td></tr></table></figure>
<h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p>使用键盘的地方很多，在此以按Esc键时退出为例。</p>
<h2 id="GetMessage消息循环"><a href="#GetMessage消息循环" class="headerlink" title="GetMessage消息循环"></a>GetMessage消息循环</h2><p>在<code>WndProc</code>的<code>switch</code>语句中加入：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> WM_KEYDOWN:&#123;</span><br><span class="line">	<span class="keyword">if</span>(wParam == VK_ESCAPE) &#123;</span><br><span class="line">		SendMessage(hWnd,WM_DESTROY,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="PeekMessage消息循环"><a href="#PeekMessage消息循环" class="headerlink" title="PeekMessage消息循环"></a>PeekMessage消息循环</h2><p>在消息循环的<code>if</code>后加入：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(KEYDOWN(VK_ESCAPE))&#123;</span><br><span class="line">	SendMessage(hWnd,WM_DESTROY,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h1><p><a href="https://docs.microsoft.com/en-us/windows/desktop/api/winuser/nf-winuser-getasynckeystate" target="_blank" rel="noopener">GetAsyncKeyState</a><br><a href="https://docs.microsoft.com/en-us/windows/desktop/inputdev/wm-keydown" target="_blank" rel="noopener">WM_KEYDOWN</a><br><a href="https://docs.microsoft.com/en-us/windows/desktop/inputdev/wm-char" target="_blank" rel="noopener">WM_CHAR</a></p>
]]></content>
      <categories>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>Windows</tag>
      </tags>
  </entry>
  <entry>
    <title>终止处理</title>
    <url>/posts/9aae9b0c2c62b8be/</url>
    <content><![CDATA[<p>终止处理，是MSBuild支持的一项特性，用于阻止程序在异常情况下退出。最早由微软开发。</p>
<a id="more"></a>   
<p>终止处理可以让在其代码块中的<code>return</code>、<code>break</code>、<code>goto</code>、<code>continue</code>(<code>exit</code>、<code>Exit*</code>、<code>Terminate*</code>系列函数除外)等可以跳出<code>try</code>代码块的东西都在另一个代码块执行完毕后才去执行。使用方法如下：   </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">__try &#123;</span><br><span class="line">    <span class="comment">// Protected</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line">__finally &#123;</span><br><span class="line">    <span class="comment">// Execute before exiting</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Hexo的代码高亮不支持<code>__try</code>和<code>__finally</code>，没办法，凑合着看吧   </p>
<h1 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h1><h2 id="try"><a href="#try" class="headerlink" title="__try"></a>__try</h2><p><code>__try</code>后面的代码块是受保护的代码，这些代码中的<code>return</code>、<code>goto</code>等跳出关键字都不会立即生效，会在<code>__finally</code>块执行完毕后生效，返回的值也会被暂存在内存中。如下：   </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Func</span><span class="params">()</span></span>&#123;</span><br><span class="line">    DWORD dwTemp;</span><br><span class="line">    __try &#123;</span><br><span class="line">        dwTemp=<span class="number">303</span>;</span><br><span class="line">        <span class="keyword">return</span> dwTemp;</span><br><span class="line">    &#125;</span><br><span class="line">    __finally &#123;</span><br><span class="line">        MessageBox(<span class="literal">nullptr</span>,TEXT(<span class="string">""</span>),TEXT(<span class="string">"Finally block"</span>),MB_OK);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>流程图:   </p>
<p><img src="/post_images/try流程.png" alt="">   </p>
<h2 id="finally"><a href="#finally" class="headerlink" title="__finally"></a>__finally</h2><p><code>__finally</code>后面的代码块会在<code>__try</code>块<strong>执行完毕</strong>后或<strong>运行到<code>__try</code>块中的用于跳出的关键字</strong>时执行。</p>
<h2 id="leave"><a href="#leave" class="headerlink" title="__leave"></a>__leave</h2><p><code>__leave</code>关键字会将程序执行顺序跳到<code>__try</code>最后。其实<code>__leave</code>和<code>return</code>效果差不多，但是后者内存开销相对较大。如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Func</span><span class="params">()</span></span>&#123;</span><br><span class="line">    DWORD dwTemp;</span><br><span class="line">    __try &#123;</span><br><span class="line">        dwTemp=<span class="number">303</span>;</span><br><span class="line">        __leave;</span><br><span class="line">        dwTemp=<span class="number">404</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    __finally &#123;</span><br><span class="line">        MessageBox(<span class="literal">nullptr</span>,TEXT(<span class="string">""</span>),TEXT(<span class="string">"Finally block"</span>),MB_OK);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dwTemp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>流程：   </p>
<p><img src="/post_images/leave流程.png" alt=""></p>
<h1 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h1><p>这些内容通过实例理解可能会更好，所以本文的实例会比以往多。</p>
<h2 id="普通try-finally"><a href="#普通try-finally" class="headerlink" title="普通try-finally"></a>普通try-finally</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Func</span><span class="params">()</span></span>&#123;</span><br><span class="line">    DWORD dwTemp;</span><br><span class="line">    __try &#123;</span><br><span class="line">        dwTemp=<span class="number">303</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    __finally &#123;</span><br><span class="line">        dwTemp++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dwTemp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样，返回的值是304，就是303+1。流程：</p>
<p><img src="/post_images/普通th流程.png" alt="">   </p>
<p>可见，即使<code>try</code>中没有<code>return</code>、<code>goto</code>等跳出语句，<code>finally</code>也会执行。</p>
<h2 id="try块中存在返回"><a href="#try块中存在返回" class="headerlink" title="try块中存在返回"></a>try块中存在返回</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Func</span><span class="params">()</span></span>&#123;</span><br><span class="line">    DWORD dwTemp;</span><br><span class="line">    __try &#123;</span><br><span class="line">        dwTemp=<span class="number">303</span>;</span><br><span class="line">        <span class="keyword">return</span> dwTemp;</span><br><span class="line">        dwTemp=<span class="number">404</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    __finally &#123;</span><br><span class="line">        dwTemp++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样，返回的值是303.因为<code>try</code>块中一旦执行到跳出的代码，就会跳到<code>finally</code>块，这样<code>dwTemp=404</code>就不会执行，跳到<code>finally</code>后<code>dwTemp</code>自增，但由于<code>try</code>中已经<code>return</code>过，303被存到内存中的临时空间中，所以返回值不会更新为304。由于<code>try</code>中已经有<code>return</code>但没有执行，<code>finally</code>执行完后就会立即返回<code>try</code>中返回的值，无视后面的语句。   </p>
<p>乍一看，这堆代码的流程是：   </p>
<p><img src="/post_images/返回th流程_1.png" alt=""></p>
<p>但是实际上是类似于这样的：</p>
<p><img src="/post_images/返回th流程_2.png" alt=""></p>
<h2 id="try块中存在goto"><a href="#try块中存在goto" class="headerlink" title="try块中存在goto"></a>try块中存在goto</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Func</span><span class="params">()</span></span>&#123;</span><br><span class="line">    DWORD dwTemp;</span><br><span class="line">    __try &#123;</span><br><span class="line">        dwTemp=<span class="number">303</span>;</span><br><span class="line">        <span class="keyword">goto</span> end;</span><br><span class="line">    &#125;</span><br><span class="line">    __finally &#123;</span><br><span class="line">        <span class="comment">// Nothing to do</span></span><br><span class="line">    &#125;</span><br><span class="line">    dwTemp=<span class="number">404</span>;</span><br><span class="line">    end:</span><br><span class="line">    <span class="keyword">return</span> dwTemp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><s><code>finally</code>实际上是我想不出要干啥了</s><br>这样，返回值是303。<br>流程：<br><img src="/post_images/gototh流程.png" alt="">   </p>
<h2 id="try块中存在RE"><a href="#try块中存在RE" class="headerlink" title="try块中存在RE"></a>try块中存在RE</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">err</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>* p=<span class="literal">NULL</span>;</span><br><span class="line">    *p=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> *p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Func</span><span class="params">()</span></span>&#123;</span><br><span class="line">    DWORD* pdwTemp=<span class="keyword">new</span> DWORD;</span><br><span class="line">    __try &#123;</span><br><span class="line">        *pdwTemp=err();</span><br><span class="line">    &#125;</span><br><span class="line">    __finally &#123;</span><br><span class="line">        <span class="keyword">delete</span> pdwTemp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>流程：</p>
<p><img src="/post_images/REth流程.png" alt=""></p>
<p>这个代码比较危险，因为它试图对<code>(int*)NULL</code>设为<code>1</code>，然后……<br><img src="/post_images/RE.png" alt=""><br>程序会显示一个对话框或者在VS中提示错误，像这样：<br><img src="/post_images/RE_2.png" alt=""><br>当<code>try</code>块中有内存溢出等RE时，<code>try-finally</code>的价值才真正体现出来。因为RE通常要结束进程，而如果RE后不对某些特殊的变量进行处理的话，可能会造成十分严重的后果。<br>设想，你编写了一个使用多线程的程序，每个线程都需要一个全局变量来指示程序有没有结束，那么流程应该是这样的：<br><img src="/post_images/线程流程.png" alt=""><br>如果因为RE就不对其他变量进行处理，那么这个全局变量也不能指示其他线程退出，就成了这样：<br><img src="/post_images/线程流程-RE.png" alt=""></p>
<h2 id="finally块中存在return"><a href="#finally块中存在return" class="headerlink" title="finally块中存在return"></a>finally块中存在return</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Func</span><span class="params">()</span></span>&#123;</span><br><span class="line">    DWORD dwTemp;</span><br><span class="line">    __try &#123;</span><br><span class="line">        dwTemp=<span class="number">303</span>;</span><br><span class="line">        <span class="keyword">return</span> dwTemp;</span><br><span class="line">    &#125;</span><br><span class="line">    __finally &#123;</span><br><span class="line">        <span class="keyword">return</span> dwTemp+<span class="number">101</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样，函数的返回值就是404，因为在<code>try</code>块中的<code>return</code>会让程序为<code>dwTemp</code>创建一个临时的内存空间，但是<code>finally</code>中用<code>dwTemp+101</code>覆盖了这一内存空间，所以会返回<code>dwTemp+101</code>，也就是<code>404</code>。   </p>
<h1 id="工程化"><a href="#工程化" class="headerlink" title="工程化"></a>工程化</h1><p>终止处理可以让我们的代码看起来更加的正式，比如下面的函数：   </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">DWORD g_dwThreadId;</span><br><span class="line">HANDLE g_hThread;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Func</span><span class="params">()</span></span>&#123;</span><br><span class="line">    g_hThread = CreateThread(...);</span><br><span class="line">    <span class="keyword">if</span>(g_hThread == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        TerminateThread(g_hThread, <span class="number">0</span>);</span><br><span class="line">        CloseHandle(g_hThread);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以变成：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">DWORD g_dwThreadId;</span><br><span class="line">HANDLE g_hThread;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Func</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> err = <span class="number">1</span>;</span><br><span class="line">    __try &#123;</span><br><span class="line">        g_hThread = CreateThread(...);</span><br><span class="line">        <span class="keyword">if</span>(g_hThread == <span class="literal">NULL</span>) __leave;</span><br><span class="line">        err = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    __finally &#123;</span><br><span class="line">        <span class="keyword">if</span> (err) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!g_hThread) &#123;</span><br><span class="line">                TerminateThread(g_hThread, <span class="number">0</span>);</span><br><span class="line">                CloseHandle(g_hThread);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>异常处理</category>
      </categories>
      <tags>
        <tag>技巧</tag>
      </tags>
  </entry>
  <entry>
    <title>在VisualStudio使用资源</title>
    <url>/posts/d215eeacb8bb1d8a/</url>
    <content><![CDATA[<p>资源，是由Windows提出的一种能在应用程序中储存文件的技术。<br>对我们自己编写的小程序十分有用，因为我们不再需要为每一个程序创建目录并把运行需要的文件塞进去了，可以直接塞进程序里。   </p>
<a id="more"></a>
<p>本文介绍几种常用资源。</p>
<h1 id="什么是资源"><a href="#什么是资源" class="headerlink" title="什么是资源"></a>什么是资源</h1><p>所谓资源(Resource)，就是在编译时一块整合进你的程序的一堆东西，资源有很多种类，有图标(Icon,*.ico)、位图(Bitmap,*.bmp)、光标(Cursor,*.cur)、字符串表(String Table)、对话框(Dialog)、波形声音(Wave,*.wav)等的一些东西。</p>
<h1 id="如何使用资源"><a href="#如何使用资源" class="headerlink" title="如何使用资源"></a>如何使用资源</h1><p>在解决方案资源管理器中选中项目，依次点击项目-&gt;添加资源，如图：<br><img src="/post_images/resources.png" alt=""><br>然后选择对应的资源类型即可。<br><img src="/post_images/resources-select.png" alt=""><br>然后，项目目录下会生成一个<code>resources.h</code>的标头，里面是我们定义的资源的ID。我们可能需要自行包括这个标头。可以在资源视图-&gt;资源类型-&gt;资源ID的属性页面自定义ID。<br><img src="/post_images/resources-retypeid.png" alt="自定义ID"><br>资源的ID可以定义为宏或字符串，但推荐使用前者。如果自定义的ID用双引号括起来，就代表是一个字符串的资源ID，如果不括，VS会检查<code>resources.h</code>中有没有输入ID的定义，如果没有，就为输入的ID创建一个定义。</p>
<h1 id="资源类型"><a href="#资源类型" class="headerlink" title="资源类型"></a>资源类型</h1><h2 id="图标-Icon"><a href="#图标-Icon" class="headerlink" title="图标(Icon)"></a>图标(Icon)</h2><p>图标，是显示在程序左上角和任务栏的图标。<br>应用程序在资源管理器中的图标由资源ID较小的图标决定，如<code>IDI_ICON1(1001)</code>和<code>IDI_ICON2(1002)</code>，程序的图标为<code>IDI_ICON1</code>。</p>
<h3 id="添加"><a href="#添加" class="headerlink" title="添加"></a>添加</h3><p>要添加图标，我们需要添加一个Icon资源，点击导入，然后选择文件即可。   </p>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>要使用图标，我们需要把<code>MyRegisterClass</code>函数的<code>hIcon</code>成员和<code>hIconSm</code>成员的赋值更改一下。<br>宏做ID的资源：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">wcex.hIcon = LoadIcon(hInstance,MAKEINTRESOURCE(<span class="comment">/*图标资源ID*/</span>));</span><br><span class="line">wcex.hIconSm = LoadIcon(hInstance,MAKEINTRESOURCE(<span class="comment">/*图标资源ID*/</span>));</span><br></pre></td></tr></table></figure>
<p>字符串做ID的资源：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">wcex.hIcon = LoadIcon(hInstance,<span class="comment">/*图标资源ID*/</span>);</span><br><span class="line">wcex.hIconSm = LoadIcon(hInstance,<span class="comment">/*图标资源ID*/</span>);</span><br></pre></td></tr></table></figure>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>比如，我们导入了一个图标资源，定义ID为<code>IDI_ICON</code>，那么，上面的两行语句应该变为：   </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">wcex.hIcon = LoadIcon(hInstance,MAKEINTRESOURCE(IDI_ICON));</span><br><span class="line">wcex.hIconSm = LoadIcon(hInstance,MAKEINTRESOURCE(IDI_ICON));</span><br></pre></td></tr></table></figure>
<p>如果ID为<code>&quot;IDI_ICON&quot;</code>，那么应该是：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">wcex.hIcon = LoadIcon(hInstance,<span class="string">"IDI_ICON"</span>);</span><br><span class="line">wcex.hIconSm = LoadIcon(hInstance,<span class="string">"IDI_ICON"</span>);</span><br></pre></td></tr></table></figure>
<h2 id="对话框-Dialog"><a href="#对话框-Dialog" class="headerlink" title="对话框(Dialog)"></a>对话框(Dialog)</h2><p>对话框，极其毒瘤，极其方便</p>
<h3 id="添加-1"><a href="#添加-1" class="headerlink" title="添加"></a>添加</h3><p>要添加一个对话框，只要在添加资源对话框双击Dialog就可以了。</p>
<h3 id="消息处理函数"><a href="#消息处理函数" class="headerlink" title="消息处理函数"></a>消息处理函数</h3><p>我们需要为每一个(或许在编写一个使用多个对话框只为显示固定信息时可以创建一个通用的处理函数)对话框写一个消息处理函数，因为消息框实质上是一个窗口。通常这个函数像这样：   </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">INT_PTR CALLBACK <span class="title">DlgProc</span><span class="params">(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    UNREFERENCED_PARAMETER(lParam);</span><br><span class="line">    <span class="keyword">switch</span> (message)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> WM_INITDIALOG:</span><br><span class="line">        <span class="keyword">return</span> (INT_PTR)TRUE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> WM_COMMAND:</span><br><span class="line">        <span class="keyword">if</span> (LOWORD(wParam) == IDOK || LOWORD(wParam) == IDCANCEL)</span><br><span class="line">        &#123;</span><br><span class="line">            EndDialog(hDlg, LOWORD(wParam));</span><br><span class="line">            <span class="keyword">return</span> (INT_PTR)TRUE;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (INT_PTR)FALSE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是Visual Studio 2017默认自动生成的对话框消息处理函数。<br><code>INT_PTR</code>是一种类型，等价于<code>int</code>，<code>CALLBACK</code>指示参数会从右向左压入堆栈。<br><code>hDlg</code>是一个窗口句柄，是当前对话框的句柄。<br><code>message</code>是消息类型，<code>wParam</code>和<code>lParam</code>是消息的扩展参数。</p>
<h3 id="对话框消息"><a href="#对话框消息" class="headerlink" title="对话框消息"></a>对话框消息</h3><p>对话框有几种特有的消息种类，是普通窗口不会接收到的。<br>比如<code>WM_INITDIALOG</code>这是一个指示对话框被初始化的消息，处理时只需返回1表示初始化成功。   </p>
<h3 id="WM-COMMAND"><a href="#WM-COMMAND" class="headerlink" title="WM_COMMAND"></a>WM_COMMAND</h3><p><code>WM_COMMAND</code>在对话框中是一种比较特殊的消息，它代表窗口的控件或菜单选项被触发。   </p>
<h4 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h4><p><code>LOWORD(wParam)</code>表示哪一个控件被触发。对于对话框，只需将其与对话框按钮的ID比较是否相等就可以了。像这样：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> wmId = LOWORD(wParam);  <span class="comment">// ID</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span>(wmId) &#123;</span><br><span class="line">    <span class="keyword">case</span> IDC_BUTTON1: &#123;    <span class="comment">// ID of Button1</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">default</span>: &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于不同的消息，<code>lParam</code>的含义不同，具体请参考MSDN。</p>
<h3 id="控件"><a href="#控件" class="headerlink" title="控件"></a>控件</h3><p>对话框有很多种控件，比如按钮、进度条、静态文本、输入框、图像等。在此仅介绍几种常用控件，其他控件请参考MSDN。</p>
<h4 id="按钮-Button"><a href="#按钮-Button" class="headerlink" title="按钮(Button)"></a>按钮(Button)</h4><p>按钮控件是最常用的控件之一。下图就是一个按钮。  </p>
<p><img src="/post_images/Button_OK.png" alt="">   </p>
<p>从工具箱中把Button项拖到对话框中，设定ID并调整到自己想要的位置即可。   </p>
<h5 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h5><p>在此列出几个常用值。   </p>
<p><code>Default Button</code>：指定当前按钮是否为默认按钮，即打开后点击回车是否会触发当前按钮。<br><code>Visible</code>：指定当前控件是否可见。<br><code>Bitmap</code>：指定当前控件不显示位图或显示资源中的位图。<br><code>Caption</code>：显示在按钮上的文字。<br><code>Horizonal Alignment</code>：指定文本向哪对齐。<br><code>Multiline</code>：如果按钮宽度不足以显示<code>Caption</code>指定的文本，就将文本折为多行。<br><code>Transparent</code>：指定按钮是否为透明的。<br><code>ID</code>：按钮的ID。<br><code>TabStop</code>：指定用户可用Tab选中按钮。</p>
<h4 id="编辑框-Edit-Control"><a href="#编辑框-Edit-Control" class="headerlink" title="编辑框(Edit Control)"></a>编辑框(Edit Control)</h4><p>编辑框是一个用于让用户输入文本的东西。   </p>
<p><img src="/post_images/Edit_Control.png" alt="">   </p>
<p>从工具箱中把Edit Control项拖到自己喜欢的地方，并设定各项参数即可。</p>
<h5 id="属性-1"><a href="#属性-1" class="headerlink" title="属性"></a>属性</h5><p>在此列出几个常用值。   </p>
<p><code>Disabled</code>：指定是否禁用当前控件。<br><code>Multiline</code>：指定是否在文本长度太长的时候将文本折为多行。<br><code>Password</code>：指定是否对键入的每个字符显示<code>*</code>，像输入密码一样。<br><code>Read Only</code>：指定当前控件是否不允许用户编辑。<br><code>Visible</code>：指定当前控件是否可见。<br><code>LowerCase</code>：指定是否将所有字母转换为小写。<br><code>Number</code>：指定是否只允许键入数字。<br><code>Transparent</code>：指定当前控件是否透明。<br><code>UpperCase</code>：指定是否将所有字母转换为大写。   </p>
<h5 id="属性设定"><a href="#属性设定" class="headerlink" title="属性设定"></a>属性设定</h5><p>设定编辑框的文本代码如下：   </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Edit_SetText(GetDlgItem(<span class="comment">/*当前对话框句柄*/</span>,<span class="comment">/*编辑框ID*/</span>),TEXT(<span class="comment">/*文本*/</span>));   <span class="comment">// From &lt;WindowsX.h&gt;</span></span><br><span class="line"><span class="comment">//或者：</span></span><br><span class="line">SetDlgItemText(<span class="comment">/*对话框句柄*/</span>,<span class="comment">/*对话框ID*/</span>,TEXT(<span class="comment">/*文本*/</span>));</span><br></pre></td></tr></table></figure>
<p>禁用或启用一个编辑框的代码如下：   </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Edit_Enable(GetDlgItem(<span class="comment">/*当前对话框句柄*/</span>,<span class="comment">/*编辑框ID*/</span>),<span class="comment">/*0=禁用,1=启用*/</span>);</span><br></pre></td></tr></table></figure>
<p>获取编辑框的已输入的文本的代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">TCHAR szEdit[<span class="number">256</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">Edit_GetText(GetDlgItem(<span class="comment">/*对话框句柄*/</span>，<span class="comment">/*编辑框ID*/</span>),s,<span class="number">255</span>);</span><br><span class="line"><span class="comment">//或者：</span></span><br><span class="line">GetDlgItemText(<span class="comment">/*对话框句柄*/</span>, <span class="comment">/*编辑框ID*/</span>, s, <span class="number">255</span>);</span><br></pre></td></tr></table></figure>
<h4 id="静态文本-Static"><a href="#静态文本-Static" class="headerlink" title="静态文本(Static)"></a>静态文本(Static)</h4><p>静态文本比较简单，就是一个只显示文本的控件，下图就是一个Static。   </p>
<p><img src="/post_images/Static.png" alt="">   </p>
<p>Visual Studio允许多个Static控件使用相同的ID，在<code>resources.h</code>中，这个ID为<code>IDC_STATIC</code>。可以自定义这个值。一般修改ID除了闲得慌就是要更改其属性。然而我们不怎么需要更改一个静态文本显示的东西，但是如果在某些特殊情况下……<br><del>你可以用ReadOnly的Edit Control啊</del>   </p>
<h5 id="属性-2"><a href="#属性-2" class="headerlink" title="属性"></a>属性</h5><p><code>Align Text</code>:指定文本对齐方式[Left, Center, Right]<br><code>Caption</code>:显示的文本   </p>
<h2 id="字符串表-String-Table"><a href="#字符串表-String-Table" class="headerlink" title="字符串表(String Table)"></a>字符串表(String Table)</h2><p>这是一种十分……额……奇怪的东西，因为你完全可以在程序中用宏将字符串定义出来，当然如果你在写DLL就另当别论了。</p>
<h3 id="添加-2"><a href="#添加-2" class="headerlink" title="添加"></a>添加</h3><p>点击添加资源-&gt;String Table即可。</p>
<h3 id="添加字符串"><a href="#添加字符串" class="headerlink" title="添加字符串"></a>添加字符串</h3><p>双击击资源视图(如果没有就在视图里找)-&gt;[项目名称]-&gt;[项目名称].rc-&gt;String Table-&gt;[名称]<br>里面是已定义的字符串。可以自定义各项属性。</p>
<h3 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h3><p>加载已定义的字符串资源，需要使用<code>LoadString</code>函数。</p>
<h4 id="LoadString"><a href="#LoadString" class="headerlink" title="LoadString"></a>LoadString</h4><h5 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h5><p>MSDN:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LoadStringA</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  HINSTANCE hInstance,</span></span></span><br><span class="line"><span class="function"><span class="params">  UINT      uID,</span></span></span><br><span class="line"><span class="function"><span class="params">  LPSTR     lpBuffer,</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">int</span>       cchBufferMax</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LoadStringW</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  HINSTANCE hInstance,</span></span></span><br><span class="line"><span class="function"><span class="params">  UINT      uID,</span></span></span><br><span class="line"><span class="function"><span class="params">  LPWSTR    lpBuffer,</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">int</span>       cchBufferMax</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>
<p>Visual Studio 2017 - libloaderapi.h:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">WINUSERAPI <span class="keyword">int</span> WINAPI <span class="title">LoadStringA</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    _In_opt_ HINSTANCE hInstance,</span></span></span><br><span class="line"><span class="function"><span class="params">    _In_ UINT uID,</span></span></span><br><span class="line"><span class="function"><span class="params">    _Out_writes_to_(cchBufferMax,<span class="keyword">return</span> + <span class="number">1</span>) LPSTR lpBuffer,</span></span></span><br><span class="line"><span class="function"><span class="params">    _In_ <span class="keyword">int</span> cchBufferMax</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br><span class="line"><span class="function">WINUSERAPI <span class="keyword">int</span> WINAPI <span class="title">LoadStringW</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    _In_opt_ HINSTANCE hInstance,</span></span></span><br><span class="line"><span class="function"><span class="params">    _In_ UINT uID,</span></span></span><br><span class="line"><span class="function"><span class="params">    _Out_writes_to_(cchBufferMax,<span class="keyword">return</span> + <span class="number">1</span>) LPWSTR lpBuffer,</span></span></span><br><span class="line"><span class="function"><span class="params">    _In_ <span class="keyword">int</span> cchBufferMax</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> UNICODE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LoadString  LoadStringW</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LoadString  LoadStringA</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// !UNICODE</span></span></span><br></pre></td></tr></table></figure>
<p>毒瘤依旧</p>
<h5 id="参数-1"><a href="#参数-1" class="headerlink" title="参数"></a>参数</h5><h6 id="in-opt-hInstance"><a href="#in-opt-hInstance" class="headerlink" title="[in,opt]hInstance"></a>[in,opt]hInstance</h6><p>应用程序的实例，不允许为<code>NULL</code>(起码MSDN是这么说的)。</p>
<h6 id="in-uID"><a href="#in-uID" class="headerlink" title="[in]uID"></a>[in]uID</h6><p>字符串的ID。</p>
<h6 id="out-lpBuffer"><a href="#out-lpBuffer" class="headerlink" title="[out]lpBuffer"></a>[out]lpBuffer</h6><p>接收字符串用的字符数组。</p>
<h6 id="in-cchBufferMax"><a href="#in-cchBufferMax" class="headerlink" title="[in]cchBufferMax"></a>[in]cchBufferMax</h6><p>指定最大会有多少个字符。如果指定的字符串资源的字符数大于<code>cchBufferMax</code>，将截断字符。</p>
<hr>
]]></content>
      <categories>
        <category>Windows</category>
        <category>资源</category>
      </categories>
      <tags>
        <tag>Windows</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows程序-最简单的Win32窗口应用程序</title>
    <url>/posts/3de79105673fb778/</url>
    <content><![CDATA[<p>命令行，对用户极其不友好，因为你只能看到一个只输出文本的简陋的窗口。<br><a id="more"></a><br>所以在命令行界面中编写游戏之类的程序就成了一个难题。笔者曾有一个大佬室友，用命令行做出了贪吃蛇，结果闪烁非常严重（i7游戏本）。</p>
<p><s>我LZ天生狂傲！</s></p>
<p>不废话了，先上代码：  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> WINAPI <span class="title">WinMain</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">	_In_ HINSTANCE hInstance,</span></span></span><br><span class="line"><span class="function"><span class="params">	_In_opt_ HINSTANCE hPrevInstance,</span></span></span><br><span class="line"><span class="function"><span class="params">	_In_ LPTSTR lpCmdLine,</span></span></span><br><span class="line"><span class="function"><span class="params">	_In_ <span class="keyword">int</span> nCmdShow)</span></span>&#123;</span><br><span class="line">	MessageBox(<span class="literal">NULL</span>,<span class="string">"Hello world!"</span>,<span class="string">"Hello world!"</span>,MB_OK|MB_ICONINFORMATION);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果运行正常的话，会显示一个消息框，像这样：<br><img src="/post_images/msgbox.png" alt="MessageBox"><br>很明显，Windows程序的主函数和控制台应用程序不一样，包括参数，声明以及其他方面。  </p>
<h2 id="头部注解"><a href="#头部注解" class="headerlink" title="头部注解"></a>头部注解</h2><h3 id="In"><a href="#In" class="headerlink" title="_In_"></a>_In_</h3><blockquote>
<p><code>_In_</code>批注是标量、 结构、 指向结构的指针和类似的输入的参数。 显式可基于简单的标量。 该参数前的状态必须是有效，并且不会被修改。</p>
<p align="right">–MSDN</p>
</blockquote>
<h3 id="In-opt"><a href="#In-opt" class="headerlink" title="_In_opt_"></a>_In_opt_</h3><blockquote>
<p><code>_In_opt_</code>批注是标量、 结构、 指向结构的指针和类似的输入的参数。 显式可基于简单的标量。 该参数可能为null，并且不会被修改。</p>
<p align="right">–MSDN</p>
</blockquote>
<h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><h3 id="hInstance-in"><a href="#hInstance-in" class="headerlink" title="hInstance[in]"></a>hInstance[in]</h3><p>当前进程实例，作为指针被Windows函数库引用，在注册窗口类时会用到。   </p>
<h3 id="hPrevInstance-in-opt"><a href="#hPrevInstance-in-opt" class="headerlink" title="hPrevInstance[in,opt]"></a>hPrevInstance[in,opt]</h3><p>应用程序的<s>卵用没有的</s>上一个实例，在非16位系统中总是NULL，所以，<strong>不要引用这个参数。</strong><br>&lt;注意&gt;hPrevInstance会引发Visual Studio的“参数没有引用”警告，会用pragma的大佬们可以禁用这个警告，但是对蒟蒻来说怎么办？仅需一行代码：<br><code>hPrevInstance;</code><br>简单粗暴！</p>
<h3 id="lpCmdLine-in"><a href="#lpCmdLine-in" class="headerlink" title="lpCmdLine[in]"></a>lpCmdLine[in]</h3><p>字面意思，应用程序的命令行(Command Line)，和CUI(Console User Interface，控制台用户界面)main函数的(char** argv)相似，区别如下：<br>在cmd中，输入<code>test.exe 1 2 3</code>，<br> 如果test.exe是CUI程序，则<code>argc=4</code>,<code>argv = {&quot;[DIR]/test.exe&quot;, &quot;1&quot;, &quot;2&quot;, &quot;3&quot;}</code><br>如果test.exe是GUI程序，则<code>lpCmdLine=&quot;[DIR]/test.exe 1 2 3&quot;</code><br>所以，Win32有一个函数叫CommandLineToArgvW，用于将一整个命令行转换为类似argv的形式。但是这个函数只支持Unicode(不懂的自行科普)。</p>
<h3 id="nCmdShow-in"><a href="#nCmdShow-in" class="headerlink" title="nCmdShow[in]"></a>nCmdShow[in]</h3><p>指示窗口应以何种方式显示，包括最小化、最大化等值。更新窗口时会用到。详细了解请<a href="https://msdn.microsoft.com/zh-cn/library/windows/desktop/ms633559.aspx" target="_blank" rel="noopener">点击</a>（没有中文版很蛋疼）</p>
<h2 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h2><h3 id="WINAPI-APIENTRY-CALLBACK"><a href="#WINAPI-APIENTRY-CALLBACK" class="headerlink" title="WINAPI/APIENTRY/CALLBACK"></a>WINAPI/APIENTRY/CALLBACK</h3><p>这三个宏实际上是同一个关键字，被定义为<code>__stdcall</code>，指示把堆栈从右向左压入栈，而不是默认的<code>__cdecl</code>的从左向右。后两个常见于VS的示例程序中。   </p>
<h3 id="函数名-Dev-cpp用户请跳过"><a href="#函数名-Dev-cpp用户请跳过" class="headerlink" title="函数名(Dev-cpp用户请跳过)"></a>函数名(Dev-cpp用户请跳过)</h3><p>有一点要特别注意，如果读者使用Unicode进行编写，需要在主函数的函数名前面加上w。如<code>main</code>-&gt;<code>wmain</code>，<code>WinMain</code>-&gt;<code>wWinMain</code>。  </p>
<h2 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h2><p>返回值其实没有什么太大的限制，只是一个错误提示罢了，有窗口的windows程序返回0代表有错误并终止程序，返回非0值代表正常退出。<br>在大多数作者的文章上，WinMain的返回值往往是<code>msg.wParam</code>，这个是什么暂时不用管，知道它是一个非0值就可以了。</p>
]]></content>
      <categories>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>Windows</tag>
      </tags>
  </entry>
</search>
